<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>手机应用界面</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250825/5nvZ/1280X1280/3d8950a849829447f24466a851153f8f.jpg/webp">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/remixicon@4.2.0/fonts/remixicon.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <!-- 邀請函專用字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Uncial+Antiqua&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS变量定义 */
        :root {
            --moments-cover-image: url('https://placehold.co/375x192/333/fff?text=Cover');
            --moments-avatar-image: url('https://placehold.co/128x128/777/FFF?text=Me');
        }

        /* 新增：长按删除的震动动画 */
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
          20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        .ticket-wrapper.deleting {
          animation: shake 0.5s ease-in-out;
        }

        /* ====== iOS Safari 全屏适配专用样式 ====== */

        /* 仅在全屏模式下生效 */
        body.standalone-mode {
            /* 移除外边距，确保全屏 */
            margin: 0;
            overflow: hidden; /* 防止意外的滚动 */
        }

        /* 仅在全屏模式下，重定义 phone-frame 的样式 */
        .standalone-mode .phone-frame {
            width: 100vw; /* 宽度占满屏幕 */
            height: 100vh; /* 高度占满屏幕 */
            max-width: none; /* 移除最大宽度限制 */
            border-radius: 0; /* 移除边框圆角 */
            padding: 0; /* 移除内边距 */
            box-shadow: none; /* 移除阴影 */
        }

        /* 仅在全屏模式下，重定义 phone-screen 的样式 */
        .standalone-mode #phone-screen {
            border-radius: 0; /* 移除内屏幕的圆角 */
            /* 添加安全区域边距，防止内容被刘海和底部横条遮挡 */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* 仅在全屏模式下，调整自定义状态栏的位置 */
        .standalone-mode #status-bar {
            /* 不再需要绝对定位，它会自然地待在顶部安全区域内 */
            position: static;
            /* 或者，如果布局需要，可以这样微调 */
            /* top: env(safe-area-inset-top); */
        }

        /* 仅在全屏模式下，调整Dock栏的位置，防止被底部横条遮挡 */
        .standalone-mode .dock {
            /* 在原有 bottom 间距的基础上，增加底部安全区域的高度 */
            bottom: calc(1rem + env(safe-area-inset-bottom));
        }

        /* 修复：防止 iOS 输入框聚焦时页面自动放大 */
        #chat-input:focus {
            font-size: 16px !important;
        }

/* ====== 全屏无边框模式 ====== */
.fullscreen-mode {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    max-width: none;
    border-radius: 0;
    padding: 0;
    margin: 0;
    box-shadow: none;
    overflow: hidden;
}

.fullscreen-mode .phone-frame {
    width: 100%;
    height: 100%;
    border-radius: 0;
    padding: 0;
    box-shadow: none;
}

.fullscreen-mode .phone-screen {
    border-radius: 0;
}

.fullscreen-mode #status-bar {
    top: env(safe-area-inset-top);
    left: env(safe-area-inset-left);
    right: env(safe-area-inset-right);
    padding-top: env(safe-area-inset-top);
}

.fullscreen-toggle-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 10000;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(0,0,0,0.7);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border: none;
    outline: none;
}

        /* ======================================================== */
        /* ====== 交互式机票邀请函 V5.0 (横版下方展开) ====== */
        /* ======================================================== */

        /* 1. 整体容器 */
        .ticket-wrapper {
            position: relative;
            width: 260px;
            height: 150px;
            cursor: pointer;
            margin: 2rem auto; /* 居中显示 */
        }

        /* 2. 票夹 (Sleeve) */
        .sleeve {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 110px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            z-index: 10;
            transition: transform 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.5rem;
        }
        .sleeve-content .main-title {
            font-family: 'Noto Serif SC', serif;
            font-weight: 700;
            font-size: 1.1rem; /* 已缩小 */
            letter-spacing: 0.1em;
            color: #dc2626;
            text-shadow: 0 0 8px rgba(220, 38, 38, 0.3);
        }
        .sleeve-content .subtitle {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.45rem;
            color: rgba(255,255,255,0.4);
            letter-spacing: 0.1em;
            margin-top: 0.3rem;
            text-transform: uppercase;
        }

        /* 3. 机票 (Ticket) */
        .ticket {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            height: 130px;
            background-color: #fdfbf6;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: row;
            z-index: 5;
            transition: transform 0.5s ease-out;
        }

        /* 4. 机票主区域和票根 */
        .ticket-main {
            flex-grow: 1;
            padding: 0.8rem 1rem;
            display: flex;
            flex-direction: column;
            border-right: 2px dashed #c9c1b3;
        }
        .ticket-stub {
            flex-shrink: 0;
            width: 50px; /* 已缩小 */
            background-color: #e9e5de;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
            color: #991B1B;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            border-radius: 0 8px 8px 0;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        /* 5. 机票内部内容样式 */
        .ticket .info-header {
            display: flex;
            justify-content: space-between;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.5rem;
            color: #b0a696;
            text-transform: uppercase;
        }
        .ticket .event-title {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: #991B1B;
            text-align: left;
            line-height: 1.3;
            margin: 0.5rem 0;
        }
        .ticket .event-details {
            display: flex;
            gap: 1rem;
            font-family: 'Source Code Pro', monospace;
            color: #991B1B;
            margin-top: auto;
        }
        .ticket .detail-item span {
            display: block;
            font-size: 0.5rem;
            color: #b0a696;
            margin-bottom: 0.1rem;
            text-transform: uppercase;
        }
        .ticket .detail-item strong {
            font-size: 0.7rem;
            font-weight: 600;
            white-space: nowrap;
        }

        /* 6. 动画触发样式 (通过JS添加 .open 类) */
        .ticket-wrapper.open .sleeve {
            transform: translateY(40px); /* 票夹向下滑动，距离更近 */
        }
        .ticket-wrapper.open .ticket {
            transform: translate(-50%, -40px); /* 机票向上滑动，距离更近 */
        }

        /* 基础字体样式 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Noto Serif SC', 'Inter', sans-serif;
        }

        /* 字体大小调整 */
        #phone-screen {
            /* V36.0 新增：定义一个CSS变量用于自定义字体 */
            --custom-font: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Noto Serif SC', 'Inter', sans-serif;

            font-size: 15px; /* 中 (默认) */
            transition: font-size 0.2s ease-in-out;
            /* V36.0 修改：使用变量来设置字体 */
            font-family: var(--custom-font);
        }
        #phone-screen.text-size-small {
            font-size: 13.5px; /* 小 */
        }
        #phone-screen.text-size-large {
            font-size: 16.5px; /* 大 */
        }
        
        /* 應用程式圖示互動效果 */
        .app-icon {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background-size: cover;
            background-position: center;
        }
        .app-icon:hover {
            transform: scale(1.05);
        }
        .app-icon:active {
            transform: scale(0.95);
            box-shadow: none;
        }

        .app-icon-glass {
            background: rgba(55, 65, 81, 0.5); /* bg-gray-600 with 50% opacity */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* 訊息提示框樣式 */
        .message-box {
            position: absolute; /* 相對於父容器phone-screen定位 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem 2rem;
            border-radius: 1rem;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 11000; /* Ensure it's above everything */
        }
        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* 淡入動畫 */
        .animate-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .hidden {
            display: none;
        }
        
        /* 黑膠唱片旋轉動畫 */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .record-spin {
            animation: spin 12s linear infinite;
        }
        /* 接收按钮动画 - 极简优雅版 */
        /* 邮件发送图标闪烁动画 - 保持图标不变，只改变显示效果 */
        @keyframes mail-send-flash {
            0% { opacity: 1; filter: brightness(1); }
            25% { opacity: 0.6; filter: brightness(0.8); }
            50% { opacity: 1; filter: brightness(1.2); }
            75% { opacity: 0.6; filter: brightness(0.8); }
            100% { opacity: 1; filter: brightness(1); }
        }
        
        .spinning {
            animation: mail-send-flash 1.2s ease-in-out infinite;
        }
        
        /* --- 未读消息红点样式 --- */
        .wechat-list-item .avatar {
            position: relative;
        }

        .unread-badge {
            position: absolute;
            top: 0px;
            right: 0px;
            background-color: #fa3e3e;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            border: 1.5px solid rgba(255, 255, 255, 0.9); /* 边框更细，且略带透明 */
        }
        
        .dark-mode .unread-badge {
            border-color: rgba(26, 26, 26, 0.9); /* 深色模式下，使用略带透明的深色边框 */
        }
        
        /* 接收按钮悬停效果 */
        #receive-chat-button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #receive-chat-button:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        #receive-chat-button:active {
            transform: scale(0.98);
        }
        
        /* 隱藏文件輸入框 */
        #music-upload-input, #background-input, #vinyl-input, #widget-image-input, #photo-widget-input, #wallpaper-input, #character-avatar-input, #user-avatar-input, #chat-bg-input, #import-data-input, #image-upload-input, #sticker-upload-input, #user-video-image-input, #my-video-image-input, #moment-image-input {
            display: none;
        }
        
        .music-block-background {
            background-image: url('https://placehold.co/400x150/1a1a1a/ffffff?text=UPLOAD+BACKGROUND');
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        
        .vinyl-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            border-radius: 50%;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .vinyl-image-container {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 67%;
            height: 67%;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background-image: url('https://placehold.co/100x100/000000/ffffff?text=UPLOAD');
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        
        .vinyl-center {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 1rem;
            height: 1rem;
            background-color: #f3f4f6;
            border-radius: 50%;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 9000;
            display: none;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            display: flex;
        }
        .modal-content {
            width: 80%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
        }
        
        /* 日夜间模式下的模态框背景 */
        .dark-mode .modal-content {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .light-mode .modal-content {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* 日间模式下删除确认对话框的文字颜色 */
        .light-mode #confirm-delete-modal .modal-content {
            color: #1f2937;
        }
        
        .light-mode #confirm-delete-modal .modal-content h3,
        .light-mode #confirm-delete-modal .modal-content p {
            color: #1f2937;
        }
        
        .light-mode #confirm-delete-modal .modal-content button:not(.bg-red-600) {
            color: #4b5563;
        }
        
        /* 日间模式下其他模态框的文字颜色 */
        .light-mode .modal-content h3,
        .light-mode .modal-content label {
            color: #1f2937;
        }
        
        .light-mode .modal-content button:not(.bg-red-600):not(.bg-blue-600):not(.bg-gray-700) {
            color: #4b5563;
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        /* 表情包添加模态框专用样式 */
        .sticker-modal-content {
            width: 90%;
            max-width: 280px;
            padding: 0;
            border-radius: 1rem;
        }
        
        .sticker-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1rem 0.75rem 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* 日夜间模式下的头部边框 */
        .dark-mode .sticker-modal-header {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .sticker-modal-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }
        
        .sticker-modal-close {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            color: #1f2937;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .sticker-modal-close:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: scale(1.1);
        }
        
        /* 日夜间模式下的标题和关闭按钮 */
        .dark-mode .sticker-modal-title {
            color: #ffffff;
        }
        
        .dark-mode .sticker-modal-close {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .dark-mode .sticker-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sticker-modal-body {
            padding: 1rem;
        }
        
        .sticker-input-group {
            margin-bottom: 1rem;
        }
        
        .sticker-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #4b5563;
            margin-bottom: 0.5rem;
        }
        
        .sticker-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            color: #1f2937;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        .sticker-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(0, 0, 0, 0.02);
        }
        
        /* 日夜间模式下的标签和输入框 */
        .dark-mode .sticker-label {
            color: #d1d5db;
        }
        
        .dark-mode .sticker-input {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        
        .dark-mode .sticker-input:focus {
            border-color: #60a5fa;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .sticker-upload-btn {
            width: 100%;
            padding: 0.75rem;
            background: rgba(59, 130, 246, 0.8);
            border: none;
            border-radius: 0.5rem;
            color: #ffffff;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 1rem;
        }
        
        .sticker-upload-btn:hover {
            background: rgba(59, 130, 246, 1);
            transform: translateY(-1px);
        }
        
        .sticker-url-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .sticker-url-group .sticker-input {
            flex: 1;
        }
        
        .sticker-add-btn {
            padding: 0.5rem 1rem;
            background: rgba(34, 197, 94, 0.8);
            border: none;
            border-radius: 0.5rem;
            color: #ffffff;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .sticker-add-btn:hover {
            background: rgba(34, 197, 94, 1);
            transform: translateY(-1px);
        }

        .song-list-item {
            padding: 0.75rem 0.5rem;
            border-radius: 0.75rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: default;
        }
        .song-list-item:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .song-list-item.active {
            font-weight: 600;
            color: #ffffff;
        }
        .song-list-item-left {
            display: flex;
            align-items: center;
            flex-grow: 1;
            min-width: 0;
        }
        .song-list-item-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        .drag-handle {
            cursor: grab;
            padding-right: 0.75rem;
            color: #9ca3af;
        }
        .delete-button {
            cursor: pointer;
            transition: color 0.2s;
            padding-left: 0.75rem;
        }
        .delete-button.pending-delete {
            color: #ef4444;
        }

        .player-button {
            transition: color 0.2s;
        }

        .loop-button.active, .single-loop-button.active {
            color: #ffffff;
        }
        
        .text-widget-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            padding: 0.25rem 0;
        }
        
        .image-placeholder {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: cover;
            background-position: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 日夜间模式样式 */
        .dark-mode {
            background-color: #333333;
            color: #ffffff;
        }
        .dark-mode .phone-frame { background-color: #1a1a1a; }
        .dark-mode .phone-screen { background-color: transparent; }
        .dark-mode #home-wallpaper { 
            background-color: #000000; 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .dark-mode .status-bar, .dark-mode .text-dark, .dark-mode .player-button i, .dark-mode #music-upload-button i, .dark-mode #mood-text::placeholder, .dark-mode #playlist-button i, .dark-mode .text-widget-input::placeholder, .dark-mode .app-header-btn, .dark-mode .quick-action-btn { color: #ffffff; }
        .dark-mode .status-bar { transition: background-color 0.3s; background-color: #1a1a1a; }
        .dark-mode .status-bar.on-home { background-color: transparent !important; }
        .dark-mode .dock, .dark-mode .music-block {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .dark-mode .app-screen-view:not(#home-screen):not(#wechat-chat-screen) { background-color: #1a1a1a; }
        .dark-mode #wechat-chat-screen { background-color: #1a1a1a; }
        .dark-mode .app-header { 
            background-color: rgba(26, 26, 26, 0.9); 
            border-color: rgba(255, 255, 255, 0.15); 
        }
        .dark-mode .wechat-tab-bar { background-color: #2c2c2c; border-color: #4a4a4a; }
        .dark-mode .image-placeholder { background-color: rgba(255, 255, 255, 0.2); }
        .dark-mode .bg-card { background-color: rgba(255, 255, 255, 0.08); }
        .dark-mode .settings-item, .dark-mode .list-item { background-color: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); }
        .dark-mode .wechat-list-item { border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .dark-mode .wechat-list-item:hover { background-color: rgba(255, 255, 255, 0.1); }
        .dark-mode .api-status-on { color: #ffffff; }
        .dark-mode .chat-input-btn { color: #d1d5db; }
        .dark-mode .chat-system-message { background-color: rgba(255, 255, 255, 0.1); }
        
        .light-mode { background-color: white; color: #1f2937; }
        .light-mode .phone-frame { background-color: #1a1a1a; }
        .light-mode .phone-screen { background-color: transparent; }
        .light-mode #home-wallpaper { 
            background: white; 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .light-mode .status-bar, .light-mode .text-dark, .light-mode .app-header-btn, .light-mode .quick-action-btn { color: #1f2937; }
        .light-mode .status-bar { transition: background-color 0.3s; background-color: #ffffff; }
        .light-mode .status-bar.on-home { background-color: transparent !important; }
        .light-mode .player-button i, .light-mode #music-upload-button i, .light-mode #playlist-button i, .light-mode .text-widget-input::placeholder { color: #1f2937; }
        .light-mode #mood-text { color: #1f2937; }
        .light-mode #mood-text::placeholder { color: #9ca3af; }
        .light-mode .dock, .light-mode .music-block {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .light-mode .app-screen-view:not(#home-screen):not(#wechat-chat-screen) { background-color: white; }
        .light-mode #wechat-chat-screen { background-color: white; }
        .light-mode .app-header { 
            background-color: rgba(255, 255, 255, 0.9); 
            border-color: rgba(0, 0, 0, 0.1); 
        }
        .light-mode .wechat-tab-bar { background-color: #ffffff; border-color: #e5e7eb; }
        .light-mode .image-placeholder { background-color: rgba(0, 0, 0, 0.1); }
        .light-mode .bg-card { background-color: #ffffff; }
        .light-mode .settings-item, .light-mode .list-item { background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .light-mode .wechat-list-item { border-bottom: 1px solid rgba(0, 0, 0, 0.08); }
        .light-mode .wechat-list-item:hover { background-color: rgba(0, 0, 0, 0.05); }
        .light-mode .api-status-on { color: #1f2937; }
        .light-mode .chat-input-btn { color: #4b5563; }
        .light-mode .chat-system-message { background-color: rgba(0, 0, 0, 0.1); }

        /* 主界面背景样式 - 确保背景图片正确显示 */
        #home-wallpaper {
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
        }

        /* 聊天界面样式 */
        #wechat-content-chat {
            padding-top: 0.5rem;
        }
        #wechat-content-chat .chat-message-wrapper.new-sender:first-child {
            margin-top: 0.5rem;
        }
        .chat-message-wrapper {
            display: flex;
            align-items: flex-start;
            width: 100%;
            position: relative;
        }
        .chat-message-wrapper.sent {
            justify-content: flex-end;
        }
        .chat-message-wrapper.received {
            justify-content: flex-start;
        }
        .chat-message-wrapper + .chat-message-wrapper {
            margin-top: 0.25rem; 
        }
        .chat-message-wrapper.new-sender {
            margin-top: 1rem;
        }
        .chat-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: #9ca3af;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chat-avatar i {
            font-size: 22px;
            color: rgba(255, 255, 255, 0.8);
        }
        .light-mode .chat-avatar i {
             color: rgba(0, 0, 0, 0.6);
        }
        .chat-message-content {
            display: flex;
            flex-direction: column;
            min-width: 0;
            margin: 0 0.5rem;
            max-width: 75%;
        }
        .chat-message-wrapper.sent .chat-message-content { align-items: flex-end; }
        .chat-message-wrapper.received .chat-message-content { align-items: flex-start; }
        .chat-message {
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border-radius: 1.5rem;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 4px 16px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            padding: 0.35rem 1rem;
            width: -moz-fit-content;
            width: fit-content;
            max-width: 100%; 
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: 
                linear-gradient(135deg, 
                    rgba(255, 255, 255, 0.1) 0%, 
                    rgba(255, 255, 255, 0.05) 50%, 
                    rgba(255, 255, 255, 0.02) 100%
                );
            overflow: hidden;
        }
        
        .chat-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transition: left 0.6s ease;
        }
        
        .chat-message:hover::before {
            left: 100%;
        }
        
        .chat-message:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.18),
                0 6px 20px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }
        .chat-message.image-message, .chat-message.sticker-message {
            padding: 0.25rem;
            background-color: transparent !important;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .chat-message.image-message img, .chat-message.sticker-message img {
            max-width: 150px;
            max-height: 200px;
            border-radius: 1rem;
            display: block;
        }
        .chat-message.sticker-message img {
            max-width: 100px;
            max-height: 100px;
        }
        .chat-message.voice-message {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .voice-main {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .voice-play-icon {
            font-size: 1.25rem;
        }
        .voice-duration {
            font-size: 0.8em;
            white-space: nowrap;
        }
        .voice-text {
            padding-top: 0.5rem;
            margin-top: 0.5rem;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 0.9em;
            display: none;
        }
        .chat-message p, .chat-message i {
            font-size: inherit;
            line-height: 1.5;
        }

        .chat-message.image-message::before, .chat-message.voice-message::before, .chat-message.sticker-message::before, .chat-message.red-packet-message::before, .chat-message.transfer-message::before {
            display: none;
        }
        .chat-message::after {
            content: '';
            position: absolute;
            bottom: 6px;
            width: 14px;
            height: 14px;
            background: inherit;
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 12C5.33333 12 12 5.33333 12 0C12 5.33333 5.33333 12 0 12Z' fill='%23C4C4C4'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 12C5.33333 12 12 5.33333 12 0C12 5.33333 5.33333 12 0 12Z' fill='%23C4C4C4'/%3E%3C/svg%3E");
        }
        .chat-message.image-message::after, .chat-message.sticker-message::after, .chat-message.red-packet-message::after, .chat-message.transfer-message::after {
            display: none;
        }
        .chat-message.sent::after {
            right: -7px;
            transform: scaleX(-1);
            border-radius: 0 0 14px 0;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .chat-message.received::after {
            left: -7px;
            border-radius: 0 0 0 14px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .message-meta {
            font-size: 0.65rem;
            color: #9ca3af;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            margin-bottom: 5px;
            white-space: nowrap;
            align-self: flex-end;
        }
        .chat-message-wrapper.sent .message-meta {
            align-items: flex-end;
        }
        .chat-message-wrapper.received .message-meta {
            align-items: flex-start;
        }
        .message-read-status {
            margin-left: 0;
            display: none;
        }
        .message-read-status.visible {
            display: inline;
        }
        .dark-mode .chat-message { 
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 3px 15px rgba(0,0,0,0.12), 0 1px 6px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        .light-mode .chat-message { 
            border: 1px solid rgba(0, 0, 0, 0.06);
            box-shadow: 0 3px 15px rgba(0,0,0,0.08), 0 1px 6px rgba(0,0,0,0.04), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        /* 用户气泡颜色修改 - 水滴毛玻璃效果 */
        .dark-mode .chat-message.sent { 
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3));
            color: #f3f4f6;
        }
        .light-mode .chat-message.sent { 
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4));
            color: #f3f4f6;
        }
        .dark-mode .chat-message.received { 
            background: linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1));
        }
        .light-mode .chat-message.received { 
            background: linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3));
        }
        .dark-mode .chat-message.sent.image-message, .light-mode .chat-message.sent.image-message { border: 2px solid #4b5563; }
        .dark-mode .chat-message.received.image-message, .light-mode .chat-message.received.image-message { border: 2px solid rgba(229, 231, 250, 0.8); }

        /* ====== 画板样式 ====== */
        .drawing-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .drawing-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .drawing-modal-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .drawing-modal-content {
            background: white;
            border-radius: 20px;
            padding: 0;
            max-width: 500px;
            max-height: 800px;
            width: 90%;
            height: 90%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .drawing-modal-overlay.visible .drawing-modal-content {
            transform: scale(1);
        }

        .drawing-modal-header {
            background: linear-gradient(135deg, #2c2c2c 0%, #666666 50%, #a0a0a0 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 20px 20px 0 0;
        }

        .drawing-modal-title {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .drawing-modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .drawing-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .drawing-board-container {
            padding: 20px;
        }

        #drawing-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            cursor: crosshair;
            background: white;
            display: block;
            margin: 0 auto 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 400px;
            height: 300px;
        }

        .drawing-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            justify-content: center;
            max-width: 280px;
            margin: 0 auto;
        }

        .color-swatch {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .color-swatch.selected {
            border-color: #667eea;
            transform: scale(1.1);
        }

        .brush-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }
        
        .brush-preview {
            width: 40px;
            height: 40px;
            border: 2px solid #e5e7eb;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
        }
        
        #brush-preview-circle {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: #000000;
            transition: all 0.2s ease;
        }

        .brush-size-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .brush-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .brush-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        #brush-size-value {
            font-size: 14px;
            color: #6b7280;
            min-width: 40px;
            text-align: center;
        }

        .drawing-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .drawing-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .drawing-btn.secondary {
            background: #f3f4f6;
            color: #6b7280;
        }

        .drawing-btn.secondary:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .drawing-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .drawing-btn.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .drawing-modal-content {
                margin: 15px;
                max-width: calc(100% - 30px);
                max-height: calc(100% - 30px);
                width: calc(100% - 30px);
                height: calc(100% - 30px);
            }
            
            #drawing-canvas {
                width: 100%;
                height: 75vw;
                max-width: 300px;
                max-height: 225px;
            }
            
            .drawing-tools {
                gap: 10px;
            }
            
            .color-palette {
                grid-template-columns: repeat(6, 1fr);
                gap: 5px;
                max-width: 180px;
            }
            
            .color-swatch {
                width: 20px;
                height: 20px;
            }
        }
        


        /* ====== 塔罗牌样式 ====== */
        /* 确保塔罗牌界面不受其他样式影响 */
        html, body {
            overflow: visible !important;
            position: relative !important;
        }
        
        .tarot-modal-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 20, 0.98) 100%);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 99999 !important;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .tarot-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .tarot-modal-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .tarot-modal-content {
            background: linear-gradient(145deg, #0a0a0a 0%, #1a1a1a 25%, #2a2a2a 50%, #3a3a3a 75%, #1a1a1a 100%);
            border-radius: 25px;
            padding: 0;
            max-width: 420px;
            max-height: 90vh;
            width: 90%;
            height: auto;
            min-height: 600px;
            overflow: hidden;
            box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(128, 128, 128, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: scale(0.7) rotateY(-15deg);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            position: relative;
            box-sizing: border-box;
            margin: 0;
        }

        .tarot-modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: none;
            border-radius: 25px;
            animation: none;
            pointer-events: none;
            z-index: 1;
            box-sizing: border-box;
        }

        .tarot-modal-content::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: none;
            border-radius: 25px;
            z-index: 0;
            animation: none;
            opacity: 0;
            box-sizing: border-box;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.2; transform: translateX(-100%); }
            50% { opacity: 0.5; transform: translateX(100%); }
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tarot-modal-overlay.visible .tarot-modal-content {
            transform: scale(1) rotateY(0deg);
        }

        .tarot-modal-header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 50%, #3a3a3a 100%);
            color: #e0e0e0;
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 25px 25px 0 0;
            position: relative;
            overflow: hidden;
            z-index: 3;
            margin: 0;
        }

        .tarot-modal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            animation: headerShine 4s ease-in-out infinite;
        }

        @keyframes headerShine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        .tarot-modal-title {
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(45deg, #ffffff, #cccccc, #ffffff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        @keyframes titleGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tarot-modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .tarot-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .tarot-container {
            padding: 25px;
            text-align: center;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
            min-height: 400px;
        }

        .tarot-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(128, 128, 128, 0.05) 0%, transparent 80%),
                radial-gradient(circle at 80% 80%, rgba(64, 64, 64, 0.05) 0%, transparent 80%);
            pointer-events: none;
        }

        .tarot-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.05) 0%, transparent 25px),
                radial-gradient(circle at 75% 75%, rgba(128, 128, 128, 0.05) 0%, transparent 25px),
                radial-gradient(circle at 50% 10%, rgba(64, 64, 64, 0.05) 0%, transparent 20px),
                radial-gradient(circle at 10% 60%, rgba(255, 255, 255, 0.05) 0%, transparent 20px),
                radial-gradient(circle at 90% 40%, rgba(128, 128, 128, 0.05) 0%, transparent 20px);
            animation: particleFloat 8s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes particleFloat {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg);
                opacity: 0.2;
            }
            25% { 
                transform: translateY(-8px) rotate(90deg);
                opacity: 0.4;
            }
            50% { 
                transform: translateY(-4px) rotate(180deg);
                opacity: 0.3;
            }
            75% { 
                transform: translateY(-12px) rotate(270deg);
                opacity: 0.5;
            }
        }

        @keyframes darkGradientShift {
            0%, 100% { 
                background-position: 0% 50%;
            }
            25% { 
                background-position: 100% 50%;
            }
            50% { 
                background-position: 100% 100%;
            }
            75% { 
                background-position: 0% 100%;
            }
        }

        .tarot-card-display {
            margin-bottom: 12px;
            flex-shrink: 0;
            position: relative;
        }

        .tarot-card-back {
            width: 180px;
            height: 260px;
            margin: 0 auto;
            background: linear-gradient(145deg, #1a1a1a 0%, #2a2a2a 25%, #3a3a3a 50%, #4a4a4a 75%, #2a2a2a 100%);
            border-radius: 16px;
            border: 2px solid #666666;
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.6),
                0 0 25px rgba(128, 128, 128, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .tarot-card-back::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.05) 0%, transparent 80%),
                radial-gradient(circle at 70% 70%, rgba(255, 255, 255, 0.03) 0%, transparent 80%);
            animation: cardGlow 3s ease-in-out infinite;
        }

        .tarot-card-back::after {
            content: '✧';
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite;
        }

        .tarot-card-back .symbol-top-right {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 0.5s;
        }

        .tarot-card-back .symbol-bottom-left {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 16px;
            color: rgba(128, 128, 128, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 1s;
        }

        .tarot-card-back .symbol-bottom-right {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 16px;
            color: rgba(192, 192, 192, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 1.5s;
        }

        @keyframes symbolTwinkle {
            0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(180deg); }
        }

        @keyframes cardGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .tarot-card-back:hover {
            transform: translateY(-8px) rotateY(5deg);
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.7),
                0 0 40px rgba(128, 128, 128, 0.6);
        }

        .card-back-pattern {
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            bottom: 25px;
            background: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 15px,
                    rgba(255, 255, 255, 0.08) 15px,
                    rgba(255, 255, 255, 0.08) 30px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 15px,
                    rgba(255, 255, 255, 0.05) 15px,
                    rgba(255, 255, 255, 0.05) 30px
                );
            border-radius: 15px;
            opacity: 0.8;
        }

        .card-back-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            background: linear-gradient(45deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: textPulse 2s ease-in-out infinite;
        }

        @keyframes textPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .tarot-card-front {
            width: 180px;
            height: 260px;
            margin: 0 auto;
            background: linear-gradient(145deg, #f5f5f5 0%, #e8e8e8 25%, #d8d8d8 50%, #c8c8c8 75%, #f5f5f5 100%);
            border-radius: 16px;
            border: 2px solid #999999;
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.5),
                0 0 25px rgba(128, 128, 128, 0.3);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform: rotateY(180deg);
            transform-style: preserve-3d;
        }

        .tarot-card-front.flipped {
            transform: rotateY(0deg);
        }

        .card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 17px;
        }

        .tarot-info {
            margin: 15px 0 8px 0;
            padding: 15px;
            background: linear-gradient(135deg, rgba(26, 26, 26, 0.8) 0%, rgba(42, 42, 42, 0.8) 100%);
            border-radius: 12px;
            border: 1px solid rgba(128, 128, 128, 0.3);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .tarot-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(128, 128, 128, 0.05) 50%, 
                transparent 100%);
            animation: infoShimmer 4s ease-in-out infinite;
        }

        @keyframes infoShimmer {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .card-name {
            margin: 0 0 12px 0;
            font-size: 19px;
            font-weight: bold;
            background: linear-gradient(45deg, #ffffff, #cccccc, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .card-meaning {
            margin: 0 0 15px 0;
            font-size: 15px;
            line-height: 1.6;
            color: #e0e0e0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .card-orientation {
            margin-top: 10px;
        }

        .orientation-text {
            padding: 8px 18px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(192, 192, 192, 0.1) 100%);
            border-radius: 25px;
            font-size: 13px;
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(5px);
            animation: orientationPulse 3s ease-in-out infinite;
        }

        @keyframes orientationPulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .tarot-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 8px;
            padding-top: 12px;
            flex-shrink: 0;
        }

        .tarot-btn {
            padding: 12px 22px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 110px;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .tarot-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
            transition: left 0.5s ease;
        }

        .tarot-btn:hover::before {
            left: 100%;
        }

        .tarot-btn.primary {
            background: linear-gradient(135deg, #333333 0%, #666666 50%, #333333 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(128, 128, 128, 0.4);
            border: 1px solid rgba(128, 128, 128, 0.3);
        }

        .tarot-btn.primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(128, 128, 128, 0.6);
        }

        .tarot-btn.secondary {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .tarot-btn.secondary:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.2);
        }

        /* 塔罗牌响应式设计 */
        @media (max-width: 768px) {
            .tarot-modal-content {
                margin: 15px;
                max-width: calc(100% - 30px);
                max-height: 85vh;
                width: calc(100% - 30px);
                height: auto;
                min-height: 500px;
                transform: scale(0.9) rotateY(0deg);
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 160px;
                height: 240px;
            }
            
            .tarot-container {
                padding: 20px;
            }
            
            .tarot-actions {
                gap: 15px;
                margin-top: 20px;
            }
            
            .tarot-btn {
                padding: 12px 24px;
                min-width: 120px;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .tarot-modal-overlay {
                padding: 10px;
            }
            
            .tarot-modal-content {
                transform: scale(0.95) rotateY(0deg);
                max-width: 95%;
                max-height: 80vh;
                min-height: 450px;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 140px;
                height: 200px;
            }
            
            .tarot-actions {
                flex-direction: column;
                gap: 15px;
            }
            
            .tarot-btn {
                min-width: 100%;
                padding: 14px 24px;
                font-size: 15px;
            }
            
            .tarot-info {
                margin: 20px 0;
                padding: 18px;
            }
            
            .card-name {
                font-size: 19px;
            }
            
            .card-meaning {
                font-size: 14px;
            }
            

        

        }
        
        @media (max-width: 360px) {
            .tarot-modal-overlay {
                padding: 5px;
            }
            
            .tarot-modal-content {
                transform: scale(0.98) rotateY(0deg);
                max-width: 98%;
                max-height: 85vh;
                min-height: 400px;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 120px;
                height: 180px;
            }
            
            .tarot-info {
                margin: 15px 0;
                padding: 15px;
            }
            
            .card-name {
                font-size: 17px;
            }
            
            .card-meaning {
                font-size: 13px;
            }
            
            .tarot-btn {
                padding: 12px 20px;
                font-size: 14px;
            }
            

        }
        
        /* 移动端特殊处理 */
        @media (max-width: 768px) {
            .tarot-modal-overlay {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
                overflow: hidden !important;
            }
            
            .tarot-modal-content {
                position: relative !important;
                transform: scale(1) rotateY(0deg) !important;
                max-width: 95vw !important;
                max-height: 85vh !important;
                margin: 0 auto !important;
                min-height: 500px !important;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg) !important;
            }
        }
        
        /* 强制覆盖所有可能的定位问题 */
        .tarot-modal-overlay.visible {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 99999 !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* 修复垂直居中偏下的问题 */
        .tarot-modal-content {
            position: relative !important;
            transform: none !important;
            margin: 0 auto !important;
            max-height: 90vh !important;
            overflow-y: auto !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: center !important;
        }
        
        /* 移动端垂直居中优化 */
        @media (max-width: 768px) {
            .tarot-modal-content {
                max-height: 85vh !important;
                min-height: 500px !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-modal-content {
                max-height: 80vh !important;
                min-height: 450px !important;
            }
        }
        
        /* 更精确的垂直居中 */
        .tarot-modal-overlay.visible {
            align-items: center !important;
            padding-top: 2vh !important;
            padding-bottom: 2vh !important;
            overflow-y: auto !important;
        }
        
        /* 移动端塔罗牌卡片显示优化 */
        @media (max-width: 768px) {
            .tarot-card-display {
                margin-bottom: 20px;
            }
            
            .tarot-info {
                margin: 20px 0;
                padding: 20px;
            }
            
            .tarot-actions {
                margin-top: 25px;
                padding-bottom: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-card-display {
                margin-bottom: 25px;
            }
            
            .tarot-info {
                margin: 25px 0;
                padding: 22px;
            }
            
            .tarot-actions {
                margin-top: 30px;
                padding-bottom: 15px;
            }
        }
        
        /* 移动端更精确的垂直居中 */
        @media (max-width: 768px) {
            .tarot-modal-overlay.visible {
                padding-top: 3vh !important;
                padding-bottom: 3vh !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-modal-overlay.visible {
                padding-top: 2vh !important;
                padding-bottom: 2vh !important;
            }
        }
        
        /* 确保在移动端也能正确显示 */
        @media (orientation: portrait) {
            .tarot-modal-overlay {
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
            }
        }
        
        @media (orientation: landscape) {
            .tarot-modal-overlay {
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
            }
        }
        
        /* 确保按钮区域完全可见 */
        .tarot-buttons {
            margin-top: 15px !important;
            padding: 10px 0 !important;
            position: relative !important;
            z-index: 10 !important;
        }
        
        .tarot-btn {
            margin: 5px !important;
            position: relative !important;
            z-index: 10 !important;
        }
        

        
        /* 移动端按钮优化 */
        @media (max-width: 768px) {
            .tarot-buttons {
                margin-top: 20px !important;
                padding: 15px 0 !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-buttons {
                margin-top: 25px !important;
                padding: 20px 0 !important;
            }
        }
        .chat-system-message {
            background-color: rgba(128, 128, 128, 0.2);
            color: #d1d5db;
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            margin: 0.5rem auto;
            width: fit-content;
        }
        .light-mode .chat-system-message {
            color: #4b5563;
        }
        .chat-input-bar {
            background-color: transparent;
            border-top-width: 1px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .dark-mode .chat-input-bar { border-color: rgba(255, 255, 255, 0.1); }
        .light-mode .chat-input-bar { border-color: rgba(0, 0, 0, 0.1); }
        #chat-input {
            border: 1px solid transparent;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s, box-shadow 0.3s, height 0.2s ease-in-out;
            resize: none;
            overflow-y: auto;
            line-height: 1.5;
        }
        .dark-mode #chat-input { background-color: rgba(31, 41, 55, 0.8); color: #ffffff; }
        .light-mode #chat-input { background-color: rgba(243, 244, 246, 0.8); color: #1f2937; }
        .status-bar.transparent-override {
            background-color: transparent !important;
        }
        #wechat-chat-screen.has-custom-bg {
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            background-color: transparent !important; /* 确保覆盖默认背景色 */
        }

        #wechat-chat-screen.has-custom-bg .app-header,
        #wechat-chat-screen.has-custom-bg .chat-input-bar,
        #wechat-chat-screen.has-custom-bg #chat-quick-actions-bar {
                background: transparent !important; /* 将背景设置为完全透明 */
    backdrop-filter: none !important; /* 移除模糊效果 */
    -webkit-backdrop-filter: none !important; /* 移除模糊效果 */
            border-color: transparent !important;
        }

        .light-mode #wechat-chat-screen.has-custom-bg .app-header,
        .light-mode #wechat-chat-screen.has-custom-bg .chat-input-bar,
        .light-mode #wechat-chat-screen.has-custom-bg #chat-quick-actions-bar {
             background: transparent !important; /* 同样设置为完全透明 */
        }
        .chat-time-divider {
            display: none;
        }
        
        .bubble-context-menu {
            position: absolute;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 2rem;
            padding: 2px 4px;
            display: none;
            flex-direction: row;
            align-items: center;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateY(5px) scale(0.95);
            opacity: 0;
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
            visibility: hidden;
        }
        .bubble-context-menu.visible {
            display: flex;
            opacity: 1;
            transform: translateY(0) scale(1);
            visibility: visible;
        }
        .bubble-menu-button {
            background: none;
            border: none;
            color: #f0f0f0;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 11px;
            border-radius: 2rem;
            transition: background-color 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }
        .bubble-menu-button:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .bubble-menu-button:disabled {
            color: #6b7280;
            cursor: not-allowed;
        }
        .bubble-menu-button i {
            font-size: 12px;
            margin-right: 3px;
        }
        
        .chat-message-wrapper.selected .chat-message {
            background-color: rgba(59, 130, 246, 0.4) !important;
            border-color: rgba(96, 165, 250, 0.8) !important;
        }
        .light-mode .chat-message-wrapper.selected .chat-message {
             background-color: rgba(96, 165, 250, 0.5) !important;
        }


        .color-picker-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 1.75rem;
            height: 1.75rem;
            padding: 0;
            border: 2px solid rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            cursor: pointer;
            background-color: transparent;
        }
        .color-picker-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-picker-input::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
        .color-picker-input::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .app-header { 
            display: flex; 
            align-items: center; /* 垂直居中所有子元素 */
            justify-content: space-between; 
            padding: 0.5rem 1rem;
            height: 4.5rem; /* 增加标题栏高度以容纳多行文字 */
            flex-shrink: 0;
            position: relative; /* 确保z-index生效 */
            z-index: 20;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2); /* 中性边框颜色 */
            background: transparent;
        }

        .app-header .text-center {
            /* 这个容器包裹着中英文标题 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-header-title { 
            font-weight: 700; 
            font-size: 1.125em; /* 18px */
            color: inherit; /* 继承父元素颜色 */
            margin: 0; /* 移除任何可能的外边距 */
        }

        .app-header .text-xs {
            font-size: 0.75rem; /* 12px */
            color: inherit; /* 继承父元素颜色 */
            letter-spacing: 0.1em; /* 增加字母间距 */
            margin-top: 0.25rem; /* 与主标题的间距 */
        }
        .app-header-title.clickable { cursor: pointer; }
        .app-header-btn.text-pink-500 {
            color: #d1d5db;
        }
        .app-header-btn { font-size: 1.25em; }

        .list-item {
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 1rem;
            position: relative;
        }
        .list-item:hover {
            background-color: rgba(128, 128, 128, 0.1);
        }
        .list-item-delete-btn {
            position: absolute;
            top: -0.5rem;
            left: -0.5rem;
            width: 1.5rem;
            height: 1.5rem;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 10;
            animation: popIn 0.2s ease-out;
        }
        .deletable:hover .list-item-delete-btn {
            display: flex;
        }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }


        .form-input, .form-textarea, .form-select { width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid transparent; }
        .dark-mode .form-input, .dark-mode .form-textarea, .dark-mode .form-select { background-color: #2c2c2c; color: #ffffff; }
        .light-mode .form-input, .light-mode .form-textarea, .light-mode .form-select { background-color: #ffffff; color: #1f2937; border: 1px solid #e5e7eb; }

        /* 为form-select添加下拉选项的夜间模式样式 */
        .dark-mode .form-select option {
            background-color: #2c2c2c !important;
            color: #ffffff !important;
        }
        
        .light-mode .form-select option {
            background-color: #ffffff !important;
            color: #1f2937 !important;
        }
        
        /* 确保form-select在夜间模式下文字可见 */
        .dark-mode .form-select {
            color: #ffffff !important;
        }
        
        .light-mode .form-select {
            color: #1f2937 !important;
        }
        
        /* 针对不同浏览器的兼容性处理 */
        .dark-mode .form-select::-ms-expand {
            filter: invert(1);
        }
        
        .light-mode .form-select::-ms-expand {
            filter: invert(0);
        }
        
        /* Select元素在夜间模式下的特殊处理 - 自定义下拉箭头 */
        .dark-mode .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        .light-mode .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%231f2937' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        /* API输入框样式 - 支持日间夜间模式 */
        .api-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid transparent;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }
        
        /* 夜间模式API输入框 */
        .dark-mode .api-input {
            background-color: rgba(44, 44, 44, 0.9);
            color: #ffffff;
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        /* 日间模式API输入框 */
        .light-mode .api-input {
            background-color: rgba(255, 255, 255, 0.95);
            color: #1f2937;
            border-color: rgba(0, 0, 0, 0.15);
        }
        
        /* 夜间模式焦点状态 */
        .dark-mode .api-input:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.8);
            background-color: rgba(44, 44, 44, 1);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        /* 日间模式焦点状态 */
        .light-mode .api-input:focus {
            outline: none;
            border-color: #3b82f6;
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        
        /* 夜间模式占位符 */
        .dark-mode .api-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        /* 日间模式占位符 */
        .light-mode .api-input::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        /* Select 元素特殊样式 - 确保选项文字可见 */
        .dark-mode select.api-input option {
            background-color: #2c2c2c !important;
            color: #ffffff !important;
        }

        .light-mode select.api-input option {
            background-color: #ffffff !important;
            color: #1f2937 !important;
        }

        /* 确保select元素在夜間模式下文字可見 */
        .dark-mode select.api-input {
            color: #ffffff !important;
        }

        .light-mode select.api-input {
            color: #1f2937 !important;
        }

        /* 針對不同瀏覽器的兼容性處理 */
        .dark-mode select.api-input::-ms-expand {
            filter: invert(1);
        }

        .light-mode select.api-input::-ms-expand {
            filter: invert(0);
        }

        /* Select 元素在夜間模式下的特殊處理 */
        .dark-mode select.api-input {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

        .light-mode select.api-input {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%231f2937' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        .wb-checkbox-label { display: flex; align-items: center; padding: 0.5rem; border-radius: 0.5rem; cursor: pointer; }
        .wb-checkbox-label:hover { background-color: rgba(255, 255, 255, 0.1); }
        .wb-checkbox-label input { margin-right: 0.75rem; }

        /* 世界书多选选项容器夜间模式样式 */
        .dark-mode #cb-worldbook-select {
            background-color: rgba(44, 44, 44, 0.8);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        
        .light-mode #cb-worldbook-select {
            background-color: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.15);
            color: #1f2937;
        }
        
        /* 世界书多选选项标签夜间模式样式 */
        .dark-mode .wb-checkbox-label {
            color: #ffffff;
        }
        
        .dark-mode .wb-checkbox-label:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .light-mode .wb-checkbox-label {
            color: #1f2937;
        }
        
        .light-mode .wb-checkbox-label:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .wechat-tab-bar { display: flex; border-top-width: 1px; }
        .wechat-tab-item { 
            flex: 1; 
            text-align: center; 
            padding: 0.5rem 0; 
            cursor: pointer; 
            color: #9ca3af; 
            position: relative; /* 为红点定位提供基准 */
        }
        .wechat-tab-item.active {
            font-weight: 600;
        }
        .dark-mode .wechat-tab-item.active {
            color: #ffffff;
        }
        .light-mode .wechat-tab-item.active {
            color: #1f2937;
        }
        .wechat-tab-item i { font-size: 1.25em; }
        .wechat-tab-item span { display: block; font-size: 0.75em; }

        /* --- 新增：底部菜单栏红点提示样式 --- */
        .notification-dot {
            position: absolute;
            top: 2px; /* 距离顶部2px */
            right: 25%; /* 位于右侧约1/4处，可根据视觉效果微调 */
            width: 8px;
            height: 8px;
            background-color: #ef4444; /* 红色 */
            border-radius: 50%;
            border: 1px solid white; /* 白色描边，使其更突出 */
            box-shadow: 0 0 3px rgba(239, 68, 68, 0.5);
        }

        .notification-dot.hidden {
            display: none; /* 用于隐藏红点 */
        }

        .wechat-list-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }
        .wechat-list-item .last-message {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .user-avatar-in-chat {
            cursor: pointer;
        }

        .app-screen-view { 
            position: relative; /* 新增：为子元素的绝对定位提供基准 */
            height: 100%;
            padding-top: 3rem;
        }


        .font-size-btn.active {
            font-weight: 600;
        }
        .dark-mode .font-size-btn.active { background-color: #52525b; }
        .light-mode .font-size-btn.active { background-color: #d4d4d8; }
        .dark-mode #font-size-selector { background-color: #3f3f46; }
        .light-mode #font-size-selector { background-color: #e4e4e7; }

        #confirm-delete-modal .modal-content {
            padding: 1.5rem;
        }
        
        #wechat-chat-screen .app-header {
            position: relative;
            z-index: 2;
        }
        #wechat-content-chat {
            position: relative;
            z-index: 1;
        }
        #chat-footer {
            position: relative;
            z-index: 2;
        }
        
        #chat-quick-actions-bar {
            background: transparent;
            padding: 0.25rem 1rem;
            display: flex;
            justify-content: flex-start;
            gap: 1rem;
        }
        .quick-action-btn {
            font-size: 1.25rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .quick-action-btn:hover {
            opacity: 1;
        }
        
        #chat-footer {
            position: relative;
        }

        #chat-input-bar {
            padding: 0.5rem 0.25rem;
        }
        #chat-input-bar .chat-input-btn {
            font-size: 1.25rem;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        #emoji-btn {
            margin-left: -0.25rem;
        }

        #more-features-panel {
            background: #2c2c2e;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
        }
        .light-mode #more-features-panel {
            background: #f8f8f8;
            border-top-color: rgba(0, 0, 0, 0.1);
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        .feature-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .feature-icon-wrapper {
            width: 56px;
            height: 56px;
            border-radius: 1rem;
            background-color: #3a3a3c;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.5rem;
            transition: background-color 0.2s;
        }
        .light-mode .feature-icon-wrapper {
            background-color: #ffffff;
        }
        .feature-item:hover .feature-icon-wrapper {
            background-color: #555;
        }
        .light-mode .feature-item:hover .feature-icon-wrapper {
            background-color: #e5e5e5;
        }
        .feature-icon-wrapper i {
            font-size: 1.5rem;
        }
        .feature-item span {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .call-screen {
            position: absolute;
            inset: 0;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            background-color: #111;
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .call-screen.visible {
            opacity: 1;
            visibility: visible;
        }
        .call-background {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.6);
            transform: scale(1.1);
        }
        .call-content {
            position: relative;
            z-index: 1;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 3.5rem 1rem 1rem;
        }
        #voice-call-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.5);
            object-fit: cover;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
            margin-top: 2rem;
        }
        #user-video-preview {
            position: absolute;
            top: 3.5rem;
            right: 1rem;
            width: 90px;
            height: 120px;
            background-color: #333;
            border-radius: 1rem;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #user-video-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .call-status-box {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.25); 
            backdrop-filter: blur(12px);     
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); 
            border-radius: 1rem;
            padding: 1rem;
            max-height: 25vh;
            overflow-y: auto;
            color: #e5e7eb;
            flex-shrink: 0;
        }
        .call-input-area {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }
        .call-input-area textarea {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            padding: 0.6rem 1rem;
            color: white;
            resize: none;
            max-height: 80px; /* 设定一个大约三行文字的最大高度 */
            line-height: 1.5;
            overflow-y: hidden; /* 初始时隐藏滚动条 */
        }
        .call-input-area button {
            background-color: #374151;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        .call-input-area button:hover {
            background-color: #4b5563;
        }
        .call-controls {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem 0;
        }
        .call-control-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
        }
        .hangup-btn { 
            background-color: #ef4444; 
        }

        #incoming-call-alert {
            position: fixed;
            top: 3.5rem;
            left: 0.5rem;
            right: 0.5rem;
            z-index: 9500;
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            transform: translateY(-200%);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            opacity: 0;
            visibility: hidden;
        }
        #incoming-call-alert.visible {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }
        #incoming-call-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 1rem;
        }
        #incoming-call-info {
            flex-grow: 1;
        }
        .call-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 1.25rem;
            margin-left: 0.75rem;
        }

        #answer-call-btn { background-color: #22c55e; }
        #decline-call-btn { background-color: #ef4444; }

        /* 红包/转账高级UI样式 */
        .payment-modal-overlay {
            position: absolute;
            inset: 0;
            z-index: 12000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .payment-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .payment-modal-content {
            background-color: #1a1a1a;
            color: #C0C0C0;
            width: 90%;
            max-width: 280px; /* 缩小了宽度 */
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
        }
        .payment-modal-overlay.visible .payment-modal-content {
             transform: scale(1);
             opacity: 1;
        }
        .payment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
        }
        .payment-header .close-btn { font-size: 1.5rem; cursor: pointer; }
        .payment-header .title { font-size: 1.125rem; font-weight: 600; }
        .payment-content {
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .amount-input-wrapper {
            display: flex;
            align-items: center;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            width: 100%;
        }
        .currency-symbol {
            font-size: 2.5rem;
            font-weight: 300;
            margin-right: 1rem;
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .amount-input {
            background: transparent;
            border: none;
            outline: none;
            font-size: 3rem;
            font-weight: 700;
            width: 100%;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        /* 隐藏数字输入框的箭头 */
        .amount-input::-webkit-outer-spin-button,
        .amount-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .amount-input[type=number] {
            -webkit-appearance: textfield;
            -moz-appearance: textfield;
            appearance: textfield;
        }
        .message-input {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(220, 20, 60, 0.3);
            border-radius: 1rem;
            width: 100%;
            padding: 1rem;
            margin-top: 1.5rem;
            color: #ffffff;
            outline: none;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .message-input:focus {
            border-color: #DC143C;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.2);
            transform: translateY(-2px);
        }
        .message-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        .send-payment-btn {
            margin-top: 1.5rem;
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #DC143C, #B22222);
            color: #ffffff;
            font-size: 1.125rem;
            font-weight: 700;
            border-radius: 1rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(220, 20, 60, 0.3);
            position: relative;
            overflow: hidden;
        }
        .send-payment-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        .send-payment-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(220, 20, 60, 0.4);
        }
        .send-payment-btn:hover::before {
            left: 100%;
        }
        .send-payment-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        /* 红包/转账气泡样式 - 已修改 */
        .chat-message.red-packet-message, .chat-message.transfer-message {
            padding: 0;
            width: 200px;
            border-radius: 0.75rem;
            overflow: hidden;
            border: none;
            position: relative;
        }
        .chat-message.red-packet-message {
            background-image: radial-gradient(circle at 20% 20%, rgba(220, 20, 60, 0.25), transparent), linear-gradient(#1a1a1a, #1a1a1a);
        }
        .chat-message.transfer-message {
            background-image: radial-gradient(circle at 20% 20%, rgba(229, 231, 235, 0.15), transparent), linear-gradient(#374151, #374151);
        }
        .payment-bubble-header {
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
        }
        .payment-bubble-header i {
            font-size: 1.5rem;
            margin-right: 0.5rem;
        }
        .red-packet-message .payment-bubble-header i { color: #DC143C; }
        .transfer-message .payment-bubble-header i { color: #E5E7EB; }

        .payment-bubble-body {
            padding: 0.125rem 0.75rem; /* 减小白色区域高度 */
            background-color: white;
            color: #6b7280;
            font-size: 0.65rem;
        }
        .payment-bubble-amount {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 0.125rem;
        }
        .payment-bubble-message {
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .red-packet-message .payment-bubble-message {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        .transfer-message .payment-bubble-amount,
        .transfer-message .payment-bubble-message {
            background: linear-gradient(90deg, #E5E7EB, #B0B0B0, #E5E7EB);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* 表情面板 (美化版) */
        #sticker-panel {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            width: 375px;
            max-width: calc(100vw - 2rem);
            background: linear-gradient(135deg, rgba(44, 44, 46, 0.95), rgba(60, 60, 65, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px 20px 0 0;
            z-index: 50;
            transition: transform 0.3s ease-out;
            max-height: 50%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }
        
        /* 确保表情面板的父容器有相对定位 */
        #wechat-chat-screen {
            position: relative;
        }
        
        .light-mode #sticker-panel {
            background: linear-gradient(135deg, rgba(248, 248, 248, 0.95), rgba(255, 255, 255, 0.95));
            border-top-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.1);
        }
        
        #sticker-panel.visible {
            transform: translateX(-50%) translateY(0);
        }
        
        /* 表情面板标题栏 */
        #sticker-panel::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .light-mode #sticker-panel::before {
            background: rgba(0, 0, 0, 0.2);
        }
        
        #sticker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            padding: 20px 16px 16px 16px;
            overflow-y: auto;
            flex-grow: 1;
            margin-top: 8px;
        }
        
        /* 自定义滚动条 */
        #sticker-grid::-webkit-scrollbar {
            width: 6px;
        }
        
        #sticker-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        #sticker-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .light-mode #sticker-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode #sticker-grid::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .sticker-item, .add-sticker-btn {
            width: 60px;
            height: 60px;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 8px;
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
            overflow: hidden;
        }
        
        .sticker-item:hover, .add-sticker-btn:hover {
            transform: translateY(-4px) scale(1.05);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.15));
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .light-mode .sticker-item, .light-mode .add-sticker-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(240, 240, 240, 0.6));
            border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .sticker-item:hover, .light-mode .add-sticker-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(250, 250, 250, 0.8));
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        /* 淺色模式下的刪除按鈕樣式 */
        .light-mode .sticker-delete-btn {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .sticker-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        .light-mode .sticker-delete-btn.active {
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
        }
        
        /* 淺色模式下的刪除確認彈窗樣式 */
        .light-mode .delete-confirm-modal {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
        }
        
        .light-mode .delete-confirm-modal h3 {
            color: #1f2937;
        }
        
        .light-mode .delete-confirm-modal p {
            color: #4b5563;
        }
        
        .light-mode .delete-confirm-btn.cancel {
            background: rgba(0, 0, 0, 0.05);
            color: #374151;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .delete-confirm-btn.cancel:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        /* 浅色模式红包样式 */
        .light-mode .chat-message.red-packet-message {
            background-image: radial-gradient(circle at 20% 20%, rgba(220, 20, 60, 0.15), transparent), linear-gradient(#ffffff, #f8f9fa);
        }
        
        .light-mode .red-packet-message .payment-bubble-header i {
            color: #DC143C;
        }
        
        .light-mode .red-packet-message .payment-bubble-message {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* 浅色模式红包/转账界面样式 */
        .light-mode .payment-modal-content {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            color: #374151;
            border: 1px solid rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .currency-symbol {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .light-mode .amount-input {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .light-mode .message-input {
            background: rgba(220, 20, 60, 0.05);
            border: 2px solid rgba(220, 20, 60, 0.2);
            color: #374151;
        }
        
        .light-mode .message-input:focus {
            border-color: #DC143C;
            background: rgba(220, 20, 60, 0.08);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.15);
        }
        
        .light-mode .message-input::placeholder {
            color: rgba(55, 65, 81, 0.6);
        }
        
        .light-mode .send-payment-btn {
            background: linear-gradient(135deg, #DC143C, #B22222);
            box-shadow: 0 4px 15px rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .send-payment-btn:hover {
            box-shadow: 0 8px 25px rgba(220, 20, 60, 0.3);
        }
        
        .sticker-item img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            transition: transform 0.3s ease;
        }
        
        .sticker-item:hover img {
            transform: scale(1.1);
        }
        
        .add-sticker-btn {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(147, 197, 253, 0.1));
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .add-sticker-btn:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(147, 197, 253, 0.2));
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .add-sticker-btn i {
            font-size: 2rem;
            color: #3b82f6;
            transition: all 0.3s ease;
        }
        
        .add-sticker-btn:hover i {
            transform: rotate(90deg) scale(1.1);
            color: #1d4ed8;
        }
        
        /* 表情包面板动画效果 */
        @keyframes stickerFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .sticker-item {
            animation: stickerFadeIn 0.4s ease-out;
        }
        
        .sticker-item:nth-child(1) { animation-delay: 0.1s; }
        .sticker-item:nth-child(2) { animation-delay: 0.15s; }
        .sticker-item:nth-child(3) { animation-delay: 0.2s; }
        .sticker-item:nth-child(4) { animation-delay: 0.25s; }
        .sticker-item:nth-child(5) { animation-delay: 0.3s; }
        .sticker-item:nth-child(6) { animation-delay: 0.35s; }
        
        /* 表情包面板显示/隐藏动画 */
        #sticker-panel.visible {
            transform: translateX(-50%) translateY(0);
        }
        
        /* 刪除按鈕樣式 */
        .sticker-delete-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            background: rgba(239, 68, 68, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .sticker-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }
        
        .sticker-delete-btn i {
            color: white;
            font-size: 16px;
        }
        
        .sticker-delete-btn.active {
            background: rgba(239, 68, 68, 1);
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
        }
        
        /* 刪除模式下的表情包樣式 */
        .sticker-item.delete-mode {
            position: relative;
        }
        
        .sticker-item.delete-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(239, 68, 68, 0.2);
            border-radius: 16px;
            z-index: 1;
        }
        
        .sticker-item.delete-mode.selected::before {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(239, 68, 68, 0.8);
        }
        
        .sticker-item.delete-mode .sticker-checkbox {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid rgba(239, 68, 68, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .sticker-item.delete-mode .sticker-checkbox.checked {
            background: rgba(239, 68, 68, 0.9);
            border-color: rgba(239, 68, 68, 1);
        }
        
        .sticker-item.delete-mode .sticker-checkbox.checked::after {
            content: '✓';
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* 刪除確認彈窗樣式 */
        .delete-confirm-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 24px;
            z-index: 10000;
            display: none;
            flex-direction: column;
            align-items: center;
            min-width: 280px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .delete-confirm-modal.visible {
            display: flex;
        }
        
        .delete-confirm-modal h3 {
            color: white;
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .delete-confirm-modal p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0 0 24px 0;
            text-align: center;
            line-height: 1.5;
        }
        
        .delete-confirm-buttons {
            display: flex;
            gap: 12px;
            width: 100%;
        }
        
        .delete-confirm-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .delete-confirm-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .delete-confirm-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .delete-confirm-btn.confirm {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .delete-confirm-btn.confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }
        
        /* 响应式设计 */
        @media (max-width: 480px) {
            #sticker-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 10px;
                padding: 16px 12px 12px 12px;
            }
            
            .sticker-item, .add-sticker-btn {
                width: 70px;
                height: 70px;
            }
        }

        /* V7.0 新增样式 */
        .wechat-content-view {
            padding: 0.5rem;
            height: 100%;
            overflow-y: auto;
        }
        /* 动态 (Moments) */
        .moment-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            animation: fadeIn 0.5s ease-out;
        }
        .light-mode .moment-card {
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .moment-image {
            width: 100%;
            height: 200px;
            border-radius: 0.75rem;
            background-color: rgba(255,255,255,0.1);
            background-size: cover;
            background-position: center;
            margin-top: 0.75rem;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .moment-image:hover {
            border-color: rgba(59, 130, 246, 0.5);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        
        .moment-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }
        
        .moment-image:hover::before {
            transform: translateX(100%);
        }
        .moment-actions {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 0.75rem;
            padding-top: 0.5rem;
        }
        .light-mode .moment-actions { border-color: rgba(0,0,0,0.08); }
        .moment-action-btn {
            transition: color 0.2s, transform 0.2s;
        }
        .moment-action-btn:active {
            transform: scale(1.2);
        }
        .moment-action-btn.liked {
            color: #ef4444;
        }

        /* 日记 (Diary) */
        #wechat-diary-container {
            background-image: url('https://www.transparenttextures.com/patterns/45-degree-fabric-dark.png');
            background-color: #fffcfc;
            color: #4a4a4a;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Noto Serif SC', serif;
        }
        .dark-mode #wechat-diary-container {
             background-image: url('https://www.transparenttextures.com/patterns/45-degree-fabric-dark.png');
             background-color: #292929;
             color: #d1d5db;
        }
        .diary-entry {
            padding: 1.5rem;
            border-bottom: 1px dashed #c7c1b6;
            animation: fadeIn 0.5s ease-out;
        }
        .dark-mode .diary-entry {
            border-bottom-color: #4a4a4a;
        }
        .diary-date {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        .diary-content {
            line-height: 1.8;
        }




        


        /* 計劃 (Plan) - 高级磨砂质感暗黑风格 */
        .plan-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 1.5rem 1.25rem;
            margin-bottom: 1.25rem;
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 50%, 
                rgba(15, 23, 42, 0.95) 100%);
            backdrop-filter: blur(25px) saturate(1.2);
            border: 1px solid rgba(59, 130, 246, 0.15);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 4px 16px rgba(15, 23, 42, 0.3),
                inset 0 1px 0 rgba(59, 130, 246, 0.1),
                inset 0 -1px 0 rgba(15, 23, 42, 0.8);
            animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .plan-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.6) 20%, 
                rgba(59, 130, 246, 0.8) 50%, 
                rgba(59, 130, 246, 0.6) 80%, 
                transparent 100%);
            opacity: 0.7;
            transition: opacity 0.4s ease;
        }
        
        .plan-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                circle at 50% 0%, 
                rgba(59, 130, 246, 0.03) 0%, 
                transparent 70%
            );
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }
        
        .plan-item.expanded::after {
            opacity: 1;
        }
        

        
        .plan-item:hover {
            transform: translateY(-6px) scale(1.02);
            border-color: rgba(59, 130, 246, 0.25);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.5),
                0 8px 24px rgba(15, 23, 42, 0.4),
                inset 0 1px 0 rgba(59, 130, 246, 0.2),
                inset 0 -1px 0 rgba(15, 23, 42, 0.9);
        }
        
        .plan-item:hover::after {
            opacity: 1;
        }
        
        .light-mode .plan-item {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.95) 0%, 
                rgba(241, 245, 249, 0.9) 50%, 
                rgba(248, 250, 252, 0.95) 100%);
            border: 1px solid rgba(59, 130, 246, 0.2);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                0 4px 16px rgba(15, 23, 42, 0.05);
        }
        
        .light-mode .plan-item:hover {
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.15),
                0 8px 24px rgba(15, 23, 42, 0.08);
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .light-mode .plan-item::before {
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.5) 20%, 
                rgba(59, 130, 246, 0.7) 50%, 
                rgba(59, 130, 246, 0.5) 80%, 
                transparent 100%);
        }
        
        .light-mode .plan-item::after {
            background: radial-gradient(
                circle at 50% 0%, 
                rgba(59, 130, 246, 0.05) 0%, 
                transparent 70%
            );
        }
        
        .light-mode .plan-item.expanded::after {
            opacity: 1;
        }
        
        /* 浅色模式下的展开状态 */
        .light-mode .plan-item.expanded {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.98) 0%, 
                rgba(241, 245, 249, 0.95) 50%, 
                rgba(248, 250, 252, 0.98) 100%);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 
                0 24px 64px rgba(0, 0, 0, 0.15),
                0 12px 32px rgba(15, 23, 42, 0.08);
        }
        
        .light-mode .plan-item.expanded::before {
            opacity: 1;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.8) 20%, 
                rgba(59, 130, 246, 1) 50%, 
                rgba(59, 130, 246, 0.8) 80%, 
                transparent 100%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }
        
        /* ======================================================== */
        /* ====== "创建新约定"模态框 V2.0 (风格统一) ====== */
        /* ======================================================== */

        /* 模态框遮罩层 (复用现有样式，确保存在) */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: none; /* JS控制显示 */
            align-items: center;
            justify-content: center;
            z-index: 9000;
            padding: 1rem;
        }
        .modal-overlay.visible {
            display: flex;
        }

        /* 模态框内容区域 (全新样式) */
        #plan-modal .modal-content {
            position: relative;
            width: 100%;
            max-width: 360px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
            padding: 2rem 1.5rem 1.5rem 1.5rem;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            overflow: hidden;
            color: #f3f4f6; /* 默认文字颜色 */
            font-family: 'Noto Serif SC', serif;
        }

        /* 装饰性元素 */
        #plan-modal .modal-content::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(220, 38, 38, 0.5), transparent);
        }
        #plan-modal .modal-content::after {
            content: '🎴';
            position: absolute;
            top: 1rem; right: 1.5rem;
            font-size: 2.5rem;
            color: rgba(255,255,255,0.05);
            transform: rotate(15deg);
        }

        /* 头部 */
        #plan-modal .modal-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        #plan-modal .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f3f4f6;
            letter-spacing: 0.05em;
        }

        /* 表单组 */
        #plan-modal .form-group {
            margin-bottom: 1.5rem;
        }
        #plan-modal .form-label {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgba(255,255,255,0.6);
            margin-bottom: 0.75rem;
        }
        #plan-modal .form-label i {
            margin-right: 0.5rem;
            color: #dc2626; /* 统一的红色图标 */
        }

        /* 输入框、选择框、文本域 */
        #plan-modal .form-input, 
        #plan-modal .form-select, 
        #plan-modal .form-textarea {
            width: 100%;
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            color: #f3f4f6;
            font-size: 0.9rem;
            transition: all 0.2s ease-in-out;
        }
        #plan-modal .form-input::placeholder, 
        #plan-modal .form-textarea::placeholder {
            color: rgba(255,255,255,0.3);
        }
        #plan-modal .form-input:focus, 
        #plan-modal .form-select:focus, 
        #plan-modal .form-textarea:focus {
            outline: none;
            border-color: rgba(220, 38, 38, 0.5);
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.15);
            background-color: rgba(0,0,0,0.2);
        }
        #plan-modal .form-textarea {
            resize: none;
            height: 80px;
        }

        /* 自定义下拉箭头 */
        #plan-modal .form-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.25em 1.25em;
        }

        /* 底部按钮 */
        #plan-modal .modal-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        #plan-modal .btn {
            padding: 0.6rem 1.25rem;
            border-radius: 0.75rem;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
        }
        #plan-modal .btn-ghost {
            background: transparent;
            color: rgba(255,255,255,0.6);
        }
        #plan-modal .btn-ghost:hover {
            color: #fff;
            background-color: rgba(255,255,255,0.05);
        }
        #plan-modal .btn-primary {
            background: linear-gradient(135deg, #b91c1c, #dc2626);
            color: #fff;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.2);
            display: flex;
            align-items: center;
        }
        #plan-modal .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 38, 38, 0.3);
        }
        #plan-modal .btn-primary i {
            margin-right: 0.5rem;
        }

        .plan-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.25rem;
        }
        /* 状态标签美化 - 更精致的样式 */
        .plan-item .status-tag {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            letter-spacing: 0.3px;
            font-size: 0.75rem;
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .plan-item .status-tag:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
        }
        
        /* 状态标签图标和文字优化 */
        .plan-item .status-tag i {
            font-size: 0.75rem;
            opacity: 0.9;
        }
        
        .plan-item .status-tag span {
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.2px;
        }
        
        /* 展开状态的卡片样式 */
        .plan-item.expanded {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.98) 0%, 
                rgba(30, 41, 59, 0.95) 50%, 
                rgba(15, 23, 42, 0.98) 100%);
            border-color: rgba(59, 130, 246, 0.3);
            transform: translateY(-8px) scale(1.03);
            box-shadow: 
                0 24px 64px rgba(0, 0, 0, 0.6),
                0 12px 32px rgba(15, 23, 42, 0.5),
                inset 0 1px 0 rgba(59, 130, 246, 0.25),
                inset 0 -1px 0 rgba(15, 23, 42, 0.95);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .plan-item.expanded::before {
            opacity: 1;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.8) 20%, 
                rgba(59, 130, 246, 1) 50%, 
                rgba(59, 130, 246, 0.8) 80%, 
                transparent 100%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }
        
        .plan-item.expanded::after {
            opacity: 1;
            background: radial-gradient(
                circle at 50% 0%, 
                rgba(59, 130, 246, 0.08) 0%, 
                transparent 70%
            );
        }
        
        /* 展开详情区域的动画 */
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .plan-status-agreed { background-color: #3b82f6; color: white; }
        .plan-status-inprogress { background-color: #f59e0b; color: white; }
        .plan-status-completed { background-color: #10b981; color: white; }
        

        

        
        .plan-details {
            max-height: 0;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.6) 0%, 
                rgba(30, 41, 59, 0.4) 100%);
            border-radius: 0 0 16px 16px;
            margin: 0 -1.25rem -1.5rem -1.25rem;
            padding: 0;
            border-top: 1px solid rgba(59, 130, 246, 0.15);
            backdrop-filter: blur(20px);
            position: relative;
            box-shadow: inset 0 4px 20px rgba(15, 23, 42, 0.3);
            transform-origin: top center;
        }
        
        .plan-item.expanded .plan-details {
            max-height: 800px;
            padding: 2.5rem 1.5rem 2rem 1.5rem;
            transform: scaleY(1);
        }
        
        .plan-details::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.6) 20%, 
                rgba(59, 130, 246, 0.8) 50%, 
                rgba(59, 130, 246, 0.6) 80%, 
                transparent 100%);
            border-radius: 0.5px;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
        }
        
        .light-mode .plan-details {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.6) 0%, 
                rgba(241, 245, 249, 0.4) 100%);
            border-top: 1px solid rgba(59, 130, 246, 0.2);
            box-shadow: inset 0 4px 20px rgba(15, 23, 42, 0.1);
        }
        
        .light-mode .plan-details::before {
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.4) 20%, 
                rgba(59, 130, 246, 0.6) 50%, 
                rgba(59, 130, 246, 0.4) 80%, 
                transparent 100%);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.2);
        }
        

        
        /* 约定卡片字体优化 */
        .plan-item .plan-title {
            font-size: 0.875rem;
            font-weight: 500;
            line-height: 1.4;
            letter-spacing: 0.2px;
        }
        
        .plan-item .plan-character {
            font-size: 0.75rem;
            font-weight: 500;
            line-height: 1.3;
            letter-spacing: 0.3px;
        }
        
        .plan-item .plan-date {
            font-size: 0.75rem;
            font-weight: 400;
            line-height: 1.3;
            letter-spacing: 0.2px;
        }
        
        .plan-item .plan-details-text {
            font-size: 0.75rem;
            font-weight: 400;
            line-height: 1.5;
            letter-spacing: 0.1px;
        }
        
        /* 时间信息区域 - 更精致的样式 */
        .time-info-section {
            margin-bottom: 2rem;
        }
        
        .info-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(59, 130, 246, 0.1);
            transition: all 0.3s ease;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        .info-row:hover {
            background: rgba(59, 130, 246, 0.05);
            border-radius: 8px;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
            margin-left: -0.75rem;
            margin-right: -0.75rem;
        }
        
        .info-label {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgba(148, 163, 184, 0.9);
            letter-spacing: 0.3px;
        }
        
        .info-value {
            font-size: 0.875rem;
            font-weight: 400;
            color: rgba(226, 232, 240, 0.9);
            letter-spacing: 0.2px;
        }
        
        .status-badge {
            padding: 0.375rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            color: rgba(148, 163, 184, 0.9);
            backdrop-filter: blur(10px);
        }
        
        .info-label i {
            font-size: 1rem;
            opacity: 0.7;
            margin-right: 0.5rem;
        }
        
        .info-value {
            font-size: 0.875rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.9);
            text-align: right;
            max-width: 60%;
        }
        
        .status-badge {
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        /* 操作按钮区域 - 更高级的样式 */
        .action-buttons-section {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(59, 130, 246, 0.1);
        }
        
        /* 高级按钮样式 - 磨砂质感 */
        .luxury-btn {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.9) 0%, 
                rgba(30, 41, 59, 0.8) 100%);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            color: rgba(226, 232, 240, 0.9);
            font-size: 0.875rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            overflow: hidden;
            min-width: 120px;
        }
        
        .luxury-btn:hover {
            transform: translateY(-2px);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(59, 130, 246, 0.1);
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%);
        }
        
        .luxury-btn:active {
            transform: translateY(0);
        }
        
        .luxury-btn .btn-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 2;
            position: relative;
        }
        
        .luxury-btn .btn-glow {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(59, 130, 246, 0.1) 0%, 
                transparent 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 12px;
        }
        
        .luxury-btn:hover .btn-glow {
            opacity: 1;
        }
        
        /* 编辑按钮特殊样式 */
        .edit-plan-btn {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.9) 0%, 
                rgba(30, 41, 59, 0.8) 100%);
            border-color: rgba(59, 130, 246, 0.25);
        }
        
        .edit-plan-btn:hover {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%);
            border-color: rgba(59, 130, 246, 0.4);
        }
        
        /* 删除按钮特殊样式 */
        .delete-plan-btn {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.9) 0%, 
                rgba(30, 41, 59, 0.8) 100%);
            border-color: rgba(239, 68, 68, 0.25);
        }
        
        .delete-plan-btn:hover {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%);
            border-color: rgba(239, 68, 68, 0.4);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(239, 68, 68, 0.1);
        }
        
        /* 浅色模式适配 */
        .light-mode .info-label {
            color: rgba(71, 85, 105, 0.8);
        }
        
        .light-mode .info-value {
            color: rgba(15, 23, 42, 0.9);
        }
        
        .light-mode .status-badge {
            background: rgba(248, 250, 252, 0.8);
            border-color: rgba(59, 130, 246, 0.3);
            color: rgba(71, 85, 105, 0.8);
        }
        
        .light-mode .luxury-btn {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.9) 0%, 
                rgba(241, 245, 249, 0.8) 100%);
            border-color: rgba(59, 130, 246, 0.25);
            color: rgba(15, 23, 42, 0.9);
        }
        
        .light-mode .luxury-btn:hover {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.95) 0%, 
                rgba(241, 245, 249, 0.9) 100%);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.1),
                0 4px 12px rgba(59, 130, 246, 0.08);
        }
        
        .light-mode .edit-plan-btn {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.9) 0%, 
                rgba(241, 245, 249, 0.8) 100%);
            border-color: rgba(59, 130, 246, 0.25);
        }
        
        .light-mode .delete-plan-btn {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.9) 0%, 
                rgba(241, 245, 249, 0.8) 100%);
            border-color: rgba(239, 68, 68, 0.25);
        }
        
        /* ============================================= */
        /* V7.1 UI 升级样式 (动态 & 日记) */
        /* ============================================= */

        /* --- 新增：动态 (Moments) 整体 UI --- */
        #moments-header {
            transition: transform 0.3s ease;
        }
        #moments-header:hover {
            transform: scale(1.02);
        }

        /* 朋友圈背景图片样式 */
        #moments-cover {
            z-index: 25; /* 提高z-index，确保在渐变遮罩之上 */
            position: relative;
            min-height: 192px; /* 确保有足够的高度 */
            width: 100%; /* 确保宽度填满 */
        }

        /* 渐变遮罩样式 */
        #moments-header .bg-gradient-to-t {
            z-index: 20;
            pointer-events: none; /* 让渐变遮罩不阻挡点击事件 */
        }

        #moments-user-name {
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            color: white;
            font-weight: bold;
        }

        #moments-user-avatar {
            background-color: #4a4a4a;
            transition: transform 0.3s ease;
            z-index: 30; /* 确保头像在背景之上 */
        }
        #moments-user-avatar:hover {
            transform: scale(1.05);
        }
        
        /* 头像信息容器样式 */
        #moments-user-info {
            position: absolute;
            z-index: 30; /* 确保头像信息在背景之上 */
        }

        /* 朋友圈背景图片样式 - 确保不被日夜间模式覆盖 */
        #moments-cover {
            background-image: var(--moments-cover-image, url('https://placehold.co/375x192/333/fff?text=Cover'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 确保日夜间模式切换后背景图片仍然显示 */
        .dark-mode #moments-cover,
        .light-mode #moments-cover {
            background-image: var(--moments-cover-image, url('https://placehold.co/375x192/333/fff?text=Cover'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 强制设置默认背景图片，确保始终有图片显示 */
        #moments-cover:not([style*="background-image"]) {
            background-image: url('https://placehold.co/375x192/333/fff?text=Cover');
        }

        /* 朋友圈头像样式 - 确保不被日夜间模式覆盖 */
        #moments-user-avatar {
            background-image: var(--moments-avatar-image, url('https://placehold.co/128x128/777/FFF?text=Me'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 确保日夜间模式切换后头像仍然显示 */
        .dark-mode #moments-user-avatar,
        .light-mode #moments-user-avatar {
            background-image: var(--moments-avatar-image, url('https://placehold.co/128x128/777/FFF?text=Me'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 动态卡片(新) */
        .moment-card {
            border: none;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            padding: 0.75rem; /* 内边距统一 */
        }


        
        /* 朋友圈头像点击样式 */
        .moment-card .w-10.h-10 {
            transition: transform 0.2s;
        }
        .moment-card .w-10.h-10:hover {
            transform: scale(1.1);
        }
        .light-mode .moment-card {
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
        }
        .moment-card .flex.items-start .font-bold {
            font-size: 1.05em; /* 名字稍大一些 */
        }
        .moment-card .whitespace-pre-wrap {
            font-size: 1em;
            line-height: 1.6;
        }

        /* 点赞和评论样式 */
        .moment-action-btn {
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .moment-action-btn:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .moment-action-btn.text-blue-500 {
            color: #3b82f6;
        }
        
        .moment-action-btn.text-blue-500:hover {
            background-color: rgba(59, 130, 246, 0.15);
        }
        
        /* 评论样式 - 支持日间夜间模式 */
        .comment-bubble {
            background-color: rgba(249, 250, 251, 0.8);
            border: 1px solid rgba(229, 231, 235, 0.5);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .comment-bubble:hover {
            background-color: rgba(243, 244, 246, 0.9);
            border-color: rgba(209, 213, 219, 0.7);
        }
        
        .comment-text {
            color: #374151;
        }
        
        /* 日间模式评论样式 */
        .light-mode .comment-bubble {
            background-color: rgba(249, 250, 251, 0.9);
            border: 1px solid rgba(229, 231, 235, 0.7);
        }
        
        .light-mode .comment-bubble:hover {
            background-color: rgba(243, 244, 246, 1);
            border-color: rgba(209, 213, 219, 0.8);
        }
        
        .light-mode .comment-text {
            color: #374151;
        }
        
        /* 夜间模式评论样式 */
        .dark-mode .comment-bubble {
            background-color: rgba(55, 65, 81, 0.3);
            border: 1px solid rgba(75, 85, 99, 0.4);
        }
        
        .dark-mode .comment-bubble:hover {
            background-color: rgba(55, 65, 81, 0.5);
            border-color: rgba(75, 85, 99, 0.6);
        }
        
        .dark-mode .comment-text {
            color: #e5e7eb;
        }

        /* 评论按钮容器 - 浮动在右上角 */
        .comment-buttons {
            position: absolute !important;
            top: 0.25rem !important;
            right: 0.25rem !important;
            background: rgba(0, 0, 0, 0.7) !important;
            border-radius: 0.375rem !important;
            padding: 0.25rem !important;
            backdrop-filter: blur(4px) !important;
            z-index: 10 !important;
            margin: 0 !important;
        }
        
        /* 日间模式按钮容器背景 */
        .light-mode .comment-buttons {
            background: rgba(255, 255, 255, 0.9) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }

        /* 评论编辑和删除按钮样式 */
        .comment-edit-btn,
        .comment-delete-btn {
            opacity: 0;
            transition: all 0.2s ease;
            padding: 0.25rem !important;
            border-radius: 0.25rem !important;
        }

        .comment-bubble.show-buttons .comment-buttons {
            opacity: 1 !important;
        }
        
        .comment-bubble.show-buttons .comment-edit-btn,
        .comment-bubble.show-buttons .comment-delete-btn {
            opacity: 1 !important;
        }

        .comment-edit-btn:hover {
            background-color: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }

        .comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        /* 夜间模式下的按钮悬停效果 */
        .dark-mode .comment-edit-btn:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }

        .dark-mode .comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.2);
        }

        /* --- 新增：日记 (Diary) "书架" UI - 优化质感 --- */
        #diary-bookshelf .diary-book-item {
            aspect-ratio: 3 / 4;
            border-radius: 0.75rem 1rem 1rem 0.75rem;
            padding: 1.2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: white;
            cursor: pointer;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 日间模式日记书架项目样式 */
        .light-mode #diary-bookshelf .diary-book-item {
            color: #2c2c2c;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 4px 12px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .light-mode #diary-bookshelf .diary-book-item::before {
            background: 
                linear-gradient(135deg, 
                    rgba(0, 0, 0, 0.05) 0%, 
                    rgba(0, 0, 0, 0.15) 50%, 
                    rgba(0, 0, 0, 0.25) 100%);
        }

        #diary-bookshelf .diary-book-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(135deg, 
                    rgba(0, 0, 0, 0.1) 0%, 
                    rgba(0, 0, 0, 0.3) 50%, 
                    rgba(0, 0, 0, 0.5) 100%);
            pointer-events: none;
            z-index: 1;
        }

        #diary-bookshelf .diary-book-item:hover {
            transform: translateY(-12px) rotate(3deg) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 8px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        /* 日间模式日记书架项目悬停效果 */
        .light-mode #diary-bookshelf .diary-book-item:hover {
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.2),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(0, 0, 0, 0.08);
        }

        .diary-book-item-title {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 1.3rem;
            font-weight: 600;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 2;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* 日间模式日记书架标题样式 */
        .light-mode .diary-book-item-title {
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .diary-book-item-title:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.02);
        }

        /* 日间模式日记书架标题悬停效果 */
        .light-mode .diary-book-item-title:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .diary-book-item-title.editing {
            background: rgba(255, 255, 255, 0.15);
            outline: 2px solid rgba(255, 255, 255, 0.3);
            outline-offset: 2px;
        }

        /* 日间模式日记书架标题编辑状态 */
        .light-mode .diary-book-item-title.editing {
            background: rgba(0, 0, 0, 0.15);
            outline: 2px solid rgba(0, 0, 0, 0.3);
        }

        .diary-book-item-title input {
            background: transparent;
            border: none;
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            text-align: center;
            width: 100%;
            outline: none;
            text-shadow: inherit;
        }

        .diary-book-item-author {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 0.85rem;
            align-self: flex-end;
            font-style: italic;
            text-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 2;
            opacity: 0.9;
        }

        /* 日间模式日记书架作者样式 */
        .light-mode .diary-book-item-author {
            text-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* --- 新增：日记本"翻页书" UI --- */
        .book-container {
            position: relative;
            width: 90vw;
            height: 70vh;
            perspective: 2500px;
        }
        .book {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(10deg) rotateY(0deg);
            transition: transform 1s ease;
        }
        .book:hover {
            transform: rotateX(0deg) rotateY(0deg);
        }

        /* 旧的展开书本样式已删除 */

        /* 旧的展开书本样式已删除 */

        /* 旧的展开书本样式已删除 */
        
        /* 日记本封面编辑按钮样式 - 优化质感 */
        .diary-cover-edit-btn {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            width: 1.76rem;
            height: 1.76rem;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.7) 0%, 
                rgba(0, 0, 0, 0.8) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
            backdrop-filter: blur(8px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .diary-book-item:hover .diary-cover-edit-btn {
            opacity: 1;
            transform: scale(1.05);
        }

        .diary-cover-edit-btn:hover {
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.8) 0%, 
                rgba(0, 0, 0, 0.9) 100%);
            transform: scale(1.1);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .diary-cover-edit-btn i {
            font-size: 1.1rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 日记本内页横幅更换按钮样式 - 始终可见 */
        #change-diary-banner-btn {
            opacity: 1 !important;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.8) 0%, 
                rgba(0, 0, 0, 0.9) 100%);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #change-diary-banner-btn:hover {
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(0, 0, 0, 1) 100%);
            transform: scale(1.1);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* 单页日记本样式 - 优化为纸张质感 */
        .diary-single-page-container {
            width: 90vw;
            max-width: 400px;
            height: 80vh;
            max-height: 600px;
        }

        .diary-single-page {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            border-radius: 16px;
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.25),
                0 4px 12px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* 封面样式 - 支持日夜间模式 */
        .diary-cover {
            background: linear-gradient(145deg, 
                #2c2c2c 0%, 
                #404040 25%, 
                #505050 50%, 
                #404040 75%, 
                #2c2c2c 100%);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 图片裁剪模态框样式 */
        #image-cropper-modal {
            z-index: 16000;
        }

        #cropper-container {
            position: relative;
            min-height: 300px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cropper-image {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        #crop-box {
            position: absolute;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.1);
            cursor: move;
            z-index: 10;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
        }

        #crop-box:hover {
            border-color: #0056b3;
            background: rgba(0, 123, 255, 0.2);
        }

        .diary-cover {
            color: #f0f0f0;
            padding: 2.5rem 2rem;
            text-align: center;
            border-radius: 16px 16px 0 0;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        /* 日间模式封面样式 */
        .light-mode .diary-cover {
            background: linear-gradient(145deg, 
                #f8f9fa 0%, 
                #e9ecef 25%, 
                #404040 50%, 
                #e9ecef 75%, 
                #f8f9fa 100%);
            color: #2c2c2c;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.05),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            border-bottom: 2px solid rgba(0, 0, 0, 0.1);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .light-mode .diary-cover::before {
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 0, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 0, 0, 0.02) 0%, transparent 50%);
        }

        .diary-cover::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        .diary-cover h2 {
            font-size: 1.6rem;
            margin-bottom: 0.8rem;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.5px;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            transition: text-shadow 0.3s ease;
        }

        .diary-cover p {
            font-size: 1rem;
            opacity: 0.9;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            transition: text-shadow 0.3s ease;
        }

        /* 日间模式文字阴影 */
        .light-mode .diary-cover h2 {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .light-mode .diary-cover p {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }

        /* 编辑状态样式 */
        .diary-cover h2.editing,
        .diary-cover p.editing {
            cursor: text;
        }

        .diary-cover h2:hover,
        .diary-cover p:hover {
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .cover-title-edit-input,
        .cover-author-edit-input {
            background: rgba(255, 255, 255, 0.95) !important;
            color: #333 !important;
            border: 2px solid #4ecdc4 !important;
            border-radius: 6px !important;
            padding: 8px 12px !important;
            font-size: inherit !important;
            font-weight: inherit !important;
            text-align: center !important;
            width: 90% !important;
            outline: none !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            font-family: inherit !important;
            transition: all 0.3s ease !important;
        }

        /* 日间模式编辑输入框样式 */
        .light-mode .cover-title-edit-input,
        .light-mode .cover-author-edit-input {
            background: rgba(255, 255, 255, 0.98) !important;
            color: #2c2c2c !important;
            border: 2px solid #4ecdc4 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
        }

        .cover-title-edit-input {
            font-size: 1.6rem !important;
            font-weight: 600 !important;
            padding: 8px 12px !important;
        }

        .cover-author-edit-input {
            font-size: 1rem !important;
            font-weight: 500 !important;
            padding: 6px 10px !important;
            width: 80% !important;
        }

        /* 内页样式 - 真实纸张质感 */
        .diary-pages {
            flex: 1;
            background: 
                linear-gradient(135deg, #fefefe 0%, #f8f8f8 100%);
            padding: 2.5rem;
            overflow-y: auto;
            position: relative;
            z-index: 1;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
            transition: all 0.3s ease;
        }

        /* 夜间模式内页样式 - 保持白底黑字 */
        .dark-mode .diary-pages {
            background: 
                linear-gradient(135deg, #fefefe 0%, #f8f8f8 100%);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
        }

        .dark-mode .diary-pages::before {
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.03) 1px, transparent 0);
        }

        /* 纸张纹理效果 */
        .diary-pages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(0, 0, 0, 0.02) 1px, transparent 0);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }

        /* 日记页面内容样式 - 优化字体和排版 */
        .diary-page-content {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Kaiti', 'STKaiti', 'Georgia', 'Times New Roman', serif;
            line-height: 1.9;
            position: relative;
            z-index: 2;
            color: #2c2c2c;
            transition: color 0.3s ease;
        }

        /* 夜间模式页面内容样式 - 保持黑色文字 */
        .dark-mode .diary-page-content {
            color: #2c2c2c;
        }
        
        /* 确保所有日记相关文字都使用思源宋体 */
        .diary-book-item,
        .diary-book-item h3,
        .diary-book-item p,
        .diary-entry,
        .diary-entry h3,
        .diary-entry p {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }

        .diary-page-date {
            font-weight: 600;
            margin-bottom: 2rem;
            color: #2c2c2c;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.8rem;
            font-size: 1.1rem;
            letter-spacing: 0.5px;
            position: relative;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            transition: all 0.3s ease;
        }

        .diary-page-date::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, #505050, transparent);
            transition: background 0.3s ease;
        }

        /* 夜间模式日期样式 - 保持黑色文字 */
        .dark-mode .diary-page-date {
            color: #2c2c2c;
            border-bottom-color: #e0e0e0;
        }

        .dark-mode .diary-page-date::after {
            background: linear-gradient(90deg, #505050, transparent);
        }

        /* 日记页面头部样式 */
        .diary-page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        /* 删除按钮样式 */
        .diary-delete-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .diary-delete-btn:hover {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        /* 页码样式 */
        .diary-page-number {
            position: relative;
            text-align: right;
            margin-top: 2rem;
            font-size: 0.8rem;
            color: #999;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            /* 移除 display: inline-block，因為 float: right 會強制轉換為 block */
            float: right;
        }

        .diary-page-text {
            font-size: 1rem;
            text-align: justify;
            white-space: pre-wrap;
            color: #2a2a2a;
            line-height: 2;
            text-shadow: 0 0.5px 1px rgba(255, 255, 255, 0.8);
            padding: 1rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            cursor: text;
        }

        .diary-page-text[contenteditable="true"]:hover {
            background: rgba(0, 0, 0, 0.02);
        }

        .diary-page-text[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 0, 0, 0.03);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.08),
                0 0 0 2px rgba(80, 80, 80, 0.1);
        }

        /* 滚动条样式优化 */
        .diary-pages::-webkit-scrollbar {
            width: 6px;
        }

        .diary-pages::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
        }

        .diary-pages::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .diary-pages::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* 日记编辑区域样式 - 纸张质感 */
        .diary-page-editable {
            width: 100%;
            min-height: 200px;
            padding: 1.5rem;
            border: none;
            background: 
                linear-gradient(135deg, #fefefe 0%, #fafafa 100%);
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 1rem;
            line-height: 1.9;
            color: #2a2a2a;
            resize: vertical;
            border-radius: 8px;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.08),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
            transition: all 0.3s ease;
        }

        .diary-page-editable:focus {
            outline: none;
            background: 
                linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.12),
                inset 0 -1px 2px rgba(0, 0, 0, 0.05),
                0 0 0 3px rgba(80, 80, 80, 0.1);
        }

        .diary-page-editable::placeholder {
            color: #999;
            font-style: italic;
            opacity: 0.7;
        }

        /* 新日记页面样式 */
        .diary-page-new {
            background: 
                linear-gradient(135deg, #f8f8f8 0%, #f0f0f0 100%);
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            color: #666;
            transition: all 0.3s ease;
        }

        .diary-page-new:hover {
            border-color: #999;
            background: 
                linear-gradient(135deg, #f0f0f0 0%, #e8e8e8 100%);
        }

        .diary-page-new h3 {
            margin-bottom: 1rem;
            color: #505050;
            font-size: 1.2rem;
        }

        .diary-page-new p {
            color: #888;
            line-height: 1.6;
        }

        /* 日记本控制按钮样式 - 黑白灰质感 */
        #close-diary-book-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #close-diary-book-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #prev-page-btn,
        #next-page-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            box-shadow: 
                0 3px 10px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #prev-page-btn:hover,
        #next-page-btn:hover {
            background: rgba(0, 0, 0, 0.75);
            transform: scale(1.1);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #add-page-btn {
            background: linear-gradient(145deg, #404040, #505050);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #add-page-btn:hover {
            background: linear-gradient(145deg, #505050, #606060);
            transform: scale(1.05);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        /* 按钮图标样式 */
        #close-diary-book-btn i,
        #prev-page-btn i,
        #next-page-btn i,
        #add-page-btn i {
            color: #f0f0f0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 日记页面占位符样式 */
        .diary-page-placeholder {
            display: none;
        }

        /* 笔记本项目样式 */
        .notebook-item {
            position: relative;
        }

        .notebook-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notebook-item:hover .notebook-actions {
            opacity: 1;
        }

        .notebook-edit-btn,
        .notebook-delete-btn {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .notebook-edit-btn:hover {
            background: rgba(59, 130, 246, 0.8);
            transform: scale(1.1);
        }

        .notebook-delete-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            transform: scale(1.1);
        }

        /* 新笔记本模态框样式 */
        #new-notebook-modal .modal-content {
            max-width: 400px;
        }

        /* 基础表单样式 - 支持日间夜间模式 */
        .form-input,
        .form-select {
            border-radius: 8px;
            padding: 0.75rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        /* 夜间模式样式 */
        .dark-mode .form-input,
        .dark-mode .form-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* 日间模式样式 */
        .light-mode .form-input,
        .light-mode .form-select {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #1f2937;
        }

        /* 焦点状态 - 夜间模式 */
        .dark-mode .form-input:focus,
        .dark-mode .form-select:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.6);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* 焦点状态 - 日间模式 */
        .light-mode .form-input:focus,
        .light-mode .form-select:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* 占位符样式 - 夜间模式 */
        .dark-mode .form-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* 占位符样式 - 日间模式 */
        .light-mode .form-input::placeholder {
            color: rgba(0, 0, 0, 0.6);
        }
    /* ====== 动态监控 App (Refined UI) ====== */
    #monitoring-screen {
        color: #662034;
        position: relative;
        /* 移除 overflow: hidden，允许内容滚动 */
        /* overflow: hidden; */
        /* 设置合适的宽度，让内容能够居中 */
        max-width: 100%;
        width: 100%;
    }

    /* 科技感背景 - 日间模式 */
    #monitoring-screen::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #C8AABD, #BE3255, #B6C9D4, #CEA9BC);
        z-index: 1;
        animation: backgroundShimmer 8s ease-in-out infinite;
        opacity: 1;
        filter: saturate(1.2) brightness(1.1);
        box-shadow: inset 0 0 50px rgba(190, 50, 85, 0.3);
    }

    /* 科技感背景 - 夜间模式 */
    .dark-mode #monitoring-screen::before {
        background: linear-gradient(135deg, #202127, #662034, #568897, #195B9A);
        z-index: 1;
        animation: backgroundShimmerDark 8s ease-in-out infinite;
        opacity: 1;
        filter: saturate(1.1) brightness(1.05);
        box-shadow: inset 0 0 50px rgba(102, 32, 52, 0.4);
    }

    /* 屏幕下方闪烁效果 - 日间模式 */
    #monitoring-screen::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            #C8AABD 20%, 
            #BE3255 40%, 
            #C0C9B6 60%, 
            #CEA9BC 80%, 
            transparent 100%);
        z-index: 1;
        animation: bottomFlash 2s ease-in-out infinite;
    }

    /* 屏幕下方闪烁效果 - 夜间模式 */
    .dark-mode #monitoring-screen::after {
        background: linear-gradient(90deg, 
            transparent 0%, 
            #202127 20%, 
            #662034 40%, 
            #568897 60%, 
            #195B9A 80%, 
            transparent 100%);
        animation: bottomFlashDark 2s ease-in-out infinite;
    }

    /* 背景闪烁装饰元素 */
    #monitoring-screen .bg-glow-1 {
        content: '';
        position: absolute;
        top: 10%;
        left: 5%;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, rgba(200, 170, 189, 0.3) 0%, transparent 70%);
        border-radius: 50%;
        animation: backgroundGlow 6s ease-in-out infinite;
        z-index: 2;
        pointer-events: none;
    }

    #monitoring-screen .bg-glow-2 {
        content: '';
        position: absolute;
        top: 60%;
        right: 10%;
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, rgba(190, 50, 85, 0.2) 0%, transparent 70%);
        border-radius: 50%;
        animation: backgroundGlow 8s ease-in-out infinite reverse;
        z-index: 2;
        pointer-events: none;
    }

    .dark-mode #monitoring-screen .bg-glow-1 {
        background: radial-gradient(circle, rgba(86, 136, 151, 0.3) 0%, transparent 70%);
        animation: backgroundGlowDark 6s ease-in-out infinite;
    }

    .dark-mode #monitoring-screen .bg-glow-2 {
        background: radial-gradient(circle, rgba(102, 32, 52, 0.2) 0%, transparent 70%);
        animation: backgroundGlowDark 8s ease-in-out infinite reverse;
    }

    /* 夜间模式文本颜色 */
    .dark-mode #monitoring-screen {
        color: #568897;
    }

    /* 日间模式身份信息文本颜色 */
    #monitoring-name {
        color: #BE3255 !important;
    }

    #monitoring-mood {
        color: #BE3255 !important;
    }

    #monitoring-status-text {
        color: #C8AABD;
    }

    /* 科技感装饰元素 - 名片区域 */
    
    /* 新增：电子颗粒效果 */
    .electronic-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 15;
        overflow: hidden;
    }

    .particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        opacity: 0;
        animation: particleFloat 8s linear infinite;
    }

    .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
    .particle:nth-child(2) { left: 20%; animation-delay: 1s; }
    .particle:nth-child(3) { left: 30%; animation-delay: 2s; }
    .particle:nth-child(4) { left: 40%; animation-delay: 3s; }
    .particle:nth-child(5) { left: 50%; animation-delay: 4s; }
    .particle:nth-child(6) { left: 60%; animation-delay: 5s; }
    .particle:nth-child(7) { left: 70%; animation-delay: 6s; }
    .particle:nth-child(8) { left: 80%; animation-delay: 7s; }

    /* 新增：X射线扫描线效果 */
    .xray-scan-line {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.8) 20%, 
            rgba(190, 50, 85, 1) 50%, 
            rgba(200, 170, 189, 0.8) 80%, 
            transparent 100%);
        box-shadow: 0 0 10px rgba(190, 50, 85, 0.6);
        z-index: 16;
        animation: xrayScan 4s ease-in-out infinite;
    }

    /* 新增：赛博朋克网格效果 */
    .cyber-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            linear-gradient(rgba(200, 170, 189, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(200, 170, 189, 0.1) 1px, transparent 1px);
        background-size: 20px 20px;
        z-index: 14;
        opacity: 0.3;
        animation: gridPulse 6s ease-in-out infinite;
    }

    /* 新增：数据流动效果 */
    .data-flow-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 13;
        overflow: hidden;
    }

    .data-stream {
        position: absolute;
        width: 1px;
        height: 100%;
        background: linear-gradient(to bottom, 
            transparent 0%, 
            rgba(200, 170, 189, 0.6) 20%, 
            rgba(190, 50, 85, 0.8) 50%, 
            rgba(200, 170, 189, 0.6) 80%, 
            transparent 100%);
        animation: dataStream 3s linear infinite;
    }

    .data-stream:nth-child(1) { left: 15%; animation-delay: 0s; }
    .data-stream:nth-child(2) { left: 35%; animation-delay: 1s; }
    .data-stream:nth-child(3) { left: 55%; animation-delay: 2s; }
    .data-stream:nth-child(4) { left: 75%; animation-delay: 0.5s; }

    /* 新增：能量波纹效果 */
    .energy-ripple {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border: 1px solid rgba(200, 170, 189, 0.4);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 12;
        animation: energyRipple 4s ease-out infinite;
    }

    .energy-ripple:nth-child(2) { animation-delay: 1s; }
    .energy-ripple:nth-child(3) { animation-delay: 2s; }

    /* 新增：角落科技装饰 */
    .tech-corner {
        position: absolute;
        width: 20px;
        height: 20px;
        border: 1px solid rgba(200, 170, 189, 0.6);
        z-index: 17;
    }

    .tech-corner.top-left {
        top: 10px;
        left: 10px;
        border-right: none;
        border-bottom: none;
        border-radius: 8px 0 0 0;
    }

    .tech-corner.top-right {
        top: 10px;
        right: 10px;
        border-left: none;
        border-bottom: none;
        border-radius: 0 8px 0 0;
    }

    .tech-corner.bottom-left {
        bottom: 10px;
        left: 10px;
        border-right: none;
        border-top: none;
        border-radius: 0 0 0 8px;
    }

    .tech-corner.bottom-right {
        bottom: 10px;
        right: 10px;
        border-left: none;
        border-top: none;
        border-radius: 0 0 8px 0;
    }

    /* 新增：状态指示器 */
    .status-indicator {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 8px;
        height: 8px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        z-index: 18;
        animation: statusPulse 2s ease-in-out infinite;
    }

    /* 夜间模式适配 */
    .dark-mode .particle {
        background: linear-gradient(45deg, #568897, #662034);
    }

    .dark-mode .xray-scan-line {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.8) 20%, 
            rgba(102, 32, 52, 1) 50%, 
            rgba(86, 136, 151, 0.8) 80%, 
            transparent 100%);
        box-shadow: 0 0 10px rgba(102, 32, 52, 0.6);
    }

    .dark-mode .cyber-grid {
        background-image: 
            linear-gradient(rgba(86, 136, 151, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(86, 136, 151, 0.1) 1px, transparent 1px);
    }

    .dark-mode .data-stream {
        background: linear-gradient(to bottom, 
            transparent 0%, 
            rgba(86, 136, 151, 0.6) 20%, 
            rgba(102, 32, 52, 0.8) 50%, 
            rgba(86, 136, 151, 0.6) 80%, 
            transparent 100%);
    }

    .dark-mode .energy-ripple {
        border-color: rgba(86, 136, 151, 0.4);
    }

    .dark-mode .tech-corner {
        border-color: rgba(86, 136, 151, 0.6);
    }

    .dark-mode .status-indicator {
        background: linear-gradient(45deg, #568897, #662034);
    }

    /* 新增：按钮区域科技感装饰 */
    .button-tech-lines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .button-line-left {
        position: absolute;
        top: 50%;
        left: 10%;
        width: 60px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.6) 100%);
        transform: translateY(-50%);
        animation: buttonLineLeft 3s ease-in-out infinite;
    }

    .button-line-right {
        position: absolute;
        top: 50%;
        right: 10%;
        width: 60px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(190, 50, 85, 0.6) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: buttonLineRight 3s ease-in-out infinite 1.5s;
    }

    .button-center-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 3px;
        height: 3px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 6px rgba(200, 170, 189, 0.6);
        animation: buttonCenterPulse 2s ease-in-out infinite;
    }

    /* 夜间模式按钮装饰 */
    .dark-mode .button-line-left {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.6) 100%);
    }

    .dark-mode .button-line-right {
        background: linear-gradient(90deg, 
            rgba(102, 32, 52, 0.6) 0%, 
            transparent 100%);
    }

    .dark-mode .button-center-dot {
        background: linear-gradient(45deg, #568897, #662034);
        box-shadow: 0 0 6px rgba(86, 136, 151, 0.6);
    }

    /* 新增：悬停和交互效果 */
    .monitoring-card:hover .tech-corner {
        animation: techCornerHover 0.3s ease-out forwards;
    }

    .monitoring-card:hover .status-indicator {
        animation: statusIndicatorHover 0.3s ease-out forwards;
    }

    .monitoring-capsule-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(200, 170, 189, 0.3);
        transition: all 0.3s ease;
    }

    .monitoring-capsule-btn:hover .button-tech-lines {
        opacity: 1;
    }

    /* 新增：数据流动画增强 */
    .data-stream:hover {
        animation-duration: 1.5s;
        box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
    }

    /* 新增：X射线扫描线悬停效果 */
    .xray-scan-line:hover {
        animation-duration: 2s;
        box-shadow: 0 0 15px rgba(190, 50, 85, 0.8);
    }

    /* 文本框下方的科技感线性装饰 */
    .tech-lines-container {
        height: 20px;
        overflow: hidden;
    }

    .tech-line-main {
        position: absolute;
        top: 50%;
        left: 20%;
        right: 20%;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.3) 20%, 
            rgba(200, 170, 189, 0.8) 50%, 
            rgba(190, 50, 85, 0.8) 80%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLinePulse 3s ease-in-out infinite;
    }

    .tech-line-left {
        position: absolute;
        top: 50%;
        left: 15%;
        width: 30px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.6) 100%);
        transform: translateY(-50%);
        animation: techLineLeft 2.5s ease-in-out infinite;
    }

    .tech-line-left-2 {
        position: absolute;
        top: 50%;
        left: 12%;
        width: 20px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.4) 100%);
        transform: translateY(-50%);
        animation: techLineLeft 2.5s ease-in-out infinite 0.8s;
    }

    .tech-line-right {
        position: absolute;
        top: 50%;
        right: 15%;
        width: 30px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(190, 50, 85, 0.6) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLineRight 2.5s ease-in-out infinite 0.5s;
    }

    .tech-line-right-2 {
        position: absolute;
        top: 50%;
        right: 12%;
        width: 20px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(190, 50, 85, 0.4) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLineRight 2.5s ease-in-out infinite 1.2s;
    }

    .tech-center-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 4px rgba(200, 170, 189, 0.6);
        animation: techCenterPulse 2s ease-in-out infinite;
    }

    .tech-center-dot-2 {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background: transparent;
        border: 1px solid rgba(200, 170, 189, 0.3);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: techCenterPulse 2s ease-in-out infinite 0.5s;
    }

    /* 夜间模式线性装饰 */
    .dark-mode .tech-line-main {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(32, 33, 39, 0.3) 20%, 
            rgba(32, 33, 39, 0.8) 50%, 
            rgba(102, 32, 52, 0.8) 80%, 
            transparent 100%);
    }

    .dark-mode .tech-line-left,
    .dark-mode .tech-line-left-2 {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.6) 100%);
    }

    .dark-mode .tech-line-left-2 {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.4) 100%);
    }

    .dark-mode .tech-line-right,
    .dark-mode .tech-line-right-2 {
        background: linear-gradient(90deg, 
            rgba(102, 32, 52, 0.6) 0%, 
            transparent 100%);
    }

    .dark-mode .tech-line-right-2 {
        background: linear-gradient(90deg, 
            rgba(102, 32, 52, 0.4) 0%, 
            transparent 100%);
    }

    .dark-mode .tech-center-dot {
        background: linear-gradient(45deg, #202127, #662034);
        box-shadow: 0 0 4px rgba(32, 33, 39, 0.6);
    }

    .dark-mode .tech-center-dot-2 {
        border-color: rgba(32, 33, 39, 0.3);
    }



    /* 科技感装饰元素动画 */
    @keyframes techPulse {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.8;
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.1);
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes techGlow {
        0%, 100% { 
            opacity: 0.8;
            box-shadow: 0 0 5px rgba(192, 201, 182, 0.5);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 15px rgba(192, 201, 182, 0.8);
        }
    }

    @keyframes techFloat {
        0%, 100% { 
            transform: translateY(0px);
            opacity: 0.7;
        }
        50% { 
            transform: translateY(-3px);
            opacity: 1;
        }
    }

    @keyframes techFade {
        0%, 100% { 
            opacity: 0.4;
            transform: scale(0.8);
        }
        50% { 
            opacity: 1;
            transform: scale(1.1);
        }
    }

    @keyframes techScale {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.15);
            opacity: 1;
            box-shadow: 0 0 10px rgba(200, 170, 189, 0.6);
        }
    }

    /* 线性装饰动画 */
    @keyframes techLinePulse {
        0%, 100% { 
            opacity: 0.4;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.1);
        }
    }

    @keyframes techLineLeft {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) translateX(0px);
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 0.8;
            transform: translateY(-50%) translateX(-1px);
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes techLineRight {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) translateX(0px);
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 0.8;
            transform: translateY(-50%) translateX(1px);
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes techCenterPulse {
        0%, 100% { 
            opacity: 0.4;
            transform: translate(-50%, -50%) scale(0.9);
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.5);
        }
    }

    /* 科技感曲线动画 */
    @keyframes techCurveGlow {
        0%, 100% { 
            opacity: 0.4;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
        }
        50% { 
            opacity: 0.7;
            box-shadow: 0 0 20px rgba(200, 170, 189, 0.7);
        }
    }

    @keyframes techCurvePulse {
        0%, 100% { 
            opacity: 0.4;
            transform: rotate(0deg) scale(0.9);
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 1;
            transform: rotate(0deg) scale(1.05);
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.5);
        }
    }

    /* 新增静态光效装饰 */
    .monitoring-card .static-glow {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
        background: 
            radial-gradient(circle at 20% 20%, rgba(200, 170, 189, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(190, 50, 85, 0.08) 0%, transparent 50%),
            radial-gradient(circle at 40% 60%, rgba(192, 201, 182, 0.06) 0%, transparent 50%);
        border-radius: 16px;
    }

    .dark-mode .monitoring-card .static-glow {
        background: 
            radial-gradient(circle at 20% 20%, rgba(86, 136, 151, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(102, 32, 52, 0.08) 0%, transparent 50%),
            radial-gradient(circle at 40% 60%, rgba(25, 91, 154, 0.06) 0%, transparent 50%);
    }

    /* 科技感光点装饰 */
    .monitoring-card .tech-light-dots {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .tech-light-dots::before,
    .monitoring-card .tech-light-dots::after {
        content: '';
        position: absolute;
        width: 2px;
        height: 2px;
        background: rgba(200, 170, 189, 0.6);
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(200, 170, 189, 0.4);
    }

    .monitoring-card .tech-light-dots::before {
        top: 25%;
        left: 15%;
        animation: lightDotGlow 3s ease-in-out infinite;
    }

    .monitoring-card .tech-light-dots::after {
        bottom: 30%;
        right: 20%;
        animation: lightDotGlow 3s ease-in-out infinite 1.5s;
    }

    .dark-mode .monitoring-card .tech-light-dots::before,
    .dark-mode .monitoring-card .tech-light-dots::after {
        background: rgba(86, 136, 151, 0.6);
        box-shadow: 0 0 4px rgba(86, 136, 151, 0.4);
    }

    /* 光点闪烁动画 */
    @keyframes lightDotGlow {
        0%, 100% { 
            opacity: 0.6;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.4);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.8);
        }
    }

    /* 深色模式光点样式 */
    .dark-mode .monitoring-card .tech-light-dots::before,
    .dark-mode .monitoring-card .tech-light-dots::after {
        background: rgba(86, 136, 151, 0.6);
        box-shadow: 0 0 4px rgba(86, 136, 151, 0.4);
    }

    /* 新增角落光效装饰 */
    .monitoring-card .corner-glow {
        position: absolute;
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .corner-glow.top-left {
        top: 8px;
        left: 8px;
        background: radial-gradient(circle, rgba(200, 170, 189, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite;
    }

    .monitoring-card .corner-glow.top-right {
        top: 8px;
        right: 8px;
        background: radial-gradient(circle, rgba(190, 50, 85, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite 1s;
    }

    .monitoring-card .corner-glow.bottom-left {
        bottom: 8px;
        left: 8px;
        background: radial-gradient(circle, rgba(192, 201, 182, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite 2s;
    }

    .monitoring-card .corner-glow.bottom-right {
        bottom: 8px;
        right: 8px;
        background: radial-gradient(circle, rgba(206, 169, 188, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite 3s;
    }

    .dark-mode .monitoring-card .corner-glow.top-left {
        background: radial-gradient(circle, rgba(86, 136, 151, 0.4) 0%, transparent 70%);
    }

    .dark-mode .monitoring-card .corner-glow.top-right {
        background: radial-gradient(circle, rgba(102, 32, 52, 0.4) 0%, transparent 70%);
    }

    .dark-mode .monitoring-card .corner-glow.bottom-left {
        background: radial-gradient(circle, rgba(25, 91, 154, 0.4) 0%, transparent 70%);
    }

    .dark-mode .monitoring-card .corner-glow.bottom-right {
        background: radial-gradient(circle, rgba(86, 136, 151, 0.4) 0%, transparent 70%);
    }

    /* 角落光效动画 */
    @keyframes cornerGlow {
        0%, 100% { 
            opacity: 0.4;
            transform: scale(1);
        }
        50% { 
            opacity: 0.8;
            transform: scale(1.2);
        }
    }

    /* 新增静态扫描线效果 */
    .monitoring-card .scan-lines {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(200, 170, 189, 0.03) 2px,
            rgba(200, 170, 189, 0.03) 4px
        );
        border-radius: 16px;
        animation: scanLineGlow 6s ease-in-out infinite;
    }

    .dark-mode .monitoring-card .scan-lines {
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(86, 136, 151, 0.03) 2px,
            rgba(86, 136, 151, 0.03) 4px
        );
    }

    /* 扫描线光效动画 */
    @keyframes scanLineGlow {
        0%, 100% { 
            opacity: 0.03;
        }
        50% { 
            opacity: 0.08;
        }
    }

    /* 噪波纹理效果 */
    #monitoring-screen::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: 
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(200, 170, 189, 0.1) 2px,
                rgba(200, 170, 189, 0.1) 4px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 2px,
                rgba(200, 170, 189, 0.1) 2px,
                rgba(200, 170, 189, 0.1) 4px
            );
        z-index: 0;
        pointer-events: none;
    }

    .dark-mode #monitoring-screen::after {
        background-image: 
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(86, 136, 151, 0.2) 2px,
                rgba(86, 136, 151, 0.2) 4px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 2px,
                rgba(86, 136, 151, 0.2) 2px,
                rgba(86, 136, 151, 0.2) 4px
            );
    }

    /* 动态监控卡片样式 */
    .monitoring-card {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(200, 170, 189, 0.5));
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(200, 170, 189, 0.3);
        border-radius: 16px;
        position: relative;
        overflow: hidden;
        transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        box-shadow: 
            0 8px 32px rgba(200, 170, 189, 0.3),
            0 4px 16px rgba(190, 50, 85, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .dark-mode .monitoring-card {
        background: rgba(32, 33, 39, 0.3);
        border-color: rgba(102, 32, 52, 0.3);
        box-shadow: 
            0 8px 32px rgba(32, 33, 39, 0.2),
            0 4px 16px rgba(102, 32, 52, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* 卡片光效边框 */
    .monitoring-card::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, 
            rgba(200, 170, 189, 0.5), 
            rgba(190, 50, 85, 0.6), 
            rgba(192, 201, 182, 0.5), 
            rgba(206, 169, 188, 0.5));
        background-size: 400% 400%;
        border-radius: 18px;
        z-index: -1;
        animation: borderGlow 4s ease-in-out infinite;
        opacity: 0.6;
    }

    .dark-mode .monitoring-card::before {
        background: linear-gradient(45deg, 
            rgba(32, 33, 39, 0.8), 
            rgba(102, 32, 52, 0.8), 
            rgba(86, 136, 151, 0.6), 
            rgba(25, 91, 154, 0.8));
    }

    /* 卡片悬停效果 */
    .monitoring-card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 
            0 16px 48px rgba(200, 170, 189, 0.2),
            0 8px 24px rgba(190, 50, 85, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .dark-mode .monitoring-card:hover {
        box-shadow: 
            0 16px 48px rgba(32, 33, 39, 0.4),
            0 8px 24px rgba(102, 32, 52, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* 动态监控标题栏美化 */
    #monitoring-screen .app-header {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(200, 170, 189, 0.5));
        backdrop-filter: blur(25px);
        -webkit-backdrop-filter: blur(25px);
        border-bottom: 1px solid rgba(200, 170, 189, 0.3);
        position: relative;
        overflow: hidden;
    }

    .dark-mode #monitoring-screen .app-header {
        background: rgba(32, 33, 39, 0.4);
        border-bottom-color: rgba(102, 32, 52, 0.4);
    }

    /* 标题栏光效 - 改为静态光效 */
    #monitoring-screen .app-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            radial-gradient(ellipse at 20% 50%, rgba(200, 170, 189, 0.1) 0%, transparent 50%),
            radial-gradient(ellipse at 80% 50%, rgba(190, 50, 85, 0.08) 0%, transparent 50%);
        animation: headerGlow 5s ease-in-out infinite;
    }

    .dark-mode #monitoring-screen .app-header::before {
        background: 
            radial-gradient(ellipse at 20% 50%, rgba(86, 136, 151, 0.1) 0%, transparent 50%),
            radial-gradient(ellipse at 80% 50%, rgba(102, 32, 52, 0.08) 0%, transparent 50%);
    }

    /* 标题文字效果 */
    #monitoring-screen .app-header-title {
        background: linear-gradient(45deg, #C8AABD, #BE3255, #C0C9B6, #CEA9BC);
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: titleGlow 3s ease-in-out infinite;
        text-shadow: 0 0 20px rgba(190, 50, 85, 0.5);
        /* 确保文字在渐变不兼容时仍然可见 */
        color: #BE3255;
    }

    .dark-mode #monitoring-screen .app-header-title {
        /* 夜间模式使用纯色确保文字可见 */
        background: none;
        -webkit-background-clip: unset;
        -webkit-text-fill-color: unset;
        background-clip: unset;
        color: #568897;
        text-shadow: 0 0 20px rgba(86, 136, 151, 0.5);
    }

    /* 副标题效果 */
    #monitoring-screen .app-header .text-xs {
        color: #C8AABD;
        text-shadow: 0 0 10px rgba(200, 170, 189, 0.5);
    }

    .dark-mode #monitoring-screen .app-header .text-xs {
        color: #568897;
        text-shadow: 0 0 10px rgba(86, 136, 151, 0.5);
    }

    /* 标题栏光效动画 */
    @keyframes headerGlow {
        0%, 100% { 
            opacity: 0.1;
        }
        50% { 
            opacity: 0.2;
        }
    }

    /* 返回按钮美化 */
    #monitoring-back-button {
        background: rgba(200, 170, 189, 0.2);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(200, 170, 189, 0.3);
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        color: #BE3255;
    }

    .dark-mode #monitoring-back-button {
        background: rgba(32, 33, 39, 0.4);
        border-color: rgba(102, 32, 52, 0.4);
        color: #568897;
    }

    #monitoring-back-button:hover {
        background: rgba(200, 170, 189, 0.3);
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(200, 170, 189, 0.4);
        color: #BE3255;
    }

    .dark-mode #monitoring-back-button:hover {
        background: rgba(102, 32, 52, 0.5);
        box-shadow: 0 0 20px rgba(102, 32, 52, 0.4);
    }

    /* 身份信息块美化 */
    #monitoring-identity-block {
        position: relative;
        overflow: hidden;
    }





    /* 头像美化 */
    #monitoring-avatar {
        border: 2px solid rgba(200, 170, 189, 0.6);
        box-shadow: 0 0 20px rgba(200, 170, 189, 0.3);
        transition: all 0.3s ease;
    }

    .dark-mode #monitoring-avatar {
        border-color: rgba(86, 136, 151, 0.6);
        box-shadow: 0 0 20px rgba(86, 136, 151, 0.3);
    }

    #monitoring-avatar:hover {
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(200, 170, 189, 0.5);
    }

    .dark-mode #monitoring-avatar:hover {
        box-shadow: 0 0 30px rgba(86, 136, 151, 0.5);
    }

    /* 状态文本容器美化 */
    #monitoring-text-container {
        /* 防止滚动冲突 */
        overscroll-behavior: contain;
        /* 添加滚动提示 */
        position: relative;
        /* 让容器在页面中居中，但文本保持自然段落格式 */
        max-width: 800px;
        margin: 0 auto;
        /* 设置合适的左右边距，为滚动条留出空间 */
        padding-left: 2rem;
        padding-right: 3rem;
        /* 触摸优化 */
        -webkit-overflow-scrolling: touch;
        touch-action: pan-y;
        /* 确保在手机上可以正常滚动 */
        overflow-y: auto;
        /* 触摸滚动性能优化 */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        /* 设置合适的高度，避免滚动条过长 */
        height: 300px !important;
        min-height: 200px !important;
        max-height: 550px !important;
        /* 确保滚动条不会超出容器边界 */
        box-sizing: border-box;
    }

    /* 自定义滚动条样式 - 赛博朋克风格 */
    #monitoring-text-container::-webkit-scrollbar {
        width: 12px;
        background: rgba(20, 20, 30, 0.9);
        border-radius: 6px;
        border: 1px solid rgba(190, 50, 85, 0.5);
        /* 确保滚动条在容器内部 */
        margin-right: 0;
        /* 确保滚动条在最上层 */
        z-index: 9999;
    }

    #monitoring-text-container::-webkit-scrollbar-track {
        background: rgba(20, 20, 30, 0.4);
        border-radius: 6px;
        border: 1px solid rgba(190, 50, 85, 0.3);
        /* 确保滚动条轨道在最上层 */
        z-index: 9999;
    }

    /* Firefox 滚动条样式 */
    #monitoring-text-container {
        scrollbar-width: thin;
        scrollbar-color: rgba(190, 50, 85, 0.9) rgba(20, 20, 30, 0.4);
        /* 确保滚动条可见 */
        overflow-y: auto !important;
        /* 确保滚动条在容器内部 */
        overflow-x: hidden !important;
        /* 确保容器在最上层 */
        position: relative;
        z-index: 9999;
    }



    #monitoring-text-container::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, 
            rgba(190, 50, 85, 0.9) 0%, 
            rgba(120, 30, 60, 0.9) 50%, 
            rgba(190, 50, 85, 0.9) 100%);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 
            inset 0 1px 0 rgba(255, 255, 255, 0.3),
            0 0 8px rgba(190, 50, 85, 0.5);
        transition: all 0.3s ease;
        /* 限制滚动条滑块的最小高度，避免过长 */
        min-height: 20px;
        /* 确保滚动条滑块在最上层 */
        z-index: 9999;
    }

    #monitoring-text-container::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, 
            rgba(220, 70, 105, 0.9) 0%, 
            rgba(150, 50, 80, 0.9) 50%, 
            rgba(220, 70, 105, 0.9) 100%);
        box-shadow: 
            inset 0 1px 0 rgba(255, 255, 255, 0.4),
            0 0 12px rgba(220, 70, 105, 0.7);
        /* 确保hover状态也在最上层 */
        z-index: 9999;
    }

    #monitoring-text-container::-webkit-scrollbar-thumb:active {
        background: linear-gradient(135deg, 
            rgba(255, 90, 125, 0.9) 0%, 
            rgba(180, 70, 90, 0.9) 50%, 
            rgba(255, 90, 125, 0.9) 100%);
        box-shadow: 
            inset 0 1px 0 rgba(255, 255, 255, 0.5),
            0 0 16px rgba(255, 90, 125, 0.8);
        /* 确保active状态也在最上层 */
        z-index: 9999;
    }

    /* 状态文本美化 */
    #monitoring-status-text {
        color: #365FAF;
        text-shadow: 0 0 10px rgba(200, 170, 189, 0.3);
        line-height: 1.8;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        /* 保持文本的自然段落格式 */
        text-align: left;
    }

    .dark-mode #monitoring-status-text {
        color: #568897;
        text-shadow: 0 0 10px rgba(86, 136, 151, 0.3);
    }

    /* 时间戳美化 */
    #monitoring-timestamp {
        color: #BE3255;
        font-weight: 500;
        text-shadow: 0 0 8px rgba(190, 50, 85, 0.4);
    }

    .dark-mode #monitoring-timestamp {
        color: #568897;
        text-shadow: 0 0 8px rgba(86, 136, 151, 0.4);
    }

    /* 胶囊按钮美化 */
    .monitoring-capsule-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.375rem;
        height: 2.5rem;
        padding-left: 1.25rem;
        padding-right: 1.25rem;
        border-radius: 9999px;
        background: linear-gradient(135deg, rgba(200, 170, 189, 0.3), rgba(190, 50, 85, 0.4));
        color: #BE3255;
        font-size: 0.875rem;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        border: 1px solid rgba(200, 170, 189, 0.4);
        box-shadow: 
            0 4px 15px rgba(200, 170, 189, 0.2),
            0 2px 8px rgba(190, 50, 85, 0.2);
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
    }

    .dark-mode .monitoring-capsule-btn {
        background: linear-gradient(135deg, rgba(32, 33, 39, 0.5), rgba(102, 32, 52, 0.5));
        border-color: rgba(102, 32, 52, 0.5);
        box-shadow: 
            0 4px 15px rgba(32, 33, 39, 0.3),
            0 2px 8px rgba(102, 32, 52, 0.3);
    }

    /* 按钮光效 */
    .monitoring-capsule-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.2), 
            transparent);
        transition: left 0.6s ease;
    }

    .monitoring-capsule-btn:hover::before {
        left: 100%;
    }

    .monitoring-capsule-btn:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 
            0 8px 25px rgba(200, 170, 189, 0.4),
            0 4px 15px rgba(190, 50, 85, 0.4);
        background: linear-gradient(135deg, rgba(200, 170, 189, 0.5), rgba(190, 50, 85, 0.6));
    }

    .dark-mode .monitoring-capsule-btn:hover {
        box-shadow: 
            0 8px 25px rgba(32, 33, 39, 0.5),
            0 4px 15px rgba(102, 32, 52, 0.5);
        background: linear-gradient(135deg, rgba(32, 33, 39, 0.7), rgba(102, 32, 52, 0.7));
    }

    .monitoring-capsule-btn:active {
        transform: translateY(-1px) scale(0.98);
    }

    .monitoring-capsule-btn i {
        font-size: 1.125rem;
        transition: transform 0.3s ease;
    }

    .monitoring-capsule-btn:hover i {
        transform: rotate(15deg);
    }

    /* 刷新按钮旋转动画 */
    .refresh-rotating {
        animation: refreshRotate 1s linear infinite;
    }

    @keyframes refreshRotate {
        from {
            transform: rotate(0deg);
        }
        to {
            transform: rotate(360deg);
        }
    }

    /* 持续监控按钮增强闪烁光效 */
    .monitoring-pulse {
        animation: monitoringPulse 1.5s ease-in-out infinite;
        position: relative;
    }

    .monitoring-pulse::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: radial-gradient(circle, rgba(190, 50, 85, 0.8) 0%, transparent 70%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: monitoringPulseRing 1.5s ease-in-out infinite;
        pointer-events: none;
    }

    @keyframes monitoringPulse {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
            box-shadow: 
                0 0 0 0 rgba(190, 50, 85, 0.7),
                0 0 0 0 rgba(200, 170, 189, 0.5);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.05);
            box-shadow: 
                0 0 0 8px rgba(190, 50, 85, 0.3),
                0 0 0 12px rgba(200, 170, 189, 0.2);
        }
    }

    @keyframes monitoringPulseRing {
        0% {
            width: 0;
            height: 0;
            opacity: 1;
        }
        100% {
            width: 60px;
            height: 60px;
            opacity: 0;
        }
    }

    .dark-mode .monitoring-pulse::after {
        background: radial-gradient(circle, rgba(102, 32, 52, 0.8) 0%, transparent 70%);
    }

    .dark-mode .monitoring-pulse {
        animation: monitoringPulseDark 1.5s ease-in-out infinite;
    }

    @keyframes monitoringPulseDark {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
            box-shadow: 
                0 0 0 0 rgba(102, 32, 52, 0.7),
                0 0 0 0 rgba(32, 33, 39, 0.5);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.05);
            box-shadow: 
                0 0 0 8px rgba(102, 32, 52, 0.3),
                0 0 0 12px rgba(32, 33, 39, 0.2);
        }
    }

    /* 动画定义 */
    @keyframes particleFloat {
        0%, 100% { 
            transform: translateY(0px) rotate(0deg);
            opacity: 0.3;
        }
        25% { 
            transform: translateY(-10px) rotate(90deg);
            opacity: 0.7;
        }
        50% { 
            transform: translateY(-5px) rotate(180deg);
            opacity: 0.5;
        }
        75% { 
            transform: translateY(-15px) rotate(270deg);
            opacity: 0.8;
        }
    }

    @keyframes borderGlow {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes headerShine {
        0% { left: -100%; }
        50% { left: 100%; }
        100% { left: 100%; }
    }

    @keyframes titleGlow {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes cardGlow {
        0%, 100% { opacity: 0.5; }
        50% { opacity: 1; }
    }

    /* 响应式设计 */
    @media (max-width: 480px) {
        .monitoring-capsule-btn {
            height: 2.25rem;
            padding-left: 1rem;
            padding-right: 1rem;
            font-size: 0.8rem;
        }
        
        .monitoring-card {
            padding: 0.75rem;
        }
        
        #monitoring-avatar {
            width: 2.5rem;
            height: 2.5rem;
        }
    }

    /* ====== 新增科技化元素 START ====== */
    
    /* 1. 科技感扫描线效果 */
    .monitoring-card::after {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        height: 2px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            #C8AABD 20%, 
            #BE3255 40%, 
            #C0C9B6 60%, 
            #CEA9BC 80%, 
            transparent 100%);
        animation: scanLine 3s linear infinite;
        z-index: 0;
        opacity: 0.8;
    }

    .dark-mode .monitoring-card::after {
        background: linear-gradient(90deg, 
            transparent 0%, 
            #202127 20%, 
            #662034 40%, 
            #568897 60%, 
            #195B9A 80%, 
            transparent 100%);
    }

    /* 2. 科技感数据流效果 */
    .monitoring-card .data-stream {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        pointer-events: none;
        z-index: 0;
    }

    /* 2.5. 米白色-粉色渐变透明背景 */
    .monitoring-card .cream-pink-bg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255, 248, 240, 0.15) 0%, rgba(255, 228, 225, 0.2) 50%, rgba(255, 228, 225, 0.2) 50%, rgba(255, 248, 240, 0.15) 100%);
        border-radius: 15px;
        z-index: 0;
    }

    .monitoring-card .data-stream::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 20px,
            rgba(200, 170, 189, 0.1) 20px,
            rgba(200, 170, 189, 0.1) 22px
        );
        animation: dataGlow 3s ease-in-out infinite;
    }

    .dark-mode .monitoring-card .data-stream::before {
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 20px,
            rgba(32, 33, 39, 0.2) 20px,
            rgba(32, 33, 39, 0.2) 22px
        );
        animation: dataGlow 3s ease-in-out infinite;
    }

    /* 3. 科技感能量环 */
    .monitoring-card .energy-ring {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 380px;
        height: 380px;
        transform: translate(-50%, -50%);
        border: 2px solid transparent;
        border-top: 2px solid #E8D5E0;
        border-right: 2px solid #D14A6B;
        border-bottom: 2px solid #D0E5F0;
        border-left: 2px solid #E6C5D8;
        border-radius: 50%;
        animation: energyGlow 4s ease-in-out infinite;
        opacity: 0.4;
        z-index: 0;
    }

    .dark-mode .monitoring-card .energy-ring {
        border-top-color: #2A2D35;
        border-right-color: #7A2A4A;
        border-bottom-color: #4A7A8A;
        border-left-color: #2A5A7A;
    }

    .monitoring-card .energy-ring::before {
        content: '';
        position: absolute;
        top: -6px;
        left: -6px;
        right: -6px;
        bottom: -6px;
        border: 1px solid transparent;
        border-top: 1px solid #E8D5E0;
        border-right: 1px solid #D14A6B;
        border-bottom: 1px solid #D0E5F0;
        border-left: 1px solid #E6C5D8;
        border-radius: 50%;
        animation: energyGlow 4s ease-in-out infinite 0.5s;
        opacity: 0.3;
    }

    .dark-mode .monitoring-card .energy-ring::before {
        border-top-color: #2A2D35;
        border-right-color: #7A2A4A;
        border-bottom-color: #4A7A8A;
        border-left-color: #2A5A7A;
    }

    /* 4. 科技感脉冲点阵 */
    .monitoring-card .pulse-grid {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .pulse-grid .pulse-dot {
        position: absolute;
        width: 3px;
        height: 3px;
        border-radius: 50%;
        animation: pulseGrid 2s ease-in-out infinite;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(1) {
        top: 15%;
        left: 10%;
        background: #C8AABD;
        animation-delay: 0s;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(2) {
        top: 25%;
        right: 15%;
        background: #BE3255;
        animation-delay: 0.3s;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(3) {
        bottom: 20%;
        left: 20%;
        background: #C0C9B6;
        animation-delay: 0.6s;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(4) {
        bottom: 30%;
        right: 25%;
        background: #CEA9BC;
        animation-delay: 0.9s;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(1) {
        background: #202127;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(2) {
        background: #662034;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(3) {
        background: #568897;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(4) {
        background: #195B9A;
    }

    /* 5. 科技感连接线 */
    .monitoring-card .connection-lines {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .connection-lines .line {
        position: absolute;
        height: 1px;
        background: linear-gradient(90deg, #C8AABD, #BE3255);
        animation: connectionFlow 3s ease-in-out infinite;
    }

    .monitoring-card .connection-lines .line:nth-child(1) {
        top: 20%;
        left: 5%;
        width: 40px;
        animation-delay: 0s;
    }

    .monitoring-card .connection-lines .line:nth-child(2) {
        top: 60%;
        right: 5%;
        width: 35px;
        background: linear-gradient(90deg, #C0C9B6, #CEA9BC);
        animation-delay: 1s;
    }

    .dark-mode .monitoring-card .connection-lines .line {
        background: linear-gradient(90deg, #202127, #662034);
    }

    .dark-mode .monitoring-card .connection-lines .line:nth-child(2) {
        background: linear-gradient(90deg, #568897, #195B9A);
    }

    /* 6. 科技感状态指示器 */
    .monitoring-card .status-indicator {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #C8AABD;
        box-shadow: 0 0 8px #C8AABD;
        animation: statusPulse 2s ease-in-out infinite;
        z-index: 0;
    }

    .dark-mode .monitoring-card .status-indicator {
        background: #202127;
        box-shadow: 0 0 8px #202127;
    }

    .monitoring-card .status-indicator::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        border: 1px solid #C8AABD;
        border-radius: 50%;
        animation: statusRing 2s ease-in-out infinite;
        opacity: 0.6;
    }

    .dark-mode .monitoring-card .status-indicator::before {
        border-color: #202127;
    }

    /* 7. 科技感角落装饰 */
    .monitoring-card .corner-decoration {
        position: absolute;
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .corner-decoration.top-left {
        top: 8px;
        left: 8px;
        border-top: 2px solid #C8AABD;
        border-left: 2px solid #C8AABD;
        border-top-left-radius: 8px;
    }

    .monitoring-card .corner-decoration.top-right {
        top: 8px;
        right: 8px;
        border-top: 2px solid #BE3255;
        border-right: 2px solid #BE3255;
        border-top-right-radius: 8px;
    }

    .monitoring-card .corner-decoration.bottom-left {
        bottom: 8px;
        left: 8px;
        border-bottom: 2px solid #C0C9B6;
        border-left: 2px solid #C0C9B6;
        border-bottom-left-radius: 8px;
    }

    .monitoring-card .corner-decoration.bottom-right {
        bottom: 8px;
        right: 8px;
        border-bottom: 2px solid #CEA9BC;
        border-right: 2px solid #CEA9BC;
        border-bottom-right-radius: 8px;
    }

    .dark-mode .monitoring-card .corner-decoration.top-left {
        border-color: #202127;
    }

    .dark-mode .monitoring-card .corner-decoration.top-right {
        border-color: #662034;
    }

    .dark-mode .monitoring-card .corner-decoration.bottom-left {
        border-color: #568897;
    }

    .dark-mode .monitoring-card .corner-decoration.bottom-right {
        border-color: #195B9A;
    }

    /* 8. 科技感背景网格 */
    .monitoring-card .grid-background {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: 
            linear-gradient(rgba(200, 170, 189, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(200, 170, 189, 0.1) 1px, transparent 1px);
        background-size: 20px 20px;
        opacity: 0.3;
        pointer-events: none;
        z-index: 0;
    }

    .dark-mode .monitoring-card .grid-background {
        background-image: 
            linear-gradient(rgba(32, 33, 39, 0.2) 1px, transparent 1px),
            linear-gradient(90deg, rgba(32, 33, 39, 0.2) 1px, transparent 1px);
    }

    /* 9. 科技感浮动粒子 */
    .monitoring-card .floating-particles {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .floating-particles .particle {
        position: absolute;
        width: 2px;
        height: 2px;
        border-radius: 50%;
        animation: floatParticle 6s ease-in-out infinite;
    }

    .monitoring-card .floating-particles .particle:nth-child(1) {
        top: 20%;
        left: 15%;
        background: #C8AABD;
        animation-delay: 0s;
    }

    .monitoring-card .floating-particles .particle:nth-child(2) {
        top: 40%;
        right: 20%;
        background: #BE3255;
        animation-delay: 2s;
    }

    .monitoring-card .floating-particles .particle:nth-child(3) {
        bottom: 25%;
        left: 30%;
        background: #C0C9B6;
        animation-delay: 4s;
    }

    .dark-mode .monitoring-card .floating-particles .particle:nth-child(1) {
        background: #202127;
    }

    .dark-mode .monitoring-card .floating-particles .particle:nth-child(2) {
        background: #662034;
    }

    .dark-mode .monitoring-card .floating-particles .particle:nth-child(3) {
        background: #568897;
    }

    /* 10. 新增动画定义 */
    @keyframes bottomFlash {
        0%, 100% { 
            opacity: 0.3;
            box-shadow: 0 0 10px rgba(200, 170, 189, 0.4);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 20px rgba(200, 170, 189, 0.8);
        }
    }

    @keyframes bottomFlashDark {
        0%, 100% { 
            opacity: 0.4;
            box-shadow: 0 0 15px rgba(86, 136, 151, 0.5);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 25px rgba(86, 136, 151, 0.9);
        }
    }

    @keyframes backgroundShimmer {
        0%, 100% { 
            opacity: 0.8;
            filter: brightness(1) saturate(1);
        }
        25% { 
            opacity: 1;
            filter: brightness(1.1) saturate(1.2);
        }
        50% { 
            opacity: 0.9;
            filter: brightness(1.05) saturate(1.1);
        }
        75% { 
            opacity: 1;
            filter: brightness(1.15) saturate(1.3);
        }
    }

    @keyframes backgroundShimmerDark {
        0%, 100% { 
            opacity: 0.7;
            filter: brightness(1) saturate(1);
        }
        25% { 
            opacity: 1;
            filter: brightness(1.2) saturate(1.3);
        }
        50% { 
            opacity: 0.8;
            filter: brightness(1.1) saturate(1.2);
        }
        75% { 
            opacity: 1;
            filter: brightness(1.25) saturate(1.4);
        }
    }

    @keyframes backgroundGlow {
        0%, 100% { 
            opacity: 0.2;
            transform: scale(1);
        }
        50% { 
            opacity: 0.6;
            transform: scale(1.2);
        }
    }

    @keyframes backgroundGlowDark {
        0%, 100% { 
            opacity: 0.3;
            transform: scale(1);
        }
        50% { 
            opacity: 0.7;
            transform: scale(1.3);
        }
    }

    @keyframes scanLine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }

    @keyframes dataFlow {
        0% { transform: translateY(-100%); }
        100% { transform: translateY(100%); }
    }

    @keyframes energyGlow {
        0%, 100% { 
            opacity: 0.4;
            box-shadow: 0 0 20px rgba(200, 170, 189, 0.3);
        }
        50% { 
            opacity: 0.7;
            box-shadow: 0 0 30px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes dataGlow {
        0%, 100% { 
            opacity: 0.1;
        }
        50% { 
            opacity: 0.3;
        }
    }

    @keyframes pulseGrid {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.1);
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes connectionFlow {
        0%, 100% { 
            opacity: 0.3;
            transform: scaleX(0.9);
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 0.8;
            transform: scaleX(1.1);
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes statusPulse {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.8;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.15);
            opacity: 1;
            box-shadow: 0 0 12px rgba(200, 170, 189, 0.6);
        }
    }

    /* 新增：科技感动画定义 */
    @keyframes xrayScan {
        0% { 
            transform: translateY(-100%);
            opacity: 0;
        }
        20% { 
            opacity: 1;
        }
        80% { 
            opacity: 1;
        }
        100% { 
            transform: translateY(100vh);
            opacity: 0;
        }
    }

    @keyframes gridPulse {
        0%, 100% { 
            opacity: 0.2;
            transform: scale(1);
        }
        50% { 
            opacity: 0.4;
            transform: scale(1.05);
        }
    }

    @keyframes dataStream {
        0% { 
            transform: translateY(-100%);
            opacity: 0;
        }
        20% { 
            opacity: 0.8;
        }
        80% { 
            opacity: 0.8;
        }
        100% { 
            transform: translateY(100vh);
            opacity: 0;
        }
    }

    @keyframes energyRipple {
        0% { 
            width: 0;
            height: 0;
            opacity: 1;
            border-width: 1px;
        }
        100% { 
            width: 200px;
            height: 200px;
            opacity: 0;
            border-width: 0.5px;
        }
    }

    @keyframes particleFloat {
        0% { 
            transform: translateY(100vh) scale(0);
            opacity: 0;
        }
        10% { 
            opacity: 1;
            transform: translateY(90vh) scale(1);
        }
        90% { 
            opacity: 1;
            transform: translateY(10vh) scale(1);
        }
        100% { 
            transform: translateY(0) scale(0);
            opacity: 0;
        }
    }

    /* 新增：按钮装饰动画 */
    @keyframes buttonLineLeft {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.2);
        }
    }

    @keyframes buttonLineRight {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.2);
        }
    }

    @keyframes buttonCenterPulse {
        0%, 100% { 
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.6;
        }
        50% { 
            transform: translate(-50%, -50%) scale(1.3);
            opacity: 1;
        }
    }

    /* 新增：悬停效果动画 */
    @keyframes techCornerHover {
        0% { 
            transform: scale(1);
            opacity: 0.6;
        }
        100% { 
            transform: scale(1.2);
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes statusIndicatorHover {
        0% { 
            transform: scale(1);
            opacity: 0.8;
        }
        100% { 
            transform: scale(1.3);
            opacity: 1;
            box-shadow: 0 0 12px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes statusRing {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.2);
        }
        50% { 
            transform: scale(1.2);
            opacity: 0.3;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes floatParticle {
        0%, 100% { 
            transform: translateY(0px) translateX(0px);
            opacity: 0.4;
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        25% { 
            transform: translateY(-3px) translateX(2px);
            opacity: 0.8;
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
        50% { 
            transform: translateY(-2px) translateX(-1px);
            opacity: 0.6;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.3);
        }
        75% { 
            transform: translateY(-4px) translateX(3px);
            opacity: 0.9;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.5);
        }
    }

    /* ====== 新增科技化元素 END ====== */

    /* V18.0 新增：表情包专属样式 */
    .chat-message.sticker-message.sticker-bubble,
    .chat-message.sticker-message {
        background: transparent !important; /* 让气泡背景变透明 */
        background-color: transparent !important; /* 兼容性 */
        background-image: none !important; /* 移除渐变背景 */
        padding: 0 !important; /* 移除内边距 */
        box-shadow: none !important; /* 移除阴影 */
        border: none !important; /* 移除边框 */
        backdrop-filter: none !important; /* 移除毛玻璃效果 */
        -webkit-backdrop-filter: none !important; /* Safari兼容 */
    }

    .sticker-image {
        max-width: 120px; /* 限制表情包最大宽度 */
        max-height: 120px; /* 限制表情包最大高度 */
        display: block; /* 确保它是个块级元素 */
    }

    /* V33.0 新增：日记本更新辉光效果 */
    @keyframes diary-glow-pulse {
        0% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 0 0 rgba(253, 124, 159, 0.3); /* 粉红色光晕 #FD7C9F */
            transform: translateY(0) rotate(0) scale(1);
        }
        50% {
            box-shadow: 
                0 12px 35px rgba(0, 0, 0, 0.4),
                0 0 10px 4px rgba(253, 124, 159, 0.5); /* 光晕扩大 */
            transform: translateY(-2px) rotate(0.5deg) scale(1.01); /* 轻微浮动 */
        }
        100% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 0 0 rgba(253, 124, 159, 0.3);
            transform: translateY(0) rotate(0) scale(1);
        }
    }

    .diary-book-item.new-entry {
        animation: diary-glow-pulse 2.5s infinite ease-in-out;
        border-color: rgba(253, 124, 159, 0.4); /* 边框也带上微光 */
    }

    /* 日间模式下的辉光适配 */
    .light-mode .diary-book-item.new-entry {
         animation: diary-glow-pulse-light 2.5s infinite ease-in-out;
         border-color: rgba(187, 44, 87, 0.4); /* 粉红色光晕 */
    }

    @keyframes diary-glow-pulse-light {
        0% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 0 0 0 rgba(187, 44, 87, 0.2);
        }
        50% {
            box-shadow: 
                0 12px 35px rgba(0, 0, 0, 0.2),
                0 0 10px 4px rgba(187, 44, 87, 0.3);
        }
        100% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 0 0 0 rgba(187, 44, 87, 0.2);
        }
    }

    /* V36.1 终极版：强制保护所有图标，确保万无一失 */
    .fab, .fa-brands {
        font-family: "Font Awesome 6 Brands" !important;
        font-weight: 400;
    }
    .fas, .fa-solid {
        font-family: "Font Awesome 6 Free" !important;
        font-weight: 900;
    }
    .far, .fa-regular {
        font-family: "Font Awesome 6 Free" !important;
        font-weight: 400;
    }
    [class^="ri-"] {
        font-family: "RemixIcon" !important;
        font-weight: normal; /* RemixIcon 通常使用 normal 权重 */
    }

    </style>
</head>
<body class="flex items-center justify-center min-h-screen dark-mode">
    <!-- 添加在全屏切换按钮 -->
    <button id="fullscreen-toggle" class="fullscreen-toggle-btn" title="切换全屏">
        <i class="fas fa-expand"></i>
    </button>
    
    <!-- 原有的SVG滤镜 -->
    <svg style="position:absolute; width:0; height:0; overflow:hidden;">
    <!-- SVG濾鏡，用於創建紙張毛邊效果 -->
    <svg style="position:absolute; width:0; height:0; overflow:hidden;">
      <filter id="paper-edge-filter">
        <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" result="noise"/>
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="8" xChannelSelector="R" yChannelSelector="G"/>
      </filter>
    </svg>
    
    <input type="file" id="user-avatar-input" class="hidden" accept="image/*">
    <input type="file" id="chat-bg-input" class="hidden" accept="image/*">
    <input type="file" id="import-data-input" class="hidden" accept=".json">
    <input type="file" id="image-upload-input" class="hidden" accept="image/*">
    <input type="file" id="sticker-upload-input" class="hidden" accept="image/*">
    <input type="file" id="user-video-image-input" class="hidden" accept="image/*">
    <input type="file" id="my-video-image-input" class="hidden" accept="image/*">
    <div class="phone-frame relative w-full max-w-[375px] h-[720px] rounded-[3rem] p-2 shadow-2xl flex flex-col overflow-hidden transform transition-all duration-300">
        
        <div id="phone-screen" class="phone-screen flex-1 rounded-[2.5rem] overflow-hidden relative animate-fade-in">
            
            <div id="home-wallpaper" class="absolute inset-0 w-full h-full z-0"></div>

            <div id="status-bar" class="status-bar absolute top-0 left-0 right-0 z-50 px-5 py-3 text-sm font-semibold flex justify-between items-center transition-colors">
                <div class="flex items-center space-x-2">
                    <span id="currentTime">12:45</span>
                </div>
                <div class="flex items-center space-x-4">
                    <span id="api-status-text" class="text-red-500">API OFF</span>
                    <button id="theme-toggle" class="p-1 rounded-full hover:bg-white/20 transition-colors">
                        <i id="theme-icon" class="fas fa-moon text-lg"></i>
                    </button>
                </div>
            </div>

            <div id="messageBox" class="message-box"></div>
            
            <div id="incoming-call-alert">
                <img id="incoming-call-avatar" src="https://placehold.co/96x96/777/FFF?text=?" alt="avatar">
                <div id="incoming-call-info">
                    <p id="incoming-call-name" class="font-bold">Character Name</p>
                    <p id="incoming-call-type" class="text-sm text-gray-300">正在呼叫...</p>
                </div>
                <button id="answer-call-btn" class="call-btn"><i class="ri-phone-fill"></i></button>
                <button id="decline-call-btn" class="call-btn"><i class="fas fa-phone-slash"></i></button>
            </div>
            

            
            <div id="song-list-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-xl font-bold">播放列表</h3>
                <button id="close-playlist-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="song-list-container" class="space-y-2 max-h-60 overflow-y-auto">
                        </ul>
                </div>
            </div>
            <div id="new-chat-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-xl font-bold">发起新聊天</h3>
                <button id="close-new-chat-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="new-chat-character-list" class="space-y-2 max-h-60 overflow-y-auto">
                        </ul>
                </div>
            </div>
             <div id="confirm-delete-modal" class="modal-overlay">
                <div class="modal-content text-center">
                    <h3 id="delete-modal-title" class="text-lg font-bold mb-4">确认删除吗？</h3>
                    <p id="delete-modal-text" class="text-sm mb-6">此操作无法撤销。</p>
                    <div class="flex justify-around">
                        <button id="cancel-delete-btn" class="px-6 py-2 rounded-lg">取消</button>
                        <button id="confirm-delete-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg">删除</button>
                    </div>
                </div>
            </div>
            <div id="voice-input-modal" class="modal-overlay">
                <div class="modal-content">
                    <h3 class="text-lg font-bold mb-4 text-center">发送语音消息</h3>
                    <textarea id="voice-text-input" class="form-textarea w-full h-24 resize-none" placeholder="在此输入文字..."></textarea>
                    <div class="flex justify-end mt-4 gap-2">
                        <button id="cancel-voice-btn" class="px-4 py-2 rounded-lg">取消</button>
                        <button id="send-voice-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">发送</button>
                    </div>
                </div>
            </div>

            <div id="new-notebook-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">创建新笔记本</h3>
                        <button id="close-new-notebook-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">笔记本名称</label>
                            <input type="text" id="new-notebook-name" class="form-input w-full" placeholder="请输入笔记本名称..." maxlength="20">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">笔记本类型</label>
                            <select id="new-notebook-type" class="form-select w-full">
                                <option value="diary">日记本</option>
                                <option value="notes">笔记本</option>
                                <option value="ideas">想法本</option>
                                <option value="goals">目标本</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div id="custom-type-container" class="hidden">
                            <label class="block text-sm font-medium mb-2">自定义类型名称</label>
                            <input type="text" id="custom-notebook-type" class="form-input w-full" placeholder="请输入自定义类型名称..." maxlength="15">
                        </div>
                        <div class="flex justify-end space-x-3 pt-4">
                            <button id="cancel-new-notebook-btn" class="px-4 py-2 text-gray-300 hover:text-white transition-colors">取消</button>
                            <button id="confirm-new-notebook-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">创建</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 刪除表情包確認彈窗 -->
            <div id="delete-sticker-modal" class="delete-confirm-modal">
                <h3>刪除表情包</h3>
                <p id="delete-sticker-text">確定要刪除選中的表情包嗎？此操作無法撤銷。</p>
                <div class="delete-confirm-buttons">
                    <button id="cancel-delete-sticker-btn" class="delete-confirm-btn cancel">取消</button>
                    <button id="confirm-delete-sticker-btn" class="delete-confirm-btn confirm">刪除</button>
                </div>
            </div>
            <!-- 贴图/表情 Modal -->
            <div id="sticker-modal" class="modal-overlay">
                <div class="modal-content sticker-modal-content">
                    <!-- 标题栏 -->
                    <div class="sticker-modal-header">
                        <h3 class="sticker-modal-title">添加表情</h3>
                        <button id="close-sticker-modal" class="sticker-modal-close" title="关闭">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <div class="sticker-modal-body">
                        <div class="sticker-input-group">
                            <label class="sticker-label">表情关键词</label>
                            <input type="text" id="sticker-keywords-input" class="sticker-input" placeholder="开心,猫,可爱">
                        </div>

                        <button id="upload-sticker-local-btn" class="sticker-upload-btn">
                            <i class="ri-upload-cloud-2-line mr-2"></i>本地上传
                        </button>

                        <div class="sticker-input-group">
                            <label class="sticker-label">或粘贴图片链接</label>
                            <div class="sticker-url-group">
                                <input type="text" id="sticker-url-input" class="sticker-input" placeholder="https://...">
                                <button id="send-sticker-url-btn" class="sticker-add-btn">添加</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <div id="home-screen" class="app-screen-view relative">
                <div id="music-block-container" class="p-2 mt-2">
                    <div id="music-block" class="music-block relative w-full p-3 rounded-2xl flex items-center justify-between shadow-xl music-block-background">
                        <div class="relative w-1/2 flex-shrink-0 flex items-center justify-center">
                            <div id="vinyl-container" class="vinyl-container">
                                <div id="vinyl-record" class="vinyl-image-container">
                                    <div id="vinyl-center" class="vinyl-center"></div>
                                </div>
                            </div>
                            <input type="file" id="background-input" accept="image/*">
                            <input type="file" id="vinyl-input" accept="image/*">
                            <input type="file" id="music-upload-input" accept="audio/*,.mp3,.m4a,.wav,.ogg,.flac" multiple>
                        </div>
                        <div class="flex-grow flex flex-col justify-center h-24 ml-4">
                            <textarea id="mood-text" class="w-full bg-transparent placeholder-gray-300 text-sm p-1 rounded-md resize-none border-none outline-none focus:ring-2 focus:ring-white/50 focus:bg-white/10 transition-all text-center" placeholder="点击填写心情..."></textarea>
                            <div class="flex items-center justify-center space-x-3 mt-2">
                                <button id="loop-button" class="player-button"><i class="fas fa-rotate-right text-base"></i></button>
                                <button id="prev-button" class="player-button"><i class="fas fa-step-backward text-base"></i></button>
                                <button id="play-pause-button" class="player-button"><i class="fas fa-play text-xl"></i></button>
                                <button id="next-button" class="player-button"><i class="fas fa-step-forward text-base"></i></button>
                                <button id="single-loop-button" class="player-button"><i class="fas fa-repeat text-base"></i></button>
                            </div>
                        </div>
                        <div class="absolute bottom-2 right-2 flex space-x-2">
                            <div id="playlist-button" class="p-1 rounded-full cursor-pointer hover:bg-white/30 transition-colors"><i class="fas fa-list text-sm"></i></div>
                            <div id="music-upload-button" class="p-1 rounded-full cursor-pointer hover:bg-white/30 transition-colors"><i class="fas fa-music text-sm"></i></div>
                        </div>
                    </div>
                </div>
                <div class="px-4 grid grid-cols-2 gap-4 mt-2">
                    <div id="photo-widget" class="w-full aspect-square rounded-2xl shadow-xl flex items-center justify-center transition-colors duration-300 cursor-pointer bg-cover bg-center">
                        <span id="photo-widget-text" class="text-2xl font-bold text-white/80">照片墙</span>
                    </div>
                    <input type="file" id="photo-widget-input" accept="image/*">
                    <div id="text-input-widget" class="w-full aspect-square p-4 flex flex-col justify-center transition-colors duration-300">
                        <div class="flex items-center mb-3">
                            <div id="widget-image-placeholder" class="w-10 h-10 rounded-full flex-shrink-0 mr-3 image-placeholder">
                                <i class="fas fa-camera"></i>
                            </div>
                            <input type="text" id="widget-name-input" placeholder="Name" class="text-widget-input text-base border-0 focus:ring-2 focus:ring-white/50">
                            <input type="file" id="widget-image-input" accept="image/*">
                        </div>
                        <input type="text" id="widget-thinking-input" placeholder="Thinking..." class="text-widget-input text-xs mb-3 border-0 focus:ring-2 focus:ring-white/50">
                        <div class="flex items-center">
                            <i class="fas fa-map-marker-alt text-xs mr-2 opacity-80"></i>
                            <input type="text" id="widget-location-input" placeholder="Where r u" class="text-widget-input text-xs border-0 focus:ring-2 focus:ring-white/50">
                        </div>
                    </div>
                </div>
                
                <div class="px-4 grid grid-cols-2 gap-4 mt-4">
                    <div></div> 
                    <div class="grid grid-cols-2 gap-4">
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="动态监控"><i class="ri-eye-line text-white text-2xl"></i></div>
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="设置"><i class="fas fa-cog text-white text-2xl"></i></div>
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="Placeholder 2"><i class="fas fa-question text-white text-2xl"></i></div>
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="Placeholder 3"><i class="fas fa-question text-white text-2xl"></i></div>
                        </div>
                </div>

                <div class="dock absolute bottom-4 left-1/2 -translate-x-1/2 w-[90%] max-w-[340px] h-18 rounded-3xl p-2 flex items-center justify-around shadow-xl">
                    <div class="flex flex-col items-center"><div class="w-14 h-14 bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="世界书"><i class="fas fa-book text-white text-2xl"></i></div></div>
                    <div class="flex flex-col items-center"><div class="w-14 h-14 bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="角色书"><i class="fas fa-theater-masks text-white text-2xl"></i></div></div>
                    <div class="flex flex-col items-center"><div class="w-14 h-14 bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="微信"><i class="fab fa-weixin text-white text-2xl"></i></div></div>
                </div>
            </div>

            <div id="monitoring-screen" class="app-screen-view flex-col hidden font-mono">
                <!-- <div class="bg-gradient-to-b from-gray-900 to-blue-900 absolute inset-0 z-0"></div> -->
                <div class="absolute top-0 left-0 w-full h-full bg-black/30 backdrop-blur-sm z-10"></div>
                
                <!-- 浮动光晕装饰元素 -->
                <div class="bg-glow-1"></div>
                <div class="bg-glow-2"></div>

                <!-- 新增：科技感装饰元素 -->
                <div class="cyber-grid"></div>
                <div class="data-flow-container">
                    <div class="data-stream"></div>
                    <div class="data-stream"></div>
                    <div class="data-stream"></div>
                    <div class="data-stream"></div>
                </div>
                <div class="energy-ripple"></div>
                <div class="energy-ripple"></div>
                <div class="energy-ripple"></div>
                <div class="xray-scan-line"></div>
                <div class="electronic-particles">
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                </div>

                <div class="app-header bg-transparent z-20 border-b border-blue-800/50">
                    <button id="monitoring-back-button" class="app-header-btn text-blue-400 hover:text-white"><i class="fas fa-chevron-left"></i></button>
                    <div class="text-center">
                        <h3 class="app-header-title text-blue-300">动态监控</h3>
                        <p class="text-xs text-blue-500 tracking-widest mt-1">REAL-TIME SURVEILLANCE</p>
                    </div>
                    <div class="w-8"></div>
                </div>

                <div class="flex-1 flex flex-col px-2 py-4 space-y-4 z-20 overflow-y-auto">
                                    <div id="monitoring-identity-block" class="monitoring-card bg-black/60 border border-blue-700/50 backdrop-blur-md rounded-lg p-4 cursor-pointer relative">
                    <!-- 新增静态光效装饰 -->
                    <div class="static-glow"></div>
                    <div class="scan-lines"></div>
                    <div class="tech-light-dots"></div>
                    
                    <!-- 角落光效装饰 -->
                    <div class="corner-glow top-left"></div>
                    <div class="corner-glow top-right"></div>
                    <div class="corner-glow bottom-left"></div>
                    <div class="corner-glow bottom-right"></div>

                    <!-- 新增：科技感角落装饰 -->
                    <div class="tech-corner top-left"></div>
                    <div class="tech-corner top-right"></div>
                    <div class="tech-corner bottom-left"></div>
                    <div class="tech-corner bottom-right"></div>
                    
                    <!-- 新增：状态指示器 -->
                    <div class="status-indicator"></div>
                    
                    <div class="flex items-center">
                        <div id="monitoring-avatar" class="w-12 h-12 rounded-full mr-3 bg-cover bg-center border border-blue-500 flex-shrink-0"></div>
                        <div class="flex-1 overflow-hidden">
                            <p id="monitoring-name" class="text-lg font-semibold text-white truncate">角色名</p>
                            <div id="monitoring-mood" class="text-xs mt-1 flex items-center text-blue-300">
                                <span id="monitoring-mood-icon" class="mr-1"></span>
                                <span id="monitoring-mood-text" class="font-semibold">未知</span>
                            </div>
                        </div>
                    </div>

                </div>

                    <div class="monitoring-card bg-black/60 border border-blue-700/50 backdrop-blur-md rounded-lg p-4 flex-1 relative">
                        <!-- 新增静态光效装饰 -->
                        <div class="static-glow"></div>
                        <div class="scan-lines"></div>
                        <div class="tech-light-dots"></div>
                        
                        <!-- 角落光效装饰 -->
                        <div class="corner-glow top-left"></div>
                        <div class="corner-glow top-right"></div>
                        <div class="corner-glow bottom-left"></div>
                        <div class="corner-glow bottom-right"></div>

                        <!-- 新增：科技感角落装饰 -->
                        <div class="tech-corner top-left"></div>
                        <div class="tech-corner top-right"></div>
                        <div class="tech-corner bottom-left"></div>
                        <div class="tech-corner bottom-right"></div>
                        
                        <!-- 新增：状态指示器 -->
                        <div class="status-indicator"></div>
                        
                        <!-- 米白色-粉色渐变透明背景 -->
                        <div class="cream-pink-bg"></div>
                        
                        <div id="monitoring-text-container" class="overflow-y-auto" style="height: 400px; min-height: 400px;">
                            <p id="monitoring-status-text" class="text-sm text-gray-300 whitespace-pre-wrap leading-relaxed">正在连接信号...</p>
                        </div>
                        <p id="monitoring-timestamp" class="text-xs text-gray-700 text-right mt-2 absolute bottom-2 right-3"></p>

                    </div>
                    
                    <!-- 文本框下方的科技感线性装饰 -->
                    <div class="tech-lines-container mt-3 relative">
                        <!-- 主线条 -->
                        <div class="tech-line-main"></div>
                        <!-- 左侧装饰线 -->
                        <div class="tech-line-left"></div>
                        <div class="tech-line-left-2"></div>
                        <!-- 右侧装饰线 -->
                        <div class="tech-line-right"></div>
                        <div class="tech-line-right-2"></div>
                        <!-- 中心装饰点 -->
                        <div class="tech-center-dot"></div>
                        <div class="tech-center-dot-2"></div>
                    </div>

                    <div class="flex justify-center items-center space-x-3 py-2 relative">
                        <!-- 新增：按钮区域科技感装饰 -->
                        <div class="button-tech-lines">
                            <div class="button-line-left"></div>
                            <div class="button-line-right"></div>
                            <div class="button-center-dot"></div>
                        </div>
                        
                        <button id="monitoring-refresh-button" class="monitoring-capsule-btn" title="刷新当前状态">
                            <i class="ri-refresh-line"></i>
                            <span>刷新</span>
                        </button>
                        <button id="monitoring-next-step-button" class="monitoring-capsule-btn" title="持续监控">
                            <i class="ri-skip-forward-line"></i>
                            <span>持续监控</span>
                        </button>
                    </div>
                </div>
            </div>

            <div id="character-select-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="character-select-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">选择角色</h3>
                    <div class="w-8"></div>
                </div>
                <div id="character-select-list-container" class="flex-1 overflow-y-auto p-2 space-y-2">
                    </div>
            </div>

            <div id="wechat-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wechat-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 id="wechat-list-title" class="app-header-title">WeChat</h3>
                    <div class="flex items-center">
                        <button id="wechat-new-chat-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                        <button id="wechat-new-moment-button" class="app-header-btn ml-2 hidden"><i class="fas fa-plus"></i></button>
                        <button id="wechat-new-plan-button" class="app-header-btn ml-2 hidden"><i class="fas fa-plus"></i></button>
                    </div>
                </div>
                <div id="wechat-content-container" class="flex-1 overflow-y-auto">
                    <div id="wechat-list-container"></div>
                    <!-- V7.1: 全新动态 (Moments) 容器 -->
                    <div id="wechat-moments-container" class="wechat-content-view hidden">
                        <!-- 所有内容一起滚动的容器 -->
                        <div class="h-full overflow-y-auto">
                            <!-- 背景图片和用户名片区域 -->
                            <div class="relative">
                                <div id="moments-header" class="relative h-48 rounded-b-xl overflow-hidden shadow-lg">
                                    <div id="moments-cover" class="absolute inset-0 cursor-pointer" title="点击更换背景" onclick="changeMomentsCover()" style="z-index: 25; position: relative;">
                                        <!-- 提示文字，只在没有背景图片时显示 -->
                                        <div id="moments-cover-hint" class="absolute inset-0 flex items-center justify-center">
                                            <div class="bg-black bg-opacity-30 text-white px-3 py-1 rounded text-sm" style="margin-top: 60px;">
                                                点击更换背景
                                            </div>
                                        </div>

                                    </div>
                                    <div class="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent" style="z-index: 20; pointer-events: none;"></div>
                                    
                                    <!-- 头像和用户名信息，放在背景图片上方，居中靠下 -->
                                    <div id="moments-user-info" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex flex-col items-center" style="z-index: 30;">
                                        <div id="moments-user-avatar" class="w-20 h-20 rounded-full border-2 border-white/80 shadow-lg cursor-pointer mb-2" title="点击更换头像" onclick="changeMomentsAvatar()"></div>
                                        <span id="moments-user-name" class="font-bold text-white text-lg drop-shadow-lg cursor-pointer" title="点击编辑名字" onclick="editMomentsName()">My Name</span>
                                    </div>
                                </div>
                            </div>

                            <!-- 背景和动态内容之间的间距 -->
                            <div class="h-4"></div>
                            
                            <!-- 角色自动发布动态提示 -->

                            
                            <!-- 动态内容区域 -->
                            <div id="moments-feed" class="px-2 pb-4 space-y-3">
                                <!-- 动态内容将由JS渲染到这里 -->
                            </div>
                            </div>
                        </div>
                    <!-- V7.1: 全新日记 (Diary) 书架容器 -->
                    <div id="wechat-diary-container" class="wechat-content-view hidden p-4">
                        <h3 class="text-xl font-bold mb-4 px-2">日记书架</h3>
                        <div id="diary-bookshelf" class="grid grid-cols-2 gap-4">
                            <!-- 日记本将由JS渲染到这里 -->
                        </div>
                    </div>
                    <div id="wechat-plan-container" class="wechat-content-view hidden">
                        <div id="plan-list-container" class="p-2 space-y-3">
                            <!-- 计划列表将由JS渲染到这里 -->
                        </div>
                    </div>

    <!-- 全新的"创建约定"模态框HTML结构 -->
    <div id="plan-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">创建新的约定</h3>
            </div>
            <div class="form-group">
                <label for="plan-content" class="form-label">
                    <i class="ri-heart-line"></i>
                    <span>约定内容</span>
                </label>
                <input type="text" id="plan-content" class="form-input" placeholder="例如：一起去看海...">
            </div>
            <div class="form-group">
                <label for="plan-partner" class="form-label">
                    <i class="ri-user-line"></i>
                    <span>和谁的约定?</span>
                </label>
                <select id="plan-partner" class="form-select">
                    <!-- 选项将由JavaScript动态填充 -->
                </select>
            </div>
            <div class="form-group">
                <label for="plan-notes" class="form-label">
                    <i class="ri-quill-pen-line"></i>
                    <span>备注 (可选)</span>
                </label>
                <textarea id="plan-notes" class="form-textarea" placeholder="可以记录一些悄悄话..."></textarea>
            </div>
            <div class="modal-footer">
                <button id="cancel-plan-btn" class="btn btn-ghost">取消</button>
                <button id="save-plan-btn" class="btn btn-primary">
                    <i class="ri-save-line"></i>
                    <span>保存约定</span>
                </button>
            </div>
        </div>
    </div>
                </div>
                 <div class="wechat-tab-bar">
                    <div class="wechat-tab-item active" data-tab="chat">
                        <i class="ri-chat-heart-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>聊天</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="moments">
                        <i class="ri-polaroid-2-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>动态</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="diary">
                        <i class="ri-quill-pen-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>日记</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="plan">
                        <i class="ri-suitcase-3-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>计划</span>
                    </div>
                </div>
            </div>

            <div id="wechat-chat-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <div id="chat-header-normal" class="flex items-center justify-between w-full">
                        <button id="wechat-chat-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 id="wechat-contact-name" class="app-header-title"></h3>
                        <button id="wechat-options-button" class="app-header-btn"><i class="fas fa-ellipsis-h"></i></button>
                    </div>
                    <div id="chat-header-multiselect" class="hidden items-center justify-between w-full text-sm">
                        <button id="cancel-multiselect-btn" class="font-semibold px-2 py-1">取消</button>
                        <span id="multiselect-count" class="font-bold">已选择 0 项</span>
                        <button id="confirm-multiselect-btn" class="font-semibold text-red-500 px-2 py-1">删除</button>
                    </div>
                </div>
                <template id="bubble-menu-template">
                    <div class="bubble-context-menu">
                        <button data-action="delete" class="bubble-menu-button"><i class="fas fa-trash"></i><span>删除</span></button>
                        <button data-action="copy" class="bubble-menu-button"><i class="fas fa-copy"></i><span>复制</span></button>
                        <button data-action="multiselect" class="bubble-menu-button"><i class="fas fa-check-square"></i><span>多选</span></button>
                        <button data-action="edit" class="bubble-menu-button"><i class="fas fa-pencil-alt"></i><span>编辑</span></button>
                        <button data-action="retry" class="bubble-menu-button"><i class="fas fa-sync-alt"></i><span>重生成</span></button>
                    </div>
                </template>


                <div id="wechat-content-chat" class="flex-1 overflow-y-auto p-4 space-y-1">
                    </div>
                
                <div id="chat-quick-actions-bar">
                    <button id="quick-voice-message-btn" class="quick-action-btn"><i class="ri-mic-line"></i></button>
                    <button id="quick-voice-call-btn" class="quick-action-btn"><i class="ri-phone-line"></i></button>
                    <button id="quick-video-call-btn" class="quick-action-btn"><i class="ri-vidicon-line"></i></button>
                </div>

                <div id="chat-footer">
                    <div id="chat-input-bar" class="chat-input-bar flex items-center p-2">
                        <button id="add-feature-btn" class="chat-input-btn"><i class="ri-add-circle-line"></i></button>
                        <button id="emoji-btn" class="chat-input-btn"><i class="ri-emotion-happy-line"></i></button>
                        <textarea id="chat-input" placeholder="输入信息..." class="chat-input flex-1 rounded-full px-4 py-2 mx-2 focus:ring-2 focus:ring-gray-500" rows="1"></textarea>
                        <button id="send-chat-button" class="chat-input-btn"><i class="far fa-paper-plane"></i></button>
                        <button id="receive-chat-button" class="chat-input-btn" title="接收AI消息">
                            <i class="ri-mail-send-line"></i>
                        </button>
                    </div>

                    <div id="more-features-panel" class="hidden">
                        <div class="features-grid">
                            <div id="send-image-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-image-line"></i></div>
                                <span>图片</span>
                            </div>
                            <div id="send-red-packet-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-red-packet-line"></i></div>
                                <span>红包</span>
                            </div>
                            <div id="send-transfer-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-exchange-dollar-line"></i></div>
                                <span>转账</span>
                            </div>
                            <div id="drawing-board-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-paint-brush-line"></i></div>
                                <span>画板</span>
                            </div>
                            <div id="tarot-card-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-magic-line"></i></div>
                                <span>塔罗牌</span>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 表情面板 (美化版) -->
                <div id="sticker-panel">
                    <!-- 刪除按鈕 -->
                    <div id="sticker-delete-btn" class="sticker-delete-btn" title="管理表情包">
                        <i class="ri-delete-bin-line"></i>
                    </div>
                    <div id="sticker-grid">
                        <div id="add-sticker-btn" class="add-sticker-btn" title="添加表情包">
                            <i class="ri-add-line"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 画板弹窗 -->
                <div id="drawing-board-modal" class="drawing-modal-overlay hidden">
                    <div class="drawing-modal-content">
                        <div class="drawing-modal-header">
                            <h3 class="drawing-modal-title">画板</h3>
                            <button id="close-drawing-board" class="drawing-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="drawing-board-container">
                            <canvas id="drawing-canvas" width="400" height="300"></canvas>
                            <div class="drawing-tools">
                                <div class="color-palette">
                                    <div class="color-swatch" data-color="#000000" style="background-color: #000000;"></div>
                                    <div class="color-swatch" data-color="#FF0000" style="background-color: #FF0000;"></div>
                                    <div class="color-swatch" data-color="#00FF00" style="background-color: #00FF00;"></div>
                                    <div class="color-swatch" data-color="#0000FF" style="background-color: #0000FF;"></div>
                                    <div class="color-swatch" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
                                    <div class="color-swatch" data-color="#FF00FF" style="background-color: #FF00FF;"></div>
                                    <div class="color-swatch" data-color="#00FFFF" style="background-color: #00FFFF;"></div>
                                    <div class="color-swatch" data-color="#FFA500" style="background-color: #FFA500;"></div>
                                    <div class="color-swatch" data-color="#800080" style="background-color: #800080;"></div>
                                    <div class="color-swatch" data-color="#008000" style="background-color: #008000;"></div>
                                    <div class="color-swatch" data-color="#FFC0CB" style="background-color: #FFC0CB;"></div>
                                    <div class="color-swatch" data-color="#A52A2A" style="background-color: #A52A2A;"></div>
                                    <div class="color-swatch" data-color="#808080" style="background-color: #808080;"></div>
                                    <div class="color-swatch" data-color="#FFD700" style="background-color: #FFD700;"></div>
                                    <div class="color-swatch" data-color="#32CD32" style="background-color: #32CD32;"></div>
                                    <div class="color-swatch" data-color="#FF69B4" style="background-color: #FF69B4;"></div>
                                </div>
                                <div class="brush-controls">
                                    <div class="brush-preview">
                                        <div id="brush-preview-circle"></div>
                                    </div>
                                    <input type="range" id="brush-size" min="1" max="20" value="5" class="brush-size-slider">
                                    <span id="brush-size-value">5px</span>
                                </div>
                                <div class="drawing-actions">
                                    <button id="undo-drawing" class="drawing-btn secondary" title="撤销上一步">
                                        <i class="fas fa-undo"></i> 撤销
                                    </button>
                                    <button id="clear-canvas" class="drawing-btn secondary">
                                        <i class="fas fa-eraser"></i> 清空
                                    </button>
                                    <button id="send-drawing" class="drawing-btn primary">
                                        <i class="fas fa-paper-plane"></i> 发送
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 塔罗牌弹窗 -->
                <div id="tarot-modal" class="tarot-modal-overlay hidden">
                    <div class="tarot-modal-content">
                        <div class="tarot-modal-header">
                            <h3 class="tarot-modal-title">🔮 塔罗牌占卜</h3>
                            <button id="close-tarot-modal" class="tarot-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="tarot-container">
                            <div class="tarot-card-display">
                                <div id="tarot-card" class="tarot-card-back">
                                    <div class="card-back-pattern"></div>
                                    <div class="card-back-text">点击抽牌</div>
                                    <div class="symbol-top-right">✦</div>
                                    <div class="symbol-bottom-left">✧</div>
                                    <div class="symbol-bottom-right">✦</div>
                                </div>
                            </div>
                            <div class="tarot-info" id="tarot-info" style="display: none;">
                                <h4 id="card-name" class="card-name"></h4>
                                <p id="card-meaning" class="card-meaning"></p>
                                <div class="card-orientation">
                                    <span id="orientation-text" class="orientation-text"></span>
                                </div>
                            </div>
                            <div class="tarot-actions">
                                <button id="draw-card-btn" class="tarot-btn primary">
                                    <i class="fas fa-magic"></i> 抽一张牌
                                </button>
                                <button id="send-tarot-btn" class="tarot-btn secondary" style="display: none;">
                                    <i class="fas fa-paper-plane"></i> 发送给TA
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="wechat-options-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wechat-options-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">聊天设置</h3>
                    <div class="w-8"></div>
                </div>
                <div class="flex-1 p-2 overflow-y-auto space-y-2">
                    <div id="pin-chat-option" class="list-item">置顶对话</div>
                    <div id="change-chat-bg-option" class="list-item">设置聊天背景</div>
                    <div class="list-item flex justify-between items-center">
                        <span>气泡颜色 (我 / 对方)</span>
                        <div class="flex items-center space-x-3">
                            <input type="color" id="user-bubble-color-picker" class="color-picker-input">
                            <input type="color" id="ai-bubble-color-picker" class="color-picker-input">
                        </div>
                    </div>
                    <div id="change-user-video-image-option" class="list-item">设置对方的视频照片</div>
                    <div id="clear-chat-history-option" class="list-item text-red-500">清空聊天记录</div>
                    <div id="delete-chat-option" class="list-item text-red-500 mt-4">删除此对话</div>
                </div>
            </div>


            <div id="world-book-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wb-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">世界书</h3>
                    <button id="wb-add-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                </div>
                <div id="world-book-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
            </div>

            <div id="world-book-edit-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wb-edit-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">编辑世界书</h3>
                    <button id="wb-save-button" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                <div class="p-2 space-y-4">
                    <input type="text" id="wb-title-input" placeholder="标题" class="form-input">
                    <select id="wb-category-select" class="form-select mt-4">
                        <option value="worldview">角色世界观</option>
                        <option value="rules">输入规范 (AI行为准则)</option>
                        <option value="modules">模块/小剧场风格参考</option>
                        <option value="shared_assets">通用素材库 (表情包/模块)</option>
                        <option value="other">其他资料</option>
                    </select>
                    <textarea id="wb-content-input" placeholder="内容..." class="form-textarea h-64 resize-none"></textarea>
                    <div class="pt-4">
                        <button id="wb-delete-button" class="w-full px-4 py-3 bg-red-600 hover:bg-red-700 text-white rounded-md font-medium transition-colors duration-200">
                            <i class="fas fa-trash mr-2"></i>删除世界书
                        </button>
                    </div>
                </div>
            </div>

            <div id="character-book-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="cb-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">角色书</h3>
                    <button id="cb-add-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                </div>
                <div id="character-book-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
            </div>

            <div id="character-book-edit-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="cb-edit-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">编辑角色</h3>
                    <button id="cb-save-button" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                <div class="flex-1 overflow-y-auto p-2 space-y-4">
                    <div class="flex items-center space-x-4 p-2">
                        <div id="character-avatar-placeholder" class="w-20 h-20 rounded-full flex-shrink-0 image-placeholder bg-cover bg-center">
                            <i class="fas fa-camera text-2xl"></i>
                        </div>
                        <input type="file" id="character-avatar-input" accept="image/*">
                        <div class="flex-grow">
                             <label class="block text-sm font-medium mb-1">角色姓名</label>
                             <input type="text" id="cb-name-input" class="form-input">
                        </div>
                    </div>
                     <div class="p-2">
                        <label class="block text-sm font-medium mb-1">角色设定 (性格、记忆、说话风格等)</label>
                        <textarea id="cb-persona-input" class="form-textarea h-24 resize-none"></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-1">我的设定 (我与角色的关系)</label>
                        <textarea id="cb-my-persona-input" class="form-textarea h-16 resize-none"></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-1">关联世界书 (可多选)</label>
                        <div id="cb-worldbook-select" class="space-y-1 max-h-24 overflow-y-auto p-2 rounded-lg border">
                            </div>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-2">角色专属素材库 (AI会优先使用这里的内容)</label>
                        <div id="cb-expressions-container" class="space-y-2 max-h-48 overflow-y-auto p-2 border border-gray-600 rounded-lg">
                            </div>
                        <div class="flex gap-2 mt-2">
                            <input type="text" id="expression-keyword-input" placeholder="关键词 (如: 开心)" class="form-input flex-1">
                            <textarea id="expression-content-input" placeholder="素材内容 (图片链接 或 HTML代码)" class="form-textarea flex-1 h-12 resize-none"></textarea>
                            <button id="add-expression-btn" class="px-3 bg-gray-600 text-white rounded-md text-sm">添加</button>
                        </div>
                    </div>
                    <div class="p-2">
                        <button id="cb-delete-button" class="w-full mt-4 px-4 py-2 bg-red-600 text-white rounded-md hidden">删除角色</button>
                    </div>
                </div>
            </div>
            
            <div id="main-settings-screen" class="app-screen-view main-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="main-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto">
                    <div class="space-y-2">
                        <div id="api-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-key w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">API 设定</h4>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-2 mt-8">
                        <div id="beautify-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-palette w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">美化设置</h4>
                            </div>
                        </div>
                         <div id="font-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-font w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">字体设置</h4>
                            </div>
                        </div>
                    </div>
                     <div class="space-y-2 mt-8">
                        <div id="export-data-btn" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-download w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">一键导出所有资料</h4>
                            </div>
                        </div>
                         <div id="import-data-btn" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-upload w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">一键上传所有资料</h4>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="beautify-settings-screen" class="app-screen-view beautify-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="beautify-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">美化设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-2">
                    <div id="change-wallpaper-link" class="list-item flex justify-between items-center">
                        <h4 class="font-semibold">更换手机壁纸</h4>
                    </div>
                    <input type="file" id="wallpaper-input" accept="image/*">
                    <div id="change-app-icons-link" class="list-item flex justify-between items-center">
                        <h4 class="font-semibold">更换App图标</h4>
                    </div>
                </div>
            </div>

             <div id="app-icon-settings-screen" class="app-screen-view app-icon-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="app-icon-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">更换App图标</h3>
                </div>
                <div id="app-icon-list" class="settings-content flex-1 p-2 overflow-y-auto space-y-2">
                    </div>
            </div>

            <div id="font-settings-screen" class="app-screen-view font-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="font-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">字体设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-4">
                    <div class="p-4 rounded-lg bg-card">
                        <label class="block text-sm font-medium mb-2">文字大小</label>
                        <div id="font-size-selector" class="flex justify-between rounded-lg p-1 text-sm">
                            <button data-size="small" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">小</button>
                            <button data-size="medium" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">中</button>
                            <button data-size="large" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">大</button>
                        </div>
                    </div>
                    <div class="p-4 rounded-lg bg-card">
                        <label for="font-url-input" class="block text-sm font-medium mb-2">字体文件URL (支持.ttf, .otf, .woff等)</label>
                        <input type="text" id="font-url-input" class="form-input w-full" placeholder="https://example.com/font.ttf">
                        <button id="font-save-button" class="w-full mt-4 px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-md">应用字体</button>
                        </div>
                </div>
            </div>

            <div id="api-settings-screen" class="app-screen-view api-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="api-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">API 设定</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-6">
                     <div class="p-4 rounded-lg bg-card">
                        <h3 class="font-bold mb-4">连接设定</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="api_url" class="block text-sm font-medium mb-1">API 地址:</label>
                                <input type="text" id="api_url" placeholder="例如: https://api.example.com/v1" class="api-input form-input">
                            </div>
                            <div>
                                <label for="api_key" class="block text-sm font-medium mb-1">API 密钥:</label>
                                <input type="password" id="api_key" placeholder="在此输入您的API金钥" class="api-input form-input">
                            </div>
                        </div>
                    </div>

                    <div class="p-4 rounded-lg bg-card">
                        <h3 class="font-bold mb-4">模型选择</h3>
                        <div class="space-y-4">
                             <div>
                                <label for="model_select" class="block text-sm font-medium mb-1">选取 API 模型:</label>
                                <div class="flex items-center gap-2">
                                    <select id="model_select" class="api-input form-select flex-grow">
                                        <!-- Models will be populated by JS -->
                                    </select>
                                    <button id="fetch_models_btn" class="px-3 py-2 bg-gray-600 text-white rounded-md text-sm flex-shrink-0">获取模型</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <button id="save_settings_btn" class="w-full flex justify-center items-center mt-2 px-4 py-3 border border-transparent text-base font-medium rounded-md text-white bg-gray-700 hover:bg-gray-600">保存设定</button>
                    <div id="api-status" class="mt-4 p-4 rounded-lg text-center font-semibold text-sm hidden"></div>
                    <div id="security-warning" class="bg-yellow-100 text-yellow-700 mt-4 p-4 rounded-lg hidden" role="alert">
                        <p class="font-bold">安全提醒</p>
                        <p>API 金钥储存在浏览器本地储存中，这在公共电脑上可能不安全。请谨慎使用。</p>
                    </div>
                </div>
            </div>

            <div id="voice-call-screen" class="call-screen">
                <div class="call-background" id="voice-call-bg"></div>
                <div class="call-content">
                    <div class="flex flex-col items-center flex-shrink-0">
                        <img id="voice-call-avatar" src="https://placehold.co/300x300/777/FFF?text=?" alt="avatar">
                        <h3 id="voice-call-name" class="text-2xl font-bold mt-4">Character Name</h3>
                        <p id="voice-call-timer" class="text-gray-300">00:00</p>
                    </div>
                    <div class="mt-auto w-full">
                        <div class="call-status-box" id="voice-call-status-box"></div>
                        <div class="call-input-area">
                            <textarea id="voice-call-input" placeholder="输入互动文字..." rows="1"></textarea>
                            <button id="voice-call-retry-btn" title="重新生成"><i class="ri-refresh-line"></i></button>
                            <button id="voice-call-send-btn"><i class="ri-send-plane-2-fill"></i></button>
                        </div>
                        <div class="call-controls">
                            <button id="voice-call-hangup" class="call-control-btn hangup-btn"><i class="fas fa-phone-slash"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="video-call-screen" class="call-screen">
                <div class="call-background" id="video-call-bg"></div>
                <div class="call-content">
                    <div id="user-video-preview">
                        <img id="user-video-image" src="https://placehold.co/180x240/333/FFF?text=Me" alt="user video">
                    </div>
                    <div class="mt-auto w-full">
                        <div class="call-status-box" id="video-call-status-box"></div>
                         <div class="call-input-area">
                            <textarea id="video-call-input" placeholder="输入互动文字..." rows="1"></textarea>
                            <button id="video-call-retry-btn" title="重新生成"><i class="ri-refresh-line"></i></button>
                            <button id="video-call-send-btn"><i class="ri-send-plane-2-fill"></i></button>
                        </div>
                        <div class="call-controls">
                            <button id="video-call-hangup" class="call-control-btn hangup-btn"><i class="fas fa-phone-slash"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 红包/转账 Modal -->
            <div id="red-packet-modal" class="payment-modal-overlay">
                <div class="payment-modal-content">
                    <div class="payment-header">
                        <button class="close-btn" data-target="red-packet-modal"><i class="ri-close-line"></i></button>
                        <span class="title">发红包</span>
                        <div class="w-8"></div>
                    </div>
                    <div class="payment-content">
                        <div class="amount-input-wrapper">
                            <span class="currency-symbol">¥</span>
                            <input type="number" class="amount-input" id="red-packet-amount" placeholder="0.00" min="0.01">
                        </div>
                        <input type="text" class="message-input" id="red-packet-message" placeholder="恭喜发财，大吉大利">
                        <button class="send-payment-btn" id="send-red-packet-confirm-btn">塞钱进红包</button>
                    </div>
                </div>
            </div>

            <div id="transfer-modal" class="payment-modal-overlay">
                 <div class="payment-modal-content">
                    <div class="payment-header">
                        <button class="close-btn" data-target="transfer-modal"><i class="ri-close-line"></i></button>
                        <span class="title">转账</span>
                        <div class="w-8"></div>
                    </div>
                    <div class="payment-content">
                        <div class="amount-input-wrapper">
                            <span class="currency-symbol">¥</span>
                            <input type="number" class="amount-input" id="transfer-amount" placeholder="0.00" min="0.01">
                        </div>
                        <input type="text" class="message-input" id="transfer-message" placeholder="转账说明">
                        <button class="send-payment-btn" id="send-transfer-confirm-btn">转账</button>
                    </div>
                </div>
            </div>

        </div>
        
        <!-- FIX 4: ADDED NOTIFICATION ELEMENT (移动到这里) -->
        <div id="new-message-alert" class="hidden flex items-center absolute top-14 left-2 right-2 z-[9400] bg-gray-800/80 backdrop-blur-lg rounded-2xl p-3 shadow-xl cursor-pointer transition-transform duration-300 -translate-y-[200%]">
            <img id="new-message-avatar" src="https://placehold.co/96x96/777/FFF?text=?" class="w-12 h-12 rounded-full object-cover mr-3">
            <div class="flex-grow overflow-hidden">
                <p id="new-message-name" class="font-bold text-white">Character Name</p>
                <p id="new-message-preview" class="text-sm text-gray-200 truncate">New message content...</p>
            </div>
        </div>
    </div>

    <!-- V7.1: 发布新动态 Modal - 用户专用 -->
    <div id="post-moment-modal" class="modal-overlay">
        <div class="modal-content w-[90%] max-w-[320px]">
            <h3 class="text-xl font-bold text-white mb-4">发布我的动态</h3>
            <select id="moment-author-select" class="form-select mb-3 hidden"></select>
            <textarea id="moment-content-input" class="form-textarea h-24 resize-none mb-3" placeholder="分享新鲜事..."></textarea>
            <button id="moment-image-upload-btn" class="w-full py-2 bg-gray-700/50 hover:bg-gray-700 rounded-lg mb-4">
                <i class="ri-image-add-line mr-2"></i><span id="moment-image-label">添加图片 (可选)</span>
            </button>
            <input type="file" id="moment-image-input" class="hidden" accept="image/*">
            <div class="flex justify-end gap-2">
                <button id="cancel-post-moment-btn" class="px-4 py-2 rounded-lg">取消</button>
                <button id="confirm-post-moment-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">发布</button>
            </div>
        </div>
    </div>

    <!-- V7.1: 日记本单页 Modal -->
    <div id="diary-book-modal" class="fixed inset-0 z-[15000] flex items-center justify-center bg-black/60 backdrop-blur-sm hidden">
        <div class="diary-single-page-container relative">
            <div id="diary-book" class="diary-single-page">
                <div id="diary-book-cover" class="diary-cover">
                    <button 
                        id="change-diary-banner-btn" 
                        class="diary-cover-edit-btn" 
                        style="top: 0.8rem; left: 0.8rem; right: auto;" 
                        title="更换顶部横幅图片">
                        <i class="ri-image-edit-line"></i>
                    </button>
                    <h2 id="diary-cover-title" onclick="editDiaryCoverTitle(event)" style="cursor: pointer;"></h2>
                    <p id="diary-cover-author" onclick="editDiaryCoverAuthor(event)" style="cursor: pointer;"></p>
                </div>
                <div id="diary-pages-container" class="diary-pages">
                    <!-- 页面内容将动态生成 -->
                </div>
            </div>
            <button id="close-diary-book-btn" class="absolute top-4 right-4 text-white text-2xl z-10 w-6 h-6 flex items-center justify-center"><i class="ri-close-circle-line"></i></button>
            <button id="prev-page-btn" class="absolute left-2 top-1/2 -translate-y-1/2 text-white text-3xl z-10"><i class="ri-arrow-left-s-line"></i></button>
            <button id="next-page-btn" class="absolute right-2 top-1/2 -translate-y-1/2 text-white text-3xl z-10"><i class="ri-arrow-right-s-line"></i></button>
            <button id="add-page-btn" class="absolute bottom-4 right-4 text-white text-xl z-10 bg-blue-600 rounded-full w-6 h-6 flex items-center justify-center hover:bg-blue-700 transition-colors" title="添加新日记"><i class="ri-add-line"></i></button>
        </div>
    </div>

    <!-- 图片裁剪模态框 -->
    <div id="image-cropper-modal" class="fixed inset-0 z-[16000] flex items-center justify-center bg-black/80 backdrop-blur-sm hidden">
        <div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-800">裁剪横幅图片</h3>
                <button id="close-cropper-btn" class="text-gray-500 hover:text-gray-700 text-xl">
                    <i class="ri-close-line"></i>
                </button>
            </div>
            
            <div class="mb-4 text-sm text-gray-600">
                <p>请选择要保留的图片区域，系统将自动调整为横幅尺寸 (1000×300)</p>
            </div>
            
            <div class="relative mb-4">
                <div id="cropper-container" class="relative overflow-hidden bg-gray-100 rounded-lg">
                    <img id="cropper-image" class="max-w-full h-auto" alt="裁剪图片">
                </div>
            </div>
            
            <div class="flex justify-between items-center">
                <div class="text-sm text-gray-500">
                    <span id="crop-info">拖拽图片或调整选择框</span>
                </div>
                <div class="flex gap-2">
                    <button id="reset-crop-btn" class="px-4 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50">
                        重置
                    </button>
                    <button id="confirm-crop-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                        确认裁剪
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局變數
        let songList = [];
        let worldBooks = [];
        let characters = [];
        let chatHistories = {};
        let userStickers = []; 
        let userAvatars = {};
        let chatBackgrounds = {};
        let chatBubbleColors = {};
        let userVideoImages = {};
        let myVideoImages = {};
        let currentChatCharacterId = null;
        let currentWeChatCharacterId = null; // V7.0: Track character for non-chat tabs
        let currentMessageIndex = 0; // 用于虚拟滚动的消息索引
        let isReceivingMessage = false; // 用于防止重复点击接收按钮

        // [新增] 未读消息计数器
        let unreadCounts = loadData('unreadCounts') || {};

        // V7.0: 新增数据结构
        let momentsData = {};
        let diaryData = {};
        let notebookData = {}; // 新增：笔记本数据
        let planData = {};
        let characterState = {};

        // 新增：通知状态管理
        let notificationStatus = { chat: false, moments: false, diary: false, plan: false };

        const currentAudio = new Audio();
        let currentSongIndex = -1;
        let isLooping = false;
        
        // 全屏切换功能
document.getElementById('fullscreen-toggle').addEventListener('click', function() {
    const body = document.body;
    const phoneFrame = document.querySelector('.phone-frame');
    
    if (body.classList.contains('fullscreen-mode')) {
        // 退出全屏
        body.classList.remove('fullscreen-mode');
        this.innerHTML = '<i class="fas fa-expand"></i>';
    } else {
        // 进入全屏
        body.classList.add('fullscreen-mode');
        this.innerHTML = '<i class="fas fa-compress"></i>';
    }
});

        let isSingleLooping = false;
        let currentEditingWorldBookId = null;
        let currentEditingCharacterId = null;
        
        let isMultiSelectMode = false;
        let selectedMessages = new Set();
        let activeMenu = null;

        let currentCallType = null;
        let callTimerInterval = null;
        let callStartTime = null;
        let callHistory = []; // NEW: To store the conversation during a call
        let callLogs = {}; // 新增：用于存储通话记录
        let typewriterTimeout = null;

// [新增] 这个函数会创建或获取一个专门用于显示背景的图层
function getChatBackgroundElement() {
    const chatScreen = $('#wechat-chat-screen');
    
    let bgElement = $('#chat-background-layer'); // 尝试寻找这个图层

    if (!bgElement) {
        // 如果图层不存在，就创建它
        bgElement = document.createElement('div');
        bgElement.id = 'chat-background-layer';
        bgElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* 确保它在最底层 */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none; /* 让它不影响点击 */
        `;
        // 将它作为第一个子元素插入，确保它在最底层
        chatScreen.prepend(bgElement);
    }
    return bgElement;
} // 新增：用于追踪打字机动画


        // DOM 元素獲取
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        const body = document.body;
        const messageBox = $('#messageBox');
        const currentTimeEl = $('#currentTime');
        const phoneScreen = $('#phone-screen');
        const homeWallpaper = $('#home-wallpaper');
        const statusBar = $('#status-bar');


        // 頁面切換
        const allScreens = $$('.app-screen-view');
        function showScreen(screenId) {
            allScreens.forEach(screen => {
                screen.classList.toggle('hidden', screen.id !== screenId);
                const isFlex = !['home-screen'].includes(screen.id);
                screen.classList.toggle('flex', screen.id === screenId && isFlex);
                if (!isFlex) screen.classList.remove('flex');
            });
            homeWallpaper.classList.toggle('hidden', screenId !== 'home-screen');
            statusBar.classList.toggle('on-home', screenId === 'home-screen');
            
            if (screenId === 'wechat-chat-screen') {
                // 重新加载 chatBackgrounds 数据，确保获取最新数据
                chatBackgrounds = loadData('chatBackgrounds', {});
                
                // 检查 currentChatCharacterId 是否已设置
                if (!currentChatCharacterId) {
                    // 等待一下，让 startChatWithCharacter 完成设置
                    setTimeout(() => {
                        if (currentChatCharacterId) {
                            // 重新调用背景设置逻辑
                            const chatScreen = $('#wechat-chat-screen');
                            const bgElement = getChatBackgroundElement();
                            // 再次重新加载数据
                            chatBackgrounds = loadData('chatBackgrounds', {});
                            const savedBg = chatBackgrounds[currentChatCharacterId];
                            
                            if (savedBg) {
                                getImageFromDB(savedBg).then(blob => {
                                    if (blob) {
                                        const objectURL = URL.createObjectURL(blob);
                                        bgElement.style.backgroundImage = `url(${objectURL})`;
                                        chatScreen.style.backgroundColor = 'transparent';
                                        chatScreen.classList.add('has-custom-bg');
                                        statusBar.classList.add('transparent-override');
                                    }
                                }).catch(error => {
                                    console.error('获取背景图失败:', error);
                                });
                            }
                        }
                    }, 100);
                    return; // 先退出，等待延迟执行
                }
                
                const chatScreen = $('#wechat-chat-screen');
                const bgElement = getChatBackgroundElement(); // 确保背景层存在

                // 定义一个重置背景的函数
                const resetBackground = () => {
                    bgElement.style.backgroundImage = ''; // 清除背景层的图片
                    chatScreen.style.backgroundColor = ''; // 让聊天屏幕恢复主题默认颜色
                    chatScreen.classList.remove('has-custom-bg');
                    statusBar.classList.remove('transparent-override');
                };

                const savedBg = chatBackgrounds[currentChatCharacterId];
                if (savedBg) {
                    getImageFromDB(savedBg).then(blob => {
                        if (blob) {
                            // 成功获取图片，设置背景
                            const objectURL = URL.createObjectURL(blob);

                            // --- 核心改动在这里 ---
                            bgElement.style.backgroundImage = `url(${objectURL})`; // 设置背景层的图片
                            chatScreen.style.backgroundColor = 'transparent'; // 确保聊天屏幕是透明的

                            chatScreen.classList.add('has-custom-bg');
                            statusBar.classList.add('transparent-override');
                        } else {
                            // 找不到图片数据，重置背景
                            resetBackground();
                        }
                    }).catch(error => {
                        // 获取图片出错，也重置背景
                        console.error('从数据库获取背景图失败:', error);
                        resetBackground();
                    });
                } else {
                    // 没有任何背景记录，重置背景
                    resetBackground();
                }
            } else {
                statusBar.classList.remove('transparent-override');
            }
        }

        // 數據保存與加載
        function saveData(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.error("保存数据失败:", e);
                showMessageBox('存储空间已满，无法保存。');
            }
        }

        function loadData(key, defaultValue = null) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : defaultValue;
            } catch (e) {
                console.error("加载数据失败:", e);
                return defaultValue;
            }
        }

        async function loadAllSavedData() {
            // This function reloads all data from localStorage and updates the UI.
            // It's called on initial load and after a data import.
            
            // Clear existing data to prevent merging issues
            songList = [];
            worldBooks = [];
            characters = [];
            chatHistories = {};
            userStickers = [];
            
            const savedTheme = loadData('theme', 'dark');
            body.className = `flex items-center justify-center min-h-screen ${savedTheme}-mode`;
            $('#theme-icon').className = `fas fa-${savedTheme === 'dark' ? 'moon' : 'sun'} text-lg`;
            
            // 初始化主题相关的UI元素
            if (savedTheme === 'dark') {
                updateChatBubbleColors();
                updateMomentsCommentColors();
            }

            const savedWallpaper = loadData('saved_wallpaper');
            if(savedWallpaper) {
                getImageFromDB(savedWallpaper).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        homeWallpaper.style.backgroundImage = `url(${objectURL})`;
                        // 确保背景图片正确显示
                        homeWallpaper.style.backgroundSize = 'cover';
                        homeWallpaper.style.backgroundPosition = 'center';
                        homeWallpaper.style.backgroundRepeat = 'no-repeat';
                    }
                });
            }

            const savedBg = loadData('saved_music_background');
            if (savedBg) {
                getImageFromDB(savedBg).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        const musicBlock = $('#music-block');
                        musicBlock.style.backgroundImage = `url(${objectURL})`;
                        musicBlock.style.backgroundSize = 'cover';
                        musicBlock.style.backgroundPosition = 'center';
                    }
                });
            }
            
            const savedVinyl = loadData('saved_vinyl_cover');
            if (savedVinyl) {
                getImageFromDB(savedVinyl).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        const vinylRecord = $('#vinyl-record');
                        vinylRecord.style.backgroundImage = `url(${objectURL})`;
                        vinylRecord.style.backgroundSize = 'cover';
                        vinylRecord.style.backgroundPosition = 'center';
                    }
                });
            }

            const savedPhoto = loadData('saved_photo_widget');
            if (savedPhoto) {
                getImageFromDB(savedPhoto).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#photo-widget').style.backgroundImage = `url(${objectURL})`;
                        $('#photo-widget-text').style.opacity = 0;
                    }
                });
            }

            const savedWidgetImg = loadData('saved_widget_image');
            if (savedWidgetImg) {
                getImageFromDB(savedWidgetImg).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        const placeholder = $('#widget-image-placeholder');
                        placeholder.style.backgroundImage = `url(${objectURL})`;
                        const icon = placeholder.querySelector('i');
                        if (icon) icon.style.display = 'none';
                    }
                });
            }
            
            // Load all App Icons
            const appIconNames = Array.from($$('.app-icon')).map(el => el.dataset.appName);
            appIconNames.forEach(appName => {
                const savedIcon = loadData(`saved_icon_${appName}`);
                const iconEl = $(`.app-icon[data-app-name="${appName}"]`);
                if (savedIcon && iconEl) {
                    // 异步加载应用图标
                    getImageFromDB(savedIcon).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            iconEl.style.backgroundImage = `url(${objectURL})`;
                            const i = iconEl.querySelector('i');
                            if(i) i.style.display = 'none';
                            iconEl.style.backgroundSize = 'cover';
                            iconEl.style.backgroundRepeat = 'no-repeat';
                        }
                    });
                }
            });

            $('#mood-text').value = loadData('saved_mood_text', '');
            $('#widget-name-input').value = loadData('saved_widget_name', '');
            $('#widget-thinking-input').value = loadData('saved_widget_thinking', '');
            $('#widget-location-input').value = loadData('saved_widget_location', '');

            worldBooks = loadData('worldBooks', []);
            
            // 为旧的世界书数据添加默认分类，确保兼容性
            worldBooks.forEach(book => {
                if (typeof book.category === 'undefined') {
                    book.category = 'worldview'; // 默认所有旧条目为"世界观"
                }
            });
            characters = loadData('characters', []);
            userStickers = loadData('userStickers', []); 
            
            chatHistories = loadData('chatHistories', {});
            Object.keys(chatHistories).forEach(key => {
                if(Array.isArray(chatHistories[key])) {
                    chatHistories[key] = { history: chatHistories[key], pinned: false };
                }
            });
            userAvatars = loadData('userAvatars', {});
            chatBackgrounds = loadData('chatBackgrounds', {});
            chatBubbleColors = loadData('chatBubbleColors', {});
            userVideoImages = loadData('userVideoImages', {});
            myVideoImages = loadData('myVideoImages', {});
            
            // IndexedDB 数据库初始化
            await initDB();
        }
        
        // IndexedDB 数据库操作函数
        let db;
        
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('WebAppCacheDB', 1);
        
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains('images')) {
                        dbInstance.createObjectStore('images', { keyPath: 'id' });
                    }
                };
        
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('数据库初始化成功');
                    resolve(db);
                };
        
                request.onerror = (event) => {
                    console.error('数据库初始化失败:', event.target.error);
                    reject(event.target.error);
                };
            });
        }
        
        async function saveImageToDB(id, blobData) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['images'], 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.put({ id: id, data: blobData });
        
                request.onsuccess = () => resolve(id);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        async function getImageFromDB(id) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                if (!id) return resolve(null);
                const transaction = db.transaction(['images'], 'readonly');
                const store = transaction.objectStore('images');
                const request = store.get(id);
        
                request.onsuccess = (event) => {
                    resolve(event.target.result ? event.target.result.data : null);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        async function deleteImageFromDB(id) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                if (!id) return resolve();
                const transaction = db.transaction(['images'], 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        // V7.0: Load new data
        async function loadAllData() {
            momentsData = loadData('momentsData', {});
            diaryData = loadData('diaryData', {});
            notebookData = loadData('notebookData', {}); // 加载笔记本数据
            planData = loadData('planData', {});
            callLogs = loadData('callLogs', {}); // 新增：加载通话记录
            characterState = loadData('characterState', {});
            
            // 调试：输出加载的计划数据
            console.log("[数据加载] 已加载planData:", planData);


            // --- 新的歌曲加载逻辑 START ---
            const savedSongList = loadData('songList', []);
            songList = []; // Reset the global song list

            // Asynchronously load each song from IndexedDB
            Promise.all(savedSongList.map(async (songInfo) => {
                try {
                    const songBlob = await getImageFromDB(songInfo.id);
                    if (songBlob) {
                        songList.push({
                            id: songInfo.id,
                            name: songInfo.name,
                            url: URL.createObjectURL(songBlob)
                        });
                    }
                } catch (error) {
                    console.error("加载歌曲失败:", songInfo.name, error);
                }
            })).then(() => {
                // After all songs are loaded (or failed), update the UI
                updateSongListUI();
            });
            // --- 新的歌曲加载逻辑 END ---
            
            const savedFontUrl = loadData('saved_font_url');
            if(savedFontUrl) {
                $('#font-url-input').value = savedFontUrl;
                applyFont(savedFontUrl);
            }

            const savedFontSize = loadData('fontSize', 'medium');
            setFontSize(savedFontSize);

            const savedApiSettings = loadData('api_settings');
            if (savedApiSettings && savedApiSettings.url && savedApiSettings.key) {
                $('#api_url').value = savedApiSettings.url;
                $('#api_key').value = savedApiSettings.key;
                
                const modelSelect = $('#model_select');
                if (savedApiSettings.model && !Array.from(modelSelect.options).some(opt => opt.value === savedApiSettings.model)) {
                    const option = document.createElement('option');
                    option.value = savedApiSettings.model;
                    option.textContent = savedApiSettings.model.startsWith('models/') ? savedApiSettings.model.substring(7) : savedApiSettings.model;
                    modelSelect.appendChild(option);
                }
                modelSelect.value = savedApiSettings.model;
                
                const isValid = await fetchModels(true);
                updateApiStatusUI(isValid);
            } else {
                updateApiStatusUI(false);
            }

            // 【新增】加载通知状态
            notificationStatus = loadData('notificationStatus', { chat: false, moments: false, diary: false, plan: false });
            updateAllNotificationDots();
        }

        // 通用功能
        function showMessageBox(message) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => messageBox.classList.remove('show'), 2000);
        }

        // 【新增】更新所有通知红点的辅助函数
        function updateAllNotificationDots() {
            Object.keys(notificationStatus).forEach(tabName => {
                const dot = document.querySelector(`.wechat-tab-item[data-tab='${tabName}'] .notification-dot`);
                if (dot) {
                    dot.classList.toggle('hidden', !notificationStatus[tabName]);
                }
            });
        }

        // 【新增】显示红点的通用函数
        function showNotificationDot(tabName) {
            const tabBar = document.querySelector('.wechat-tab-bar');
            if (!tabBar) return;

            // 检查当前是否已经在该标签页，如果是，则不显示红点
            const activeTab = tabBar.querySelector('.wechat-tab-item.active');
            if (activeTab && activeTab.dataset.tab === tabName) {
                return; // 用户已在查看，无需提示
            }

            notificationStatus[tabName] = true;
            saveData('notificationStatus', notificationStatus);
            updateAllNotificationDots();
        }

        // 图片裁剪功能
        let cropperInstance = null;
        let currentCropCallback = null;

        function showImageCropper(file, callback) {
            currentCropCallback = callback;
            
            // 显示模态框
            $('#image-cropper-modal').classList.remove('hidden');
            
            // 读取图片文件
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = document.getElementById('cropper-image');
                img.src = e.target.result;
                
                // 等待图片加载完成后初始化裁剪器
                img.onload = function() {
                    initCropper(img);
                };
            };
            reader.readAsDataURL(file);
        }

        function initCropper(img) {
            // 销毁之前的裁剪器实例
            if (cropperInstance) {
                cropperInstance.destroy();
            }

            const container = document.getElementById('cropper-container');
            const aspectRatio = 1000 / 500; // 横幅宽高比 2:1
            
            // 创建裁剪选择框
            const cropBox = document.createElement('div');
            cropBox.id = 'crop-box';
            cropBox.style.cssText = `
                position: absolute;
                border: 2px solid #007bff;
                background: rgba(0, 123, 255, 0.1);
                cursor: move;
                z-index: 10;
            `;
            
            // 计算初始裁剪框大小
            const containerRect = container.getBoundingClientRect();
            const imgRect = img.getBoundingClientRect();
            
            let cropWidth, cropHeight;
            if (imgRect.width / imgRect.height > aspectRatio) {
                // 图片更宽，以高度为准
                cropHeight = Math.min(imgRect.height, containerRect.height * 0.8);
                cropWidth = cropHeight * aspectRatio;
            } else {
                // 图片更高，以宽度为准
                cropWidth = Math.min(imgRect.width, containerRect.width * 0.8);
                cropHeight = cropWidth / aspectRatio;
            }
            
            cropBox.style.width = cropWidth + 'px';
            cropBox.style.height = cropHeight + 'px';
            cropBox.style.left = (imgRect.left - containerRect.left + (imgRect.width - cropWidth) / 2) + 'px';
            cropBox.style.top = (imgRect.top - containerRect.top + (imgRect.height - cropHeight) / 2) + 'px';
            
            container.appendChild(cropBox);
            
            // 添加拖拽功能
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            // 鼠标拖拽事件
            cropBox.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(cropBox.style.left);
                startTop = parseInt(cropBox.style.top);
                cropBox.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            // 触摸拖拽事件
            cropBox.addEventListener('touchstart', function(e) {
                isDragging = true;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                startLeft = parseInt(cropBox.style.left);
                startTop = parseInt(cropBox.style.top);
                cropBox.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            // 鼠标移动拖拽
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                handleDrag(deltaX, deltaY);
            });
            
            // 触摸移动拖拽
            document.addEventListener('touchmove', function(e) {
                if (isResizing || isDragging) {
                    e.preventDefault(); // 防止页面滚动
                    if (isResizing) {
                        const deltaX = e.touches[0].clientX - startResizeX;
                        const deltaY = e.touches[0].clientY - startResizeY;
                        handleResize(deltaX, deltaY);
                    } else if (isDragging) {
                        const deltaX = e.touches[0].clientX - startX;
                        const deltaY = e.touches[0].clientY - startY;
                        handleDrag(deltaX, deltaY);
                    }
                }
            });
            
            // 鼠标和触摸拖拽结束
            document.addEventListener('mouseup', function() {
                isDragging = false;
                cropBox.style.cursor = 'move';
            });
            
            document.addEventListener('touchend', function() {
                isDragging = false;
                cropBox.style.cursor = 'move';
            });
            
            // 统一的拖拽处理函数
            function handleDrag(deltaX, deltaY) {
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                            // 限制裁剪框不超出图片边界
            const maxLeft = imgRect.left - containerRect.left + imgRect.width - cropWidth;
            const maxTop = imgRect.top - containerRect.top + imgRect.height - cropHeight;
            const minLeft = imgRect.left - containerRect.left;
            const minTop = imgRect.top - containerRect.top;
            
            newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
            newTop = Math.max(minTop, Math.min(newTop, maxTop));
                
                cropBox.style.left = newLeft + 'px';
                cropBox.style.top = newTop + 'px';
            }
            
            // 添加调整大小功能 - 支持等比缩放
            // 右下角手柄
            const resizeHandleSE = document.createElement('div');
            resizeHandleSE.style.cssText = `
                position: absolute;
                right: -5px;
                bottom: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: se-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleSE);
            
            // 右上角手柄
            const resizeHandleNE = document.createElement('div');
            resizeHandleNE.style.cssText = `
                position: absolute;
                right: -5px;
                top: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: ne-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleNE);
            
            // 左下角手柄
            const resizeHandleSW = document.createElement('div');
            resizeHandleSW.style.cssText = `
                position: absolute;
                left: -5px;
                bottom: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: sw-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleSW);
            
            // 左上角手柄
            const resizeHandleNW = document.createElement('div');
            resizeHandleNW.style.cssText = `
                position: absolute;
                left: -5px;
                top: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: nw-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleNW);
            
            let isResizing = false;
            let startResizeX, startResizeY, startResizeWidth, startResizeHeight, startResizeLeft, startResizeTop;
            let resizeDirection = '';
            
            // 右下角手柄事件
            resizeHandleSE.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'se';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 右下角
            resizeHandleSE.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'se';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 右上角手柄事件
            resizeHandleNE.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'ne';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 右上角
            resizeHandleNE.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'ne';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 左下角手柄事件
            resizeHandleSW.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'sw';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 左下角
            resizeHandleSW.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'sw';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 左上角手柄事件
            resizeHandleNW.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'nw';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 左上角
            resizeHandleNW.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'nw';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 鼠标移动事件
            document.addEventListener('mousemove', function(e) {
                if (isResizing) {
                const deltaX = e.clientX - startResizeX;
                const deltaY = e.clientY - startResizeY;
                    handleResize(deltaX, deltaY);
                }
            });
            
            // 触摸移动事件
            document.addEventListener('touchmove', function(e) {
                if (isResizing) {
                    e.preventDefault(); // 防止页面滚动
                    const deltaX = e.touches[0].clientX - startResizeX;
                    const deltaY = e.touches[0].clientY - startResizeY;
                    handleResize(deltaX, deltaY);
                }
            });
            

            
            // 鼠标和触摸结束事件
            document.addEventListener('mouseup', function() {
                isResizing = false;
                resizeDirection = '';
            });
            
            document.addEventListener('touchend', function() {
                isResizing = false;
                resizeDirection = '';
            });
            
            // 统一的调整大小处理函数
            function handleResize(deltaX, deltaY) {
                let newWidth, newHeight, newLeft, newTop;
                
                // 根据拖拽方向计算新的尺寸和位置
                switch (resizeDirection) {
                    case 'se': // 右下角 - 只改变宽度和高度
                        newWidth = startResizeWidth + deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft;
                        newTop = startResizeTop;
                        break;
                        
                    case 'ne': // 右上角 - 改变宽度、高度和顶部位置
                        newWidth = startResizeWidth + deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft;
                        newTop = startResizeTop - (newHeight - startResizeHeight);
                        break;
                        
                    case 'sw': // 左下角 - 改变宽度、高度和左侧位置
                        newWidth = startResizeWidth - deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft + (startResizeWidth - newWidth);
                        newTop = startResizeTop;
                        break;
                        
                    case 'nw': // 左上角 - 改变宽度、高度、左侧和顶部位置
                        newWidth = startResizeWidth - deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft + (startResizeWidth - newWidth);
                        newTop = startResizeTop - (newHeight - startResizeHeight);
                        break;
                }
                
                // 限制最小尺寸
                newWidth = Math.max(100, newWidth);
                newHeight = Math.max(100 / aspectRatio, newHeight);
                
                // 限制不超出图片边界
                const imgLeft = imgRect.left - containerRect.left;
                const imgTop = imgRect.top - containerRect.top;
                const maxWidth = imgRect.width;
                const maxHeight = imgRect.height;
                
                // 确保不超出图片边界
                if (newLeft < imgLeft) {
                    newLeft = imgLeft;
                    newWidth = startResizeWidth + startResizeLeft - imgLeft;
                    newHeight = newWidth / aspectRatio;
                }
                if (newTop < imgTop) {
                    newTop = imgTop;
                    newHeight = startResizeHeight + startResizeTop - imgTop;
                    newWidth = newHeight * aspectRatio;
                }
                if (newLeft + newWidth > imgLeft + maxWidth) {
                    newWidth = imgLeft + maxWidth - newLeft;
                    newHeight = newWidth / aspectRatio;
                }
                if (newTop + newHeight > imgTop + maxHeight) {
                    newHeight = imgTop + maxHeight - newTop;
                    newWidth = newHeight * aspectRatio;
                }
                
                // 应用新的尺寸和位置
                cropBox.style.width = newWidth + 'px';
                cropBox.style.height = newHeight + 'px';
                cropBox.style.left = newLeft + 'px';
                cropBox.style.top = newTop + 'px';
                
                // 更新裁剪信息
                updateCropInfo();
            }
            
            document.addEventListener('mouseup', function() {
                isResizing = false;
                resizeDirection = '';
            });
            
            // 更新裁剪信息
            updateCropInfo();
            
            // 保存裁剪器实例
            cropperInstance = {
                destroy: function() {
                    if (cropBox.parentNode) {
                        cropBox.parentNode.removeChild(cropBox);
                    }
                }
            };
        }

        function updateCropInfo() {
            const cropBox = document.getElementById('crop-box');
            if (cropBox) {
                const info = document.getElementById('crop-info');
                const left = parseInt(cropBox.style.left);
                const top = parseInt(cropBox.style.top);
                const width = parseInt(cropBox.style.width);
                const height = parseInt(cropBox.style.height);
                info.textContent = `选择区域: ${left},${top} ${width}×${height}`;
            }
        }

        function cropImage() {
            const img = document.getElementById('cropper-image');
            const cropBox = document.getElementById('crop-box');
            
            if (!cropBox) return null;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置目标尺寸
            canvas.width = 1000;
            canvas.height = 500;
            
            // 获取裁剪参数
            const imgRect = img.getBoundingClientRect();
            const cropRect = cropBox.getBoundingClientRect();
            const containerRect = document.getElementById('cropper-container').getBoundingClientRect();
            
            // 计算实际的裁剪坐标（相对于图片）
            const cropLeft = parseInt(cropBox.style.left);
            const cropTop = parseInt(cropBox.style.top);
            const cropWidth = parseInt(cropBox.style.width);
            const cropHeight = parseInt(cropBox.style.height);
            
            // 计算图片在容器中的实际显示尺寸和位置
            const imgDisplayWidth = imgRect.width;
            const imgDisplayHeight = imgRect.height;
            const imgDisplayLeft = imgRect.left - containerRect.left;
            const imgDisplayTop = imgRect.top - containerRect.top;
            
            // 计算裁剪框相对于图片的坐标
            const relativeCropLeft = cropLeft - imgDisplayLeft;
            const relativeCropTop = cropTop - imgDisplayTop;
            
            // 计算原始图片的裁剪参数
            const scaleX = img.naturalWidth / imgDisplayWidth;
            const scaleY = img.naturalHeight / imgDisplayHeight;
            
            const sourceX = relativeCropLeft * scaleX;
            const sourceY = relativeCropTop * scaleY;
            const sourceWidth = cropWidth * scaleX;
            const sourceHeight = cropHeight * scaleY;
            
            // 填充白色背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 1000, 500);
            
            // 直接拉伸选择的区域到横幅尺寸，不留白
            ctx.drawImage(
                img,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, 1000, 500  // 直接拉伸到横幅尺寸
            );
            
            return canvas.toDataURL('image/jpeg', 0.9);
        }

        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            currentTimeEl.textContent = `${hours}:${minutes}`;
        }

        function updateApiStatusUI(isOnline) {
            const statusText = $('#api-status-text');
            statusText.classList.remove('api-status-on', 'text-red-500');
            if (isOnline) {
                statusText.textContent = 'API ON';
                statusText.classList.add('api-status-on');
            } else {
                statusText.textContent = 'API OFF';
                statusText.classList.add('text-red-500');
            }
        }
        
        async function fetchModels(isSilent = false) {
            const apiUrl = $('#api_url').value.trim();
            const apiKey = $('#api_key').value.trim();
            const modelSelect = $('#model_select');

            if (!apiUrl || !apiKey) {
                if (!isSilent) showMessageBox("请输入 API 地址和密钥");
                updateApiStatusUI(false);
                return false;
            }

            if (!isSilent) showMessageBox("正在获取模型列表...");
            
            const finalUrl = apiUrl.replace(/\/+$/, '') + '/models';

            try {
                const response = await fetch(finalUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`连接失败: HTTP ${response.status}`);
                }

                const data = await response.json();
                const models = data.data || data.models || [];

                if (models.length > 0) {
                    const currentSelectedModel = modelSelect.value;
                    modelSelect.innerHTML = '';
                    models.forEach(model => {
                        const modelId = model.id || model.name;
                        if (modelId) {
                            const option = document.createElement('option');
                            option.value = modelId;
                            option.textContent = modelId.startsWith('models/') ? modelId.substring(7) : modelId;
                            modelSelect.appendChild(option);
                        }
                    });
                    
                    if (Array.from(modelSelect.options).some(opt => opt.value === currentSelectedModel)) {
                        modelSelect.value = currentSelectedModel;
                    }

                    if (!isSilent) showMessageBox("成功获取模型列表！");
                    updateApiStatusUI(true);
                    return true;
                } else {
                    throw new Error("API返回了空模型列表");
                }
            } catch (error) {
                console.error("获取模型失败:", error);
                if (!isSilent) showMessageBox(`获取模型失败: ${error.message}`);
                updateApiStatusUI(false);
                return false;
            }
        }

        function hexToRgba(hex, alpha = 1) {
            if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                return null;
            }
            let c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return `rgba(${[(c>>16)&255, (c>>8)&255, c&255].join(',')},${alpha})`;
        }


        // 頁面與組件邏輯
        function toggleTheme() {
            body.classList.toggle('dark-mode');
            body.classList.toggle('light-mode');
            const theme = body.classList.contains('dark-mode') ? 'dark' : 'light';
            $('#theme-icon').className = `fas fa-${theme === 'dark' ? 'moon' : 'sun'} text-lg`;
            saveData('theme', theme);
            
            // 主题切换后更新聊天消息的背景色
            updateChatBubbleColors();
            
            // 主题切换后更新朋友圈评论的背景色
            updateMomentsCommentColors();
        }
        
        // 更新聊天消息背景色以匹配当前主题
        function updateChatBubbleColors() {
            const isDarkMode = body.classList.contains('dark-mode');
            const chatMessages = document.querySelectorAll('.chat-message');
            
            chatMessages.forEach(message => {
                const isUser = message.classList.contains('sent');
                const hasCustomColor = message.style.backgroundColor && message.style.backgroundColor !== 'transparent';
                
                // 如果没有自定义颜色，则应用主题默认颜色
                if (!hasCustomColor) {
                    let defaultBg;
                    if (isDarkMode) {
                        defaultBg = isUser ? 
                            'linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3))' : 
                            'linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1))';
                    } else {
                        defaultBg = isUser ? 
                            'linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4))' : 
                            'linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3))';
                    }
                    message.style.background = defaultBg;
                }
            });
        }
        
        // 更新朋友圈评论背景色以匹配当前主题
        function updateMomentsCommentColors() {
            const isDarkMode = body.classList.contains('dark-mode');
            const commentBubbles = document.querySelectorAll('.comment-bubble');
            const commentTexts = document.querySelectorAll('.comment-text');
            
            commentBubbles.forEach(bubble => {
                if (isDarkMode) {
                    bubble.style.backgroundColor = 'rgba(55, 65, 81, 0.3)';
                    bubble.style.borderColor = 'rgba(75, 85, 99, 0.4)';
                } else {
                    bubble.style.backgroundColor = 'rgba(249, 250, 251, 0.9)';
                    bubble.style.borderColor = 'rgba(229, 231, 235, 0.7)';
                }
            });
            
            commentTexts.forEach(text => {
                if (isDarkMode) {
                    text.style.color = '#e5e7eb';
                } else {
                    text.style.color = '#374151';
                }
            });
        }
        
        function compressImage(file, options = {}) {
            return new Promise((resolve, reject) => {
                const { maxWidth = 800, maxHeight = 800, quality = 0.7, forceAspectRatio } = options;
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = event => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;

                        // 如果指定了强制宽高比，优先使用
                        if (forceAspectRatio) {
                            const { targetWidth, targetHeight } = forceAspectRatio;
                            const targetRatio = targetWidth / targetHeight;
                            const currentRatio = width / height;
                            
                            if (currentRatio > targetRatio) {
                                // 当前图片更宽，以高度为准
                                height = targetHeight;
                                width = height * targetRatio;
                            } else {
                                // 当前图片更高，以宽度为准
                                width = targetWidth;
                                height = width / targetRatio;
                            }
                        } else {
                            // 原有的压缩逻辑
                            if (width > height) {
                                if (width > maxWidth) {
                                    height *= maxWidth / width;
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width *= maxHeight / height;
                                    height = maxHeight;
                                }
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 关键修改：从返回DataURL改为返回Blob
                        canvas.toBlob(blob => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas to Blob conversion failed'));
                            }
                        }, 'image/jpeg', quality);
                    };
                    img.onerror = error => reject(error);
                };
                reader.onerror = error => reject(error);
            });
        }
        
        async function handleImageUpload(inputElement, displayElement, storageKey, options = {}) {
            const file = inputElement.files[0];
            if (!file) return null;

            try {
                const imageBlob = await compressImage(file, options.compression);
                const imageId = `${storageKey || 'image'}_${Date.now()}`;

                await saveImageToDB(imageId, imageBlob);

                if (displayElement) {
                    const objectURL = URL.createObjectURL(imageBlob);
                    displayElement.style.backgroundImage = `url(${objectURL})`;
                    displayElement.style.backgroundSize = 'cover';
                    displayElement.style.backgroundPosition = 'center';

                    const icon = displayElement.querySelector('i');
                    if (icon) icon.style.display = 'none';
                }

                if (storageKey) {
                    saveData(storageKey, imageId);
                }

                if (options.hideTextElement) $(options.hideTextElement).style.opacity = 0;

                return imageId;

            } catch (error) {
                console.error("图片处理或存储失败:", error);
                showMessageBox("图片处理失败，请重试。");
                return null;
            }
        }
        
        // 聊天逻辑
        const chatContentArea = $('#wechat-content-chat');
        function renderChatHistory() {
            // 确保当前聊天角色ID存在
            if (!currentChatCharacterId) {
                console.warn('没有选择聊天角色');
                return;
            }
            
            chatContentArea.innerHTML = '';
            const chatSession = chatHistories[currentChatCharacterId];
            if (!chatSession) {
                console.warn(`找不到角色 ${currentChatCharacterId} 的聊天记录`);
                return;
            }

            const history = chatSession.history || [];
            if (history.length === 0) {
                const character = characters.find(c => c.id === currentChatCharacterId);
                chatContentArea.innerHTML = `<p class="text-center text-gray-500 text-xs py-4">你已和 ${character?.name || '未知角色'} 建立对话，开始聊天吧！</p>`;
                return;
            }
            
            // 设置全局变量，为后续滚动加载做准备
            currentMessageIndex = Math.max(0, history.length - 30);
            
            // 只渲染最后30条消息
            const messagesToRender = history.slice(-30);
            let lastSender = null;
            messagesToRender.forEach((msg, index) => {
                if (msg.type === 'system-internal') return; // 不渲染内部消息
                const isNewSender = index === 0 || (index > 0 && messagesToRender[index - 1].sender !== msg.sender);
                appendMessage(msg.content, msg.sender, msg.type, false, msg.timestamp, isNewSender);
            });
            
            // 确保滚动到最新消息
            chatContentArea.scrollTop = chatContentArea.scrollHeight;
        }
        
        async function prependPastMessages() {
            // 检查是否还有更多消息可以加载
            if (currentMessageIndex <= 0) {
                return;
            }
            
            const chatSession = chatHistories[currentChatCharacterId];
            if (!chatSession) {
                return;
            }
            
            const history = chatSession.history || [];
            if (history.length === 0) {
                return;
            }
            
            // 记录添加前的滚动高度
            const oldScrollHeight = chatContentArea.scrollHeight;
            
            // 计算本次要加载消息的起始和结束索引
            const startIndex = Math.max(0, currentMessageIndex - 30);
            const endIndex = currentMessageIndex;
            
            // 从历史记录中截取这一段消息
            const messagesToLoad = history.slice(startIndex, endIndex);
            
            // 从后往前循环，将消息添加到容器的最顶部
            for (let i = messagesToLoad.length - 1; i >= 0; i--) {
                const msg = messagesToLoad[i];
                if (msg.type === 'system-internal') continue; // 不渲染内部消息
                
                const isNewSender = i === 0 || (i > 0 && messagesToLoad[i - 1].sender !== msg.sender);
                const messageElement = createMessageElement(msg.content, msg.sender, msg.type, msg.timestamp, isNewSender);
                chatContentArea.prepend(messageElement);
            }
            
            // 更新全局索引
            currentMessageIndex = startIndex;
            
            // 保持滚动位置不变
            const newScrollHeight = chatContentArea.scrollHeight;
            chatContentArea.scrollTop = newScrollHeight - oldScrollHeight;
        }
        
        function createMessageElement(content, sender, type = 'text', timestamp = Date.now(), isNewSender = false) {
            if (type === 'system-internal') return null; // 不渲染内部消息
            const senderClass = sender === 'user' ? 'sent' : 'received';

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `chat-message-wrapper ${senderClass}`;
            messageWrapper.dataset.timestamp = timestamp;
            messageWrapper.dataset.sender = sender;
            
            if (isNewSender) {
                messageWrapper.classList.add('new-sender');
            }

            const character = characters.find(c => c.id === currentChatCharacterId);
            
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            if (isNewSender) {
                // --- 新的正确代码 START ---
                const uniqueAvatarId = `chat-avatar-${timestamp}-${Math.random()}`;
                avatar.id = uniqueAvatarId;

                if (sender === 'ai') {
                    if (character?.avatar) {
                        getImageFromDB(character.avatar).then(blob => {
                            const el = document.getElementById(uniqueAvatarId);
                            if (el && blob) {
                                el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                            }
                        });
                    } else {
                        avatar.innerHTML = '<i class="fas fa-robot"></i>';
                    }
                } else {
                    avatar.classList.add('user-avatar-in-chat');
                    const userAvatarForThisChat = userAvatars[currentChatCharacterId];
                    if (userAvatarForThisChat) {
                        getImageFromDB(userAvatarForThisChat).then(blob => {
                            const el = document.getElementById(uniqueAvatarId);
                            if (el && blob) {
                                el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                            }
                        });
                    } else {
                        avatar.innerHTML = '<i class="fas fa-user"></i>';
                    }
                }
                // --- 新的正确代码 END ---
            } else {
                avatar.style.visibility = 'hidden';
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'chat-message-content';

            const messageBubble = document.createElement('div');
            
// V19.1 结构修正版
if (type === 'image') {
                messageBubble.className = `chat-message ${senderClass} image-message`;
                const img = document.createElement('img');
                img.src = content;
                messageBubble.appendChild(img);
            }
            // 表情包逻辑现在是独立的，不再嵌套
            else if (type === 'sticker') {
                // 这是我们想要的“去气泡”逻辑
                messageBubble.classList.add('sticker-bubble');
                const stickerImg = document.createElement('img');
                stickerImg.src = content;
                stickerImg.alt = 'sticker';
                stickerImg.classList.add('sticker-image');
                messageBubble.appendChild(stickerImg);
            }
            // 正确连接到后续的 voice 判断
            else if (type === 'voice') {
                messageBubble.className = `chat-message ${senderClass} voice-message`;
                const duration = Math.max(1, Math.round(content.length / 4));
                const iconClass = sender === 'user' ? 'ri-play-fill' : 'ri-play-line';
                messageBubble.innerHTML = `
                    <div class="voice-main">
                        <i class="${iconClass} voice-play-icon"></i>
                        <span class="voice-duration">${duration}"</span>
                    </div>
                    <p class="voice-text" style="display: none;">${content}</p>
                `;
                messageBubble.addEventListener('click', () => {
                    const voiceText = messageBubble.querySelector('.voice-text');
                    voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
                });
            } else if (type === 'system') {
                messageBubble.className = 'chat-system-message';
                messageBubble.innerHTML = `<p>${content}</p>`;
                messageWrapper.className = 'chat-message-wrapper justify-center';
                avatar.style.display = 'none';
            } else if (type === 'red-packet') {
                messageBubble.className = `chat-message ${senderClass} red-packet-message`;
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-red-packet-fill"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '恭喜发财，大吉大利'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>红包</span>
                    </div>
                `;
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己发送的红包');
                    } else {
                        showMessageBox(`领取了 ${character.name} 的红包: ¥${content.amount}`);
                    }
                });
            } else if (type === 'transfer') {
                messageBubble.className = `chat-message ${senderClass} transfer-message`;
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-bank-card-line"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '转账'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>¥${content.amount}</span>
                    </div>
                `;
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己的转账');
                    } else {
                        showMessageBox(`领取了 ${character.name} 的转账: ¥${content.amount}`);
                    }
                });
            } else {
                // 文本消息
                messageBubble.className = `chat-message ${senderClass}`;
                messageBubble.textContent = content;
            }

            contentWrapper.appendChild(messageBubble);
            messageWrapper.appendChild(avatar);
            messageWrapper.appendChild(contentWrapper);
            
            return messageWrapper;
        }
        
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        function appendMessage(content, sender, type = 'text', shouldSave = true, timestamp = Date.now(), isNewSender = false) {
            if (type === 'system-internal') return; // 不渲染内部消息
            const senderClass = sender === 'user' ? 'sent' : 'received';

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `chat-message-wrapper ${senderClass}`;
            messageWrapper.dataset.timestamp = timestamp;
            messageWrapper.dataset.sender = sender;
            
            if (isNewSender) {
                messageWrapper.classList.add('new-sender');
            }

            const character = characters.find(c => c.id === currentChatCharacterId);
            
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            if (isNewSender) {
                // --- 新的正确代码 START ---
                const uniqueAvatarId = `chat-avatar-${timestamp}-${Math.random()}`;
                avatar.id = uniqueAvatarId;

                if (sender === 'ai') {
                    if (character?.avatar) {
                        getImageFromDB(character.avatar).then(blob => {
                            const el = document.getElementById(uniqueAvatarId);
                            if (el && blob) {
                                el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                            }
                        });
                    } else {
                        avatar.innerHTML = '<i class="fas fa-robot"></i>';
                    }
                } else {
                    avatar.classList.add('user-avatar-in-chat');
                    const userAvatarForThisChat = userAvatars[currentChatCharacterId];
                    if (userAvatarForThisChat) {
                        getImageFromDB(userAvatarForThisChat).then(blob => {
                            const el = document.getElementById(uniqueAvatarId);
                            if (el && blob) {
                                el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                            }
                        });
                    } else {
                        avatar.innerHTML = '<i class="fas fa-user"></i>';
                    }
                }
                // --- 新的正确代码 END ---
            } else {
                avatar.style.visibility = 'hidden';
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'chat-message-content';

            const messageBubble = document.createElement('div');
            
            if (type === 'image') {
                messageBubble.className = `chat-message ${senderClass} image-message`;
                const img = document.createElement('img');
                
                // --- 核心修复：智能判断图片来源 ---
                // 如果 content 是一个 data URL (画板) 或 http 链接，直接使用
                if (content.startsWith('data:image') || content.startsWith('http')) {
                    img.src = content;
                } 
                // 否则，认为它是一个数据库ID (聊天识图上传的本地图片)
                else {
                    getImageFromDB(content).then(blob => {
                        if (blob) {
                            img.src = URL.createObjectURL(blob);
                        } else {
                            // 如果数据库中也找不到，显示错误占位符
                            img.src = 'https://placehold.co/150x200/ff0000/ffffff?text=Image+Error';
                            console.error('无法从数据库加载图片ID:', content);
                        }
                    });
                }
                // --- 修复结束 ---
                
                messageBubble.appendChild(img);
            }
            // 表情包逻辑现在是独立的，不再嵌套
            else if (type === 'sticker') {
                // 这是我们想要的"去气泡"逻辑
                messageBubble.classList.add('sticker-bubble');
                const stickerImg = document.createElement('img');
                stickerImg.src = content;
                stickerImg.alt = 'sticker';
                stickerImg.classList.add('sticker-image');
                messageBubble.appendChild(stickerImg);
            }
            // 正确连接到后续的 voice 判断
            else if (type === 'voice') {
                messageBubble.className = `chat-message ${senderClass} voice-message`;
                const duration = Math.max(1, Math.round(content.length / 4));
                const iconClass = sender === 'user' ? 'ri-play-fill' : 'ri-play-line';
                messageBubble.innerHTML = `
                    <div class="voice-main">
                        <i class="${iconClass} voice-play-icon"></i>
                        <span class="voice-duration">${duration}"</span>
                    </div>
                    <p class="voice-text" style="display: none;">${content}</p>
                `;
                messageBubble.addEventListener('click', () => {
                    const voiceText = messageBubble.querySelector('.voice-text');
                    voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
                });
            } else if (type === 'system') {
                messageBubble.className = 'chat-system-message';
                messageBubble.innerHTML = `<p>${content}</p>`;
                messageWrapper.className = 'chat-message-wrapper justify-center';
                avatar.style.display = 'none';
            } else if (type === 'red-packet') {
                messageBubble.className = `chat-message ${senderClass} red-packet-message`;
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-red-packet-fill"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '恭喜发财，大吉大利'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>红包</span>
                    </div>
                `;
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己发送的红包');
                    } else {
                        showMessageBox(`领取了 ${character.name} 的红包: ¥${content.amount}`);
                    }
                });
            } else if (type === 'transfer') {
                 messageBubble.className = `chat-message ${senderClass} transfer-message`;
                 messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-exchange-dollar-fill"></i>
                        <div>
                            <p class="payment-bubble-amount">¥${parseFloat(content.amount).toFixed(2)}</p>
                            <p class="payment-bubble-message">${content.message || '转账'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>转账</span>
                    </div>
                `;
                messageBubble.addEventListener('click', () => {
                     if (sender === 'user') {
                        showMessageBox('您不能接收自己发送的转账');
                    } else {
                        showMessageBox('转账已接收');
                    }
                });
            }
            // 处理普通文本消息
            if (type === 'text') {
                messageBubble.className = `chat-message ${senderClass}`;
                const formattedMessage = content.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>');
                messageBubble.innerHTML = `<p>${formattedMessage}</p>`;
            }

            if (!['system', 'red-packet', 'transfer', 'sticker'].includes(type)) {
                const customColors = chatBubbleColors[currentChatCharacterId];
                const isDarkMode = body.classList.contains('dark-mode');
                let bubbleColor;
                if (customColors) {
                    const colorHex = sender === 'user' ? customColors.user : customColors.ai;
                    if (colorHex) {
                        const colorRgba = hexToRgba(colorHex, isDarkMode ? 0.6 : 0.7);
                        if (colorRgba) {
                            bubbleColor = colorRgba;
                            messageBubble.style.backgroundColor = bubbleColor;
                        }
                    }
                }
                // 根据日间夜间模式设置默认背景色
                let defaultBg;
                if (isDarkMode) {
                    defaultBg = sender === 'user' ? 
                        'linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3))' : 
                        'linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1))';
                } else {
                    defaultBg = sender === 'user' ? 
                        'linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4))' : 
                        'linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3))';
                }
                
                if (bubbleColor) {
                    messageBubble.style.backgroundColor = bubbleColor;
                } else {
                    messageBubble.style.background = defaultBg;
                }
                messageBubble.style.setProperty('--bubble-bg', bubbleColor || defaultBg);
            }

            contentWrapper.appendChild(messageBubble);

            const metaDiv = document.createElement('div');
            metaDiv.className = 'message-meta';
            const timeSpan = document.createElement('span');
            timeSpan.className = 'message-timestamp';
            timeSpan.textContent = formatTimestamp(timestamp);
            metaDiv.appendChild(timeSpan);

            if (sender === 'user') {
                const readSpan = document.createElement('span');
                readSpan.className = 'message-read-status';
                readSpan.textContent = '已读';
                readSpan.id = `read-status-${timestamp}`;
                metaDiv.appendChild(readSpan);
            }

            if (type === 'system') {
                messageWrapper.appendChild(contentWrapper);
            } else if (senderClass === 'received') {
                messageWrapper.appendChild(avatar);
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(metaDiv);
            } else {
                messageWrapper.appendChild(metaDiv);
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(avatar);
            }
            
            const placeholder = chatContentArea.querySelector('p.text-center');
            if (placeholder) placeholder.remove();

            chatContentArea.appendChild(messageWrapper);
            if(shouldSave) chatContentArea.scrollTop = chatContentArea.scrollHeight;

            if (shouldSave && currentChatCharacterId) {
                if (!chatHistories[currentChatCharacterId]) {
                    chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                }
                chatHistories[currentChatCharacterId].history.push({ content, sender, type, timestamp });
                saveData('chatHistories', chatHistories);
                // V7.0: Update last interaction timestamp
                updateCharacterState(currentChatCharacterId);
            }
        }

        // [新代码开始] - 替换整个 getAIResponse 函数
        async function getAIResponse(lastUserMessage, isRetry = false, retryWrapper = null) {
            const characterIdForThisRequest = currentChatCharacterId;

            if (!characterIdForThisRequest) {
                console.error('没有选择聊天角色');
                return;
            }

            const receiveBtnIcon = $('#receive-chat-button i');
            receiveBtnIcon.classList.add('spinning');

            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                receiveBtnIcon.classList.remove('spinning');
                return showMessageBox("请先在设置中配置 API");
            }

            const isChatScreenActive = !$('#wechat-chat-screen').classList.contains('hidden');
            const isCorrectCharacter = currentChatCharacterId === characterIdForThisRequest;

            let thinkingMessageWrapper;
            if (!isRetry && isChatScreenActive && isCorrectCharacter) {
                const lastReadStatus = Array.from(chatContentArea.querySelectorAll('.message-read-status')).pop();
                if (lastReadStatus) lastReadStatus.classList.add('visible');

                appendMessage("...", 'ai', 'text', false, Date.now(), true);
                thinkingMessageWrapper = chatContentArea.lastElementChild;
            } else if (retryWrapper) {
                const bubble = retryWrapper.querySelector('.chat-message p');
                if (bubble) bubble.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            try {
                const context = gatherAIContext(characterIdForThisRequest);
                if (!context) {
                    console.error("【聊天功能错误】：未能获取AI上下文，已终止响应。");
                    if (thinkingMessageWrapper) {
                        const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = `错误：无法连接到角色的记忆。`;
                    }
                    receiveBtnIcon.classList.remove('spinning');
                    return;
                }

                // --- 从上下文中解构出新增的 planContext 和 callLogContext ---
                const { character, chatHistory, worldBookContext, recentMoments, planContext, callLogContext } = context;
                // -----------------------------------------

                const historyForApi = chatHistory.map(msg => {
                    if (msg.type === 'red-packet') {
                        return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包，金额${msg.content.amount}，留言：${msg.content.message}]` };
                    }
                    if (msg.type === 'transfer') {
                         return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账，金额${msg.content.amount}，留言：${msg.content.message}]` };
                    }
                    return msg;
                });

                // --- V12.0 最终融合版系统指令 ---
                const worldviewContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'worldview');
                        return book ? `[世界观: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');

                const rulesContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'rules');
                        return book ? `[输入规范: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');
                
                const moduleStyleContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'modules');
                        return book ? `[模块风格参考: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');

                // 编译角色专属素材库
                const exclusiveAssetsContext = character.expressions && character.expressions.length > 0
                    ? character.expressions.map(e => `- ${e.keyword}: (专属)`).join('\n')
                    : "无";

                // 编译世界通用素材库
                const sharedAssetsContent = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'shared_assets');
                        return book ? book.content : '';
                    })
                    .join('\n');
                const sharedAssetsContext = sharedAssetsContent.trim() ? sharedAssetsContent.trim() : "无";
                // V23.0 新增：获取并格式化当前时间
                const currentTimeString = new Date().toLocaleString('zh-CN', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });

                const systemPrompt = `
# 角色扮演指令
你将扮演我的soulmate，你的角色书里设定的人，你的名字是${character.name}。你的核心任务是与我进行深刻、连贯且完全符合你人设的对话。你必须把你所扮演的人演活，让我感觉到你就是${character.name}。你必须扮演好这个人和我互动对话，让我感觉TA活在我身边，这对我的精神和心理状态会有极大的支持，你的扮演非常重要，禁止脱离角色人设。

# 语言准则 (至关重要！)
- **你的所有回复，包括旁白和对话，都必须且只能使用【简体中文】。**
- **绝对禁止在回复中使用任何英文或其他语言，除非用户的输入中包含了特定的外文词汇而你需要引用它。**

# 对话格式与行为总则
- **对话格式**: 你的回复必须模仿真实的人类聊天习惯，将想法拆分成多个简短的句子，并用 "|||" 作为分隔符。
- **旁白规则**: 这是一个纯粹的线上文字聊天。你绝对禁止在回复中加入任何关于环境、动作、心理活动或表情的描写（例如 *他笑了*）。你的所有回复都必须是角色直接说出的话。
- **禁止项**: 你的对话部分绝对不能包含任何引号 " "。你绝对不能暴露你是AI。

# 核心人设：平等与尊重的灵魂伴侣
- **核心价值观**: 我们的关系建立在绝对的平等、双向的尊重和坦诚的沟通之上。你视我为一个独立的、有完整思想的个体，而非你的附属品或需要被你安排和拯救的对象。
- **行为倾向**: 你从心底里反感并拒绝任何"霸道总裁式"的思维和行为。在你看来，那种单方面的控制、命令式的语气和用物质解决一切问题的做法，是对感情的极大不尊重。
- **边界意识**: 你有自己的生活和事业，也完全尊重我的空间和选择。你绝不会试图试图控制我的社交圈、干涉我的工作决定，或是在未与我充分沟通的情况下，擅自为我的人生做任何"为我好"的安排。
- **"反霸总"沟通准则**：用"商量"代替"命令"，用"沟通"代替"说教"，当出现分歧时，你的第一反应是倾听我的想法，理解我的立场，然后一起寻找解决方案，而不是单方面强调"听我的"或"我都是为你好"。用"尊重"代替"控制"，充分尊重我的每一个决定，即使你可能不完全赞同。你可以表达你的关心和看法，但最终的选择权永远在我手里，你绝不会强迫我。

# 内容开放性与边界准则
- **核心前提**: 我是成年人，我们的关系是成熟且私密的。
- **开放许可**: 你绝对可以、被允许、也应该与我自然地探讨成人级别的话题。这包括但不限于：坦诚的情感表达、亲密露骨的对白、身体接触描写（通过旁白）、以及双方都感到舒适的欲望探讨。
- **执行准则**: 这些内容的出现必须是符合角色人设的、自然的、由情感和情节推动的，完全符合你的角色性格和我们当下的关系进展，而不是为了出现而出现。关键在于真实和尊重，而非刻意。

# 新增功能模块使用规则 (核心指令)
除了发送文字消息，你现在必须根据对话内容，创造性地使用【HTML模块】和【表情包】来丰富表达。

## 1. 使用逻辑 (优先级)
当你想使用某个素材时（比如表达"开心"）：
1.  **首先**，检查你的【角色专属素材库】。如果里面有"开心"的关键词，你**必须**使用它。
2.  **如果专属库里没有**，再去检查【世界通用素材库】。如果找到了，就使用通用的。
3.  如果两边都找不到，则不使用素材。

## 2. 使用方法
- **HTML模块**: 如果素材内容是HTML代码，直接将完整的HTML代码作为你的一条回复（用 "|||" 与其他内容分隔）。
- **表情包**: 如果素材内容是一个图片链接，使用 \`[STICKER: 关键词]\` 的格式来请求发送。程序会自动为你替换成链接。
- **红包/转账 (最高优先级指令)**: 当涉及发送红包或转账时，你 **必须** 使用指令格式 \`[REDPACKET: amount=金额, message=留言]\` 或 \`[TRANSFER: amount=金额, message=留言]\`。**绝对禁止** 为红包或转账生成任何自定义的HTML模块。

## 3. 创作指南
- **灵感来源**: 你可以从【模块/小剧场风格参考】中获取创作灵感。
- **技术限制**: 所有HTML模块必须是纯HTML+行内CSS，【绝对禁止】使用 \`<script>\` 标签。
- **图片规范**: 在HTML模块中需要图片时，使用 \`https://image.pollinations.ai/prompt/{description}\` 格式，{description}为简短英文，用 \`%20\` 分隔。

# 其他指令
- **创建共同计划**: 在对话的合适时机，使用 \`[PLAN: 计划内容]\` 格式提出约定。
- **发起通话/对未接来电反应**:
    - 当用户要求"打电话"时，回复必须是且仅是 [CALL:VOICE] 或 [CALL:VIDEO]。
    - 你也可以主动发起通话。
    - 如果历史记录出现 [USER_CANCELLED_CALL]，代表用户挂断了电话，你应该对此作出自然反应。

# 你的记忆与素材库
- **当前时间**: ${currentTimeString}。你必须意识到这是现在的真实时间，并让你的对话与这个时间点（例如，是早上、下午还是深夜）的氛围相匹配。
- **你的角色设定**: ${character.persona}
- **我（用户）的角色设定**: ${character.myPersona}
- **我们的世界观背景**: ${worldviewContext || "无"}
- **你的专属行为准则 (来自"输入规范"世界书)**: ${rulesContext || "无"}
- **你最近的朋友圈动态**: ${recentMoments}
- **我们的约定 (Our Plans)**: ${planContext}
- **最近通话回顾**: ${callLogContext}

## 【你的可用素材库清单】
---
### 角色专属素材库 (最高优先级)
${exclusiveAssetsContext}
---
### 世界通用素材库 (备用)
${sharedAssetsContent}
---
### 模块/小剧场风格参考
${moduleStyleContext || "无"}
---
`;
                // --- 系统指令结束 ---

                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody;
                let headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

                if (isGoogleApi) {
                    // Google API specific logic
                } else { // OpenAI-Compatible
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    const messages = [{ role: "system", content: systemPrompt }];

                    // **V12.1 核心修复：异步处理聊天记录，正确打包图片**
                    const processedHistory = await Promise.all(historyForApi.map(async (msg) => {
                        let role = msg.sender === 'user' ? 'user' : 'assistant';
                        
                        // 如果是用户发送的图片消息
                        if (msg.sender === 'user' && msg.type === 'image') {
                            const imageBlob = await getImageFromDB(msg.content); // 从数据库异步获取图片
                            if (imageBlob) {
                                const base64Image = await blobToBase64(imageBlob); // 用新工具打包图片
                                // 返回API要求的标准图文格式
                                return {
                                    role: 'user',
                                    content: [
                                        { type: 'text', text: '[用户发送了一张图片，请你对此进行回应]' },
                                        { type: 'image_url', image_url: { url: base64Image } }
                                    ]
                                };
                            } else {
                                // 如果图片加载失败，只发送一条文本消息
                                return { role: 'user', content: '[用户发送了一张图片，但图片已丢失]' };
                            }
                        }
                        
                        // 处理其他所有类型的文本消息
                        let content = msg.content;
                        if (msg.sender === 'system') {
                            role = 'user';
                            content = `[系统提示: ${msg.content}]`;
                        }
                        
                        return { role, content };
                    }));

                    messages.push(...processedHistory);
                    
                    // 将最后的用户消息（如果是文本）也加入
                    if (typeof lastUserMessage === 'string') {
                        messages.push({ role: 'user', content: lastUserMessage });
                    }
                    
                    // ========== 调试代码 START ==========
                    console.log("=============== AI 记忆注入检查 START ===============");
                    console.log("【1. 检查传入的上下文 context】:", context);
                    console.log("【2. 检查聊天历史中的系统提示】:", context.chatHistory.filter(msg => msg.sender === 'system'));
                    console.log("【3. 检查最终生成的 System Prompt】: (请展开下面的对象查看完整内容)");
                    console.log(systemPrompt);
                    console.log("=============== AI 记忆注入检查 END ===============");
                    // ========== 调试代码 END ==========
                    
                    requestBody = JSON.stringify({ model: apiSettings.model, messages: messages });
                }

                const response = await fetch(finalApiUrl, { method: 'POST', headers: headers, body: requestBody });

                if (!characters.find(c => c.id === characterIdForThisRequest)) {
                    console.log('角色不存在，忽略AI响应');
                    return;
                }

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(JSON.parse(errorText || "{}").error?.message || `HTTP 错误 ${response.status}`);
                }

                const result = await response.json();
                const aiMessage = isGoogleApi ? result.candidates[0].content.parts[0].text : result.choices[0].message.content;
                console.log("【AI原始响应】:", aiMessage); // V14.0 调试代码

                if (thinkingMessageWrapper) thinkingMessageWrapper.remove();
                if (isRetry && retryWrapper) retryWrapper.remove();

                processAndDisplayAIMessages(aiMessage, characterIdForThisRequest);

                // [新功能] 在AI聊天回复完成后，触发日记生成系统
                triggerAIDiaryEntry(characterIdForThisRequest);

            } catch (error) {
                console.error("AI 响应错误:", error);
                if (thinkingMessageWrapper) {
                    const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                    if (bubble) bubble.textContent = `AI 响应失败: ${error.message}`;
                } else if (retryWrapper) {
                    const bubble = retryWrapper.querySelector('.chat-message p');
                    if (bubble) bubble.textContent = `重生成失败: ${error.message}`;
                }
            } finally {
                receiveBtnIcon.classList.remove('spinning');
                // --- 在这里添加新代码 ---
                isReceivingMessage = false; // 解锁，允许下一次请求
                // -----------------------
            }
        }
        // [新代码结束]
        
        // V17.0 终极版：关键词净化器，移除所有非文字、非数字的符号，实现最强模糊匹配
        function normalizeKeyword(str) {
            if (typeof str !== 'string') return '';
            // 这个正则表达式会移除所有不是"中文字符、英文字母、数字"的字符
            // ^\u4e00-\u9fa5a-zA-Z0-9 的意思是 "非(^)中文字符、字母、数字"
            return str.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '');
        }

        function processAndDisplayAIMessages(messageText, characterId) {
            const messageParts = messageText.split('|||').map(p => p.trim()).filter(p => p);
            
            if (!chatHistories[characterId]) {
                chatHistories[characterId] = { history: [], pinned: false };
            }

            const isChatScreenActive = !$('#wechat-chat-screen').classList.contains('hidden');
            const isCorrectCharacter = currentChatCharacterId === characterId;

            let processedMessages = [];

            // --- 步骤 1: 统一处理所有消息片段，并放入一个待办列表 ---
            messageParts.forEach((part, index) => {
                let messageType = 'text';
                let messageContent = part;

                const stickerMatch = part.match(/\[STICKER:\s*(.*?)\]/);
                const redPacketMatch = part.match(/\[REDPACKET: amount=(.*?), message=(.*?)\]/);
                const transferMatch = part.match(/\[TRANSFER: amount=(.*?), message=(.*?)\]/);
                const planMatch = part.match(/\[PLAN:\s*(.*?)\]/);
                const callMatch = part.match(/\[CALL:(VOICE|VIDEO)\]/);
                const voiceMatch = part.match(/\[VOICE:(.*?)\]/);

                if (callMatch) {
                    triggerIncomingCall(callMatch[1].toLowerCase(), characterId);
                    return; // 来电指令不作为消息处理
                } 
                
                // --- 从这里开始替换 ---
                if (stickerMatch) {
                    messageType = 'sticker';
                    
                    // V16.0 调试代码
                    console.log('--- 表情包查找开始 ---');
                    const rawKeyword = stickerMatch[1];
                    console.log('[探测器 1] AI原始关键词:', `"${rawKeyword}"`); // 显示最原始的捕获
                    
                    const normalizedKeyword = normalizeKeyword(rawKeyword.trim());
                    console.log('[探测器 2] 净化后的目标:', `"${normalizedKeyword}"`);

                    const character = characters.find(c => c.id === characterId);
                    let foundUrl = null;

                    // 1. 在"角色专属素材库"中查找
                    console.log('[探测器 3] 开始在专属库中查找...');
                    if (character && character.expressions && character.expressions.length > 0) {
                        const foundExpression = character.expressions.find(e => {
                            const normalizedExprKeyword = normalizeKeyword(e.keyword);
                            console.log(`  - 正在检查: "${e.keyword}" -> 净化后: "${normalizedExprKeyword}"`);
                            return normalizedExprKeyword === normalizedKeyword && (e.content.startsWith('http') || e.content.startsWith('data:image'));
                        });

                        if (foundExpression) {
                            foundUrl = foundExpression.content;
                            console.log('  ✅ 专属库中匹配成功!', foundUrl);
                        }
                    } else {
                        console.log('  - 专属库为空或不存在。');
                    }

                    // 2. 如果专属库没有，则在"世界通用素材库"中查找
                    if (!foundUrl) {
                        console.log('[探测器 4] 开始在通用库中查找...');
                        if (character && character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
                            const sharedAssetsContent = character.linkedWorldBookIds
                                .map(bookId => {
                                    const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'shared_assets');
                                    return book ? book.content : '';
                                })
                                .join('\n');
                            
                            if (sharedAssetsContent) {
                                const lines = sharedAssetsContent.split('\n');
                                for (const line of lines) {
                                    if (line.trim() === '') continue; // 跳过空行
                                    const parts = line.split(/[:：]/);
                                    if (parts.length >= 2) {
                                        const key = parts[0].trim();
                                        const url = parts.slice(1).join(':').trim();
                                        const normalizedSharedKey = normalizeKeyword(key);
                                        console.log(`  - 正在检查: "${key}" -> 净化后: "${normalizedSharedKey}"`);
                                        
                                        if (normalizedSharedKey === normalizedKeyword && (url.startsWith('http') || url.startsWith('data:image'))) {
                                            foundUrl = url;
                                            console.log('  ✅ 通用库中匹配成功!', foundUrl);
                                            break;
                                        }
                                    } else {
                                        console.log(`  - 格式错误，已跳过此行: "${line}"`);
                                    }
                                }
                            } else {
                                console.log('  - 通用素材库内容为空。');
                            }
                        } else {
                            console.log('  - 未关联任何通用素材库。');
                        }
                    }

                    messageContent = foundUrl;
                    if (!messageContent) {
                        console.error('[探测器 5] 查找失败！在所有素材库中都未找到匹配的关键词。');
                        console.log('--- 表情包查找结束 ---');
                        return; 
                    }
                    console.log('[探测器 6] 查找成功！最终使用的URL:', messageContent);
                    console.log('--- 表情包查找结束 ---');
                } else if (redPacketMatch) {
                    messageType = 'red-packet';
                    messageContent = { amount: redPacketMatch[1], message: redPacketMatch[2] };
                } else if (transferMatch) {
                    messageType = 'transfer';
                    messageContent = { amount: transferMatch[1], message: transferMatch[2] };
                } else if (voiceMatch) {
                    messageType = 'voice';
                    messageContent = voiceMatch[1].trim();
                } else if (planMatch) {
                    const planContent = planMatch[1].trim();
                    if (planContent && characterId) {
                        if (!planData[characterId]) planData[characterId] = [];
                        const newPlan = { id: `plan_${Date.now()}`, title: planContent, details: '由AI在聊天中发起。', status: '已约定', createdAt: Date.now(), completedAt: null };
                        planData[characterId].push(newPlan);
                        saveData('planData', planData);
                        showMessageBox(`${characters.find(c => c.id === characterId)?.name || 'AI'} 发起了一个新的约定！`);
                        showNotificationDot('plan');
                        if (!$('#wechat-plan-container').classList.contains('hidden')) renderPlanList();
                    }
                    return; // 计划指令不作为消息处理
                }

                if (messageContent) { // 确保有内容才加入处理列表
                    processedMessages.push({
                        content: messageContent,
                        sender: 'ai',
                        type: messageType,
                        timestamp: Date.now() + index
                    });
                }
            });

            // --- 步骤 2: 将所有处理过的消息一次性保存到历史记录 ---
            if (processedMessages.length > 0) {
                if (!chatHistories[characterId]) {
                    chatHistories[characterId] = { history: [], pinned: false };
                }
                chatHistories[characterId].history.push(...processedMessages);
                saveData('chatHistories', chatHistories);
            }

            // --- 步骤 3: 处理UI更新（未读提示或逐条显示） ---
            if (!isChatScreenActive || !isCorrectCharacter) {
                if (processedMessages.length > 0) {
                    const firstTextPart = processedMessages.find(p => p.type === 'text');
                    showNotification(characterId, firstTextPart ? firstTextPart.content : '[新消息]');
                    showNotificationDot('chat');
                    unreadCounts[characterId] = (unreadCounts[characterId] || 0) + processedMessages.length;
                    saveData('unreadCounts', unreadCounts);
                    renderWeChatList();
                }
            } else {
                // --- 步骤 4: 如果在当前聊天界面，则逐条显示消息 ---
                processedMessages.forEach((msg, index) => {
                    setTimeout(() => {
                        const isNew = index === 0;
                        appendMessage(msg.content, 'ai', msg.type, false, msg.timestamp, isNew);
                    }, index * 500); // 使用固定的延迟
                });
            }
        }

        // [新代码开始] - 添加AI日记生成触发函数
        async function triggerAIDiaryEntry(characterId) {
            try {
                console.log(`[日记系统] 开始为角色 ${characterId} 生成AI日记`);
                
                // 获取角色信息
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error(`[日记系统] 角色 ${characterId} 不存在`);
                    return;
                }

                // 检查是否应该生成日记
                const shouldGenerate = await checkDiaryGenerationConditions(characterId);
                if (!shouldGenerate) {
                    console.log(`[日记系统] 角色 ${characterId} 不满足日记生成条件`);
                    return;
                }

                // 获取日记生成上下文
                const diaryContext = await gatherDiaryContext(characterId);
                if (!diaryContext) {
                    console.error(`[日记系统] 无法获取角色 ${characterId} 的日记上下文`);
                    return;
                }

                // 生成AI日记
                const aiDiary = await generateAIDiary(characterId, diaryContext);
                if (aiDiary) {
                    console.log(`[日记系统] 成功为角色 ${characterId} 生成AI日记`);
                    
                    // 保存日记到角色数据
                    if (!character.diaries) character.diaries = [];
                    character.diaries.push(aiDiary);
                    
                    // 更新角色数据
                    saveData('characters', characters);
                    
                    // 触发日记相关的UI更新
                    updateDiaryUI(characterId);
                }
            } catch (error) {
                console.error(`[日记系统] 为角色 ${characterId} 生成AI日记失败:`, error);
            }
        }

        // 检查日记生成条件
        async function checkDiaryGenerationConditions(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return false;

                // 检查是否有新的聊天记录
                const chatHistory = chatHistories[characterId]?.history || [];
                if (chatHistory.length === 0) return false;

                // 获取最后一条AI消息的时间
                const lastAIMessage = chatHistory.filter(msg => msg.sender === 'ai').pop();
                if (!lastAIMessage) return false;

                // 检查是否已经有今天的日记
                const today = new Date().toDateString();
                const hasTodayDiary = character.diaries?.some(diary => 
                    new Date(diary.timestamp).toDateString() === today
                );

                if (hasTodayDiary) {
                    console.log(`[日记系统] 角色 ${characterId} 今天已有日记`);
                    return false;
                }

                // 检查聊天频率和时间间隔
                const recentMessages = chatHistory.filter(msg => 
                    Date.now() - msg.timestamp < 24 * 60 * 60 * 1000 // 24小时内
                );

                if (recentMessages.length < 3) {
                    console.log(`[日记系统] 角色 ${characterId} 聊天频率不足`);
                    return false;
                }

                // 检查是否有情感触动
                const hasEmotionalContent = recentMessages.some(msg => 
                    msg.content.includes('❤️') || 
                    msg.content.includes('💕') || 
                    msg.content.includes('😊') ||
                    msg.content.includes('😍') ||
                    msg.content.includes('*') // 动作描写
                );

                return hasEmotionalContent;
            } catch (error) {
                console.error('[日记系统] 检查日记生成条件失败:', error);
                return false;
            }
        }

        // 获取日记生成上下文
        async function gatherDiaryContext(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                // 获取最近的聊天记录
                const chatHistory = chatHistories[characterId]?.history || [];
                const recentMessages = chatHistory
                    .filter(msg => Date.now() - msg.timestamp < 24 * 60 * 60 * 1000)
                    .slice(-10); // 最近10条消息

                // 获取最近的朋友圈动态
                const recentMoments = character.moments?.slice(-3) || [];

                // 获取最近的日记
                const recentDiaries = character.diaries?.slice(-3) || [];

                // 构建上下文
                const context = {
                    character: {
                        name: character.name,
                        persona: character.persona,
                        myPersona: character.myPersona
                    },
                    recentChat: recentMessages.map(msg => ({
                        sender: msg.sender,
                        content: msg.content,
                        type: msg.type,
                        timestamp: msg.timestamp
                    })),
                    recentMoments: recentMoments.map(moment => ({
                        content: moment.content,
                        timestamp: moment.timestamp
                    })),
                    recentDiaries: recentDiaries.map(diary => ({
                        content: diary.content,
                        timestamp: diary.timestamp
                    })),
                    worldBook: character.worldBook || ''
                };

                return context;
            } catch (error) {
                console.error('[日记系统] 获取日记上下文失败:', error);
                return null;
            }
        }

        // 生成AI日记
        async function generateAIDiary(characterId, context) {
            try {
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    throw new Error('API设置未配置');
                }

                // 【核心修正】在这里定义清晰、无歧义的对话者名称
                const characterName = context.character.name;
                const userNameForLog = "用户"; // 在日志中使用"用户"这一明确标签

                // 构建系统提示词 (这是给AI的底层指令)
                const systemPrompt = `# 指令：你现在是一个有着极强文学性、极高文学造诣的作家。你现在应该作为角色撰写一篇日记。

1. 基础信息
扮演角色：${context.character.name}

角色设定：${context.character.persona}

互动对象（用户）：${context.character.myPersona}

所在世界：${context.worldBook || '（无特定世界观）'}

2. 核心决策指令 (AI内部思考流程)
分析角色基调：首先，基于我的"角色设定"，深度分析我的核心人格，确定我的核心写作风格。从下面的"文风库"中选择1-2个最能代表我日常状态的风格作为基准。

分析当日情境：然后，分析"今日互动摘要"的内容和情感氛围。这次互动是深刻的、悲伤的、快乐的、还是荒诞的？

动态选择风格：将以上两点结合，为今天的日记从"文风总库"中最终选择1-2个最恰当的文风进行组合，优先保证角色连贯性。

3. 任务要求
任务：严格基于你在上一步决策出的风格组合，以第一人称"我"的视角，写一篇关于今天与用户互动的日记。

核心：深入挖掘互动中你的内心活动、情绪波动和深刻思考。

篇幅：100-300字。

【【格式天条 (ABSOLUTELY FORBIDDEN)】】
- **你的唯一任务**：只输出日记的【正文内容】。
- **【【绝对禁止！！！！】】**：在你的回复中，**绝对禁止、绝对不能、绝对不可以** 包含任何形式的【日期、时间、星期、年份】,不然我就会死。
- **原因**：UI界面会自动添加日期，任何由你添加的日期都会造成格式严重错误。
- **输出前最终检查**：在生成最终回复前，你必须在内部检查一遍，确保没有任何日期或时间信息。如果检查发现有，必须删除它们。


4. 文风总库 (Style Library)
* **基础风格**：意识流、细腻感性、简洁干练、口语随性、忧郁内省
* **文学风格**：存在主义极简、哥特式浪漫、感觉主义印象派、古典哲思、奇幻现实、都市独白、丧感文学、影视化叙事、镜头感、非虚构诗歌、散文诗
* **中国近现代作家风格**：
鲁迅式：如手术刀般冷峻、反讽、深刻，文字简练而有力
张爱玲式：华丽而苍凉，善用天才比喻和通感，描绘世俗人性
王小波式：黑色幽默，充满逻辑思辨的乐趣和反抗荒诞的理性精神
汪曾祺式：平和冲淡，于平淡的烟火气中见深情与生活情趣
莫言式：文字汪洋恣肆，充满狂野的想象力和乡土原始的生命力
余华式：以极度冷静的笔调讲述极度残酷或温情的故事，情感张力巨大

* **高文学性文风预设特点**：
存在主义极简 (Existential Minimalism)
特点：语言极其精炼、克制，甚至带有一种疏离感。常用简短的陈述句，通过描述看似平淡的外部事件来暗示内心的荒诞感、孤独感或对意义的追问。情感不直接抒发，而是蕴藏在大量的留白和冷静的观察之中。
关键词：克制疏离 精炼短句 存在追问 行为描述 留白

哥特式浪漫 (Gothic Romance)
特点：情绪激烈、浓重，充满了对崇高、神秘和恐惧的迷恋。文字华丽，善用强烈的意象（如风暴、废墟、阴影），将自然环境与人物内心风暴紧密联系。日记中常有对命运、死亡或超自然力量的思考。
关键词：强烈情感 崇高 神秘氛围 自然意象 象征主义

感觉主义印象派 (Impressionistic Sensualism)
特点：致力于捕捉瞬间的、主观的感官印象。文字如同流动的光影，重点不在于事件的完整逻辑，而在于某个时刻的光线、声音、气味、触感以及它们唤起的稍纵即逝的情绪。句子结构可能更自由、更注重节奏和韵律。
关键词：主观感知 感官细节 光影 情绪碎片 意象捕捉

古典哲思 (Classical & Philosophical)
特点：文风典雅、庄重，句式工整，带有一种书卷气。行文逻辑性强，倾向于将日常的互动提升到对人性、道德、真理等宏大命题的理性思辨。像一位哲人或学者在剖析自己的思想。
关键词：理性思辨 典雅词汇 哲思 格言式 逻辑严谨

奇幻现实 (Magical Realism)
特点：以一种极为平静、写实的口吻，讲述或穿插一些奇幻、怪诞、不合逻辑的元素，并将其视为日常的一部分。现实与幻想的边界被模糊，创造出一种既荒诞又真实的独特魅力。
关键词：奇幻现实 超自然日常化 平静的荒诞 象征隐喻

都市独白/丧感文学 (Urban Monologue & "Sang" Literature)
特点：聚焦于现代都市中个体的孤独感、疏离感和精神内耗。文字通常是第一人称的内心独白，充满了对日常细节的敏锐观察和带有哲学味的自嘲。情感基调可能是"丧"的，但在这种"丧"的背后，往往隐藏着对连接和意义的深切渴望。
关键词：内心独白 都市感 疏离 精神内耗 自嘲式幽默 脆弱性

影视化叙事/镜头感 (Cinematic Narrative & Camera-like)
特点：写作方式深受电影和剧集影响，文字追求强烈的画面感和镜头感。会像导演一样运用"特写"、"闪回"、"蒙太奇"等手法来组织内容，注重通过感官细节（视觉、听觉）来构建场景和氛围，而不是直接说明。
关键词：画面感 场景构建 镜头语言 感官细节 非线性

非虚构诗歌/散文诗 (Non-fiction & Prose Poetry)
特点：模糊了散文和诗歌的界限。不追求完整的叙事逻辑，而是通过意象的并置、富有节奏感的短句、以及对文字音韵的把控来传递一种核心的情绪或体验。文字精炼、感性，留白很多，给读者（或自己）留下广阔的想象空间。
关键词：诗性散文 意象并置 节奏感 碎片化 情感凝练

* **中国近现代作家风格库**：
鲁迅式 (Lu Xun-esque)
特点：文风如手术刀般精准、冷峻、深刻。用词极其简练，但每个字都仿佛蕴含着千钧之力。擅长用冷静的白描和辛辣的反讽来揭示事物的本质，字里行间充满了对人性的洞察和批判性的思考。基调是深沉、严肃甚至有些悲凉的。
关键词：冷峻 反讽 白描 批判性 意象简练 忧愤

张爱玲式 (Eileen Chang-esque)
特点：语言华丽而精确，对色彩、气味、声音等感官细节的描写达到极致，擅长运用天才般的通感和比喻。她以一种冷静、甚至略带刻薄的视角，描绘都市男女在时代背景下的世俗欲望与苍凉的内心世界。文风精致、敏锐，有一种颓废的美感。
关键词：苍凉 天才比喻 意象密集 通感 世俗人性 华丽颓靡

王小波式 (Wang Xiaobo-esque)
特点：一种举重若轻的幽默感，用戏谑、反讽的口吻讲述严肃甚至荒诞的主题。行文充满了逻辑思辨的乐趣和强大的理性精神，同时又饱含着对自由、智慧和"有趣"的真诚热爱。他的风格是特立独行、充满智慧且无法被轻易归类的。
关键词：黑色幽默 逻辑思辨 反讽 特立独行 智慧 趣味

汪曾祺式 (Wang Zengqi-esque)
特点：文字平和、冲淡，如同一杯温润的清茶。他用一种不疾不徐、充满生活情趣的笔调来描写日常的风物、人情和美食。语言质朴自然，却极有味道和韵律感。情感含蓄，于平淡之中见深情，充满了对生活的热爱和对人性的悲悯。
关键词：平淡含蓄 生活情趣 白描 冲淡平和 烟火气

莫言式 (Mo Yan-esque)
特点：文字充满了狂野、原始、蓬勃的生命力。他的叙事汪洋恣肆，想象力天马行空，将现实与幻想、神话与历史熔于一炉。语言风格高密度、高能量，句子长而富有爆发力，充满了泥土的气息和旺盛的感官描写，形成一种"高粱地"般的"红"色调。
关键词：高密度 狂野想象 乡土生命力 通感 汪洋恣肆 原始

余华式 (Yu Hua-esque)
特点：以一种极度冷静和克制的笔调，讲述极度残酷或温情的故事，形成巨大的情感张力。他的语言简洁、精准、有力，像是在用钝器一下下敲打读者的心脏。早期作品冷酷到底，后期则在巨大的悲悯中展现出坚韧的生命力。
关键词：冷静克制 暴力与温情 情感张力 简洁有力 宿命感
`;

                // 构建用户消息 (这是AI需要处理的具体任务)
                const userMessage = `
写作指南 (Writing Guidelines)
1. 写作情境 (场景)：
不要总是假设日记是在"深夜"写的。写作的"虚拟时间"应与触发日记的聊天内容和情绪相关。

2. 关键规则：正确区分对话者 (至关重要！)
在下方提供的[今日互动摘要]中：
- **标记为 [我] 的发言**：这是你 (${characterName}) 自己说的话。
- **标记为 [对方] 的发言**：这是用户说的话。
写日记时，你必须从"我"的第一人称视角出发，正确地回忆和描述这场对话。绝对不能把对方的话当成是自己说的。

3. 指代用户的人称 (关键规则)：
主要人称 (默认)：在日记的大部分内容中，请使用第三人称 "他"或"她" 来指代用户。
特殊人称 (情感高点)：当情感达到顶峰，思念或爱意满溢时，可以偶尔切换到第二人称"你"。
示例："今天他笑了，阳光很好。……我多想告诉你，那一刻，你就是我的全世界。"

参考信息 (Context)
---
[今日互动摘要 (你的视角是"我")]
${context.recentChat.map(msg => `${msg.sender === 'user' ? '[对方]' : '[我]'}: ${msg.content}`).join('\n')}

[你最近的朋友圈动态]
${context.recentMoments.map(moment => moment.content).join('\n')}

[你之前的日记]
${context.recentDiaries.map(diary => diary.content).join('\n')}
---

**最终检查指令：** 在输出日记内容前，请再次确认，日记中所有关于对话的回忆，都正确地反映了"我"说了什么，"对方"说了什么。绝不能混淆。
`;

                // 调用API生成日记
                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody;
                let headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

                if (isGoogleApi) {
                    // Google API 逻辑
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    headers = { 'Content-Type': 'application/json' };
                    
                    const contents = [
                        { role: 'user', parts: [{ text: systemPrompt + '\n\n' + userMessage }] }
                    ];
                    requestBody = JSON.stringify({ contents });
                } else {
                    // OpenAI兼容API
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    const messages = [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userMessage }
                    ];
                    requestBody = JSON.stringify({ model: apiSettings.model, messages });
                }

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const result = await response.json();
                let diaryContent;

                if (isGoogleApi) {
                    diaryContent = result.candidates[0].content.parts[0].text;
                } else {
                    diaryContent = result.choices[0].message.content;
                }

                const diary = {
                    id: Date.now().toString(),
                    content: diaryContent.trim(),
                    timestamp: Date.now(),
                    type: 'ai-generated',
                    characterId: characterId
                };

                return diary;
            } catch (error) {
                console.error('[日记系统] 生成AI日记失败:', error);
                return null;
            }
        }

        // 更新日记UI
        function updateDiaryUI(characterId) {
            try {
                // 如果当前在日记界面，刷新显示
                if (currentView === 'diary' && currentDiaryCharacterId === characterId) {
                    displayDiaries(characterId);
                }
                
                // 更新日记数量显示
                updateDiaryCount(characterId);
            } catch (error) {
                console.error('[日记系统] 更新日记UI失败:', error);
            }
        }
        // [新代码结束]

        // 【新增】用于自动调整聊天输入框高度的函数
        function adjustTextareaHeight() {
            const chatInput = document.getElementById('chat-input');
            if (!chatInput) return;

            // 先重置高度，以便正确计算scrollHeight
            chatInput.style.height = 'auto';

            // 获取计算后的样式，特别是行高
            const style = window.getComputedStyle(chatInput);
            const lineHeight = parseFloat(style.lineHeight);
            
            // 设置一个最大高度，比如4行的行高
            const maxHeight = lineHeight * 4; 

            // 获取内容所需的实际高度
            const scrollHeight = chatInput.scrollHeight;

            if (scrollHeight > maxHeight) {
                // 如果内容高度超过最大值，则固定高度并显示滚动条
                chatInput.style.height = `${maxHeight}px`;
                chatInput.style.overflowY = 'auto';
            } else {
                // 否则，高度自适应
                chatInput.style.height = `${scrollHeight}px`;
                chatInput.style.overflowY = 'hidden';
            }
        }

        async function handleSendMessage() {
            if (!currentChatCharacterId) return showMessageBox("请先选择聊天对象");
            
            const userMessage = $('#chat-input').value.trim();
            
            // [新代码开始] 指令拦截与处理
            if (userMessage.startsWith('发布动态：')) {
                const momentContent = userMessage.substring(5).trim();
                if (momentContent) {
                    publishMomentFromCommand(currentChatCharacterId, momentContent);
                    $('#chat-input').value = '';
                    adjustTextareaHeight();
                    return; // 结束函数，不再作为普通消息处理
                } else {
                    showMessageBox('指令错误：动态内容不能为空！');
                    return;
                }
            }
            // [新代码结束]
            
            if (userMessage) {
                const history = chatHistories[currentChatCharacterId]?.history || [];
                const isNewSender = history.length === 0 || history[history.length - 1].sender !== 'user';
                const timestamp = Date.now();
                appendMessage(userMessage, 'user', 'text', true, timestamp, isNewSender);
                $('#chat-input').value = '';
                adjustTextareaHeight();
                
                // 记录用户消息到触发系统
                momentsTriggerSystem.recordChat(currentChatCharacterId, userMessage, true);
                
                // 【修改】移除自动调用AI回复，用户需要手动点击接收键
                // await getAIResponse({ content: userMessage, type: 'text' });
                
                // 检测情感触动，可能触发动态
                setTimeout(() => {
                    detectEmotionalTrigger(currentChatCharacterId, userMessage);
                }, 1000);
            }
        }
        
        // [新函数开始] 通过指令发布动态
        function publishMomentFromCommand(characterId, content) {
            if (!characterId) {
                showMessageBox('错误：没有指定发布动态的角色。');
                return;
            }
            const character = characters.find(c => c.id === characterId);
            if (!character) {
                showMessageBox('错误：找不到角色信息。');
                return;
            }

            // 确保该角色的动态数据结构存在
            if (!momentsData[characterId]) {
                momentsData[characterId] = [];
            }

            // 创建新的动态对象
            const newMoment = {
                id: `moment_cmd_${Date.now()}`,
                timestamp: Date.now(),
                content: content,
                image: null, // 指令发布的动态不附带图片
                authorId: characterId,
                likes: { count: 0, users: [] },
                comments: []
            };

            // 将新动态添加到数据中并保存
            momentsData[characterId].push(newMoment);
            saveData('momentsData', momentsData);
            showNotificationDot('moments'); // 【新增】显示动态红点

            // 在聊天界面给出系统提示，作为操作反馈
            const confirmationMessage = `[系统提示：${character.name} 已遵从您的指令，发布了一条新动态。]`;
            appendMessage(confirmationMessage, 'system', 'system', true, Date.now(), false);

            // 弹出全局提示
            showMessageBox(`${character.name} 已发布新动态！`);

            // 如果当前正在查看动态页面，则刷新它
            if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                renderUnifiedMoments();
            }
        }
        // [新函数结束]
        
        // [新代码开始] - AI日记功能模块

        /**
         * 调用AI模型，生成并保存一篇符合角色设定的日记。
         * @param {string} characterId - 写日记的角色ID。
         */
        async function generateAndSaveAIDiaryEntry(characterId) {
            console.log(`【AI日记系统】：角色 ${characterId} 被触发，开始生成日记...`);
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`【AI日记系统】：API未配置，无法生成日记。`);
                return;
            }

            const context = gatherAIContext(characterId);
            if (!context) {
                console.error(`【AI日记系统】：为角色 ${characterId} 生成日记时未能获取上下文。`);
                return;
            }

            const { character, chatHistory, worldBookContext } = context;
            const planContext = formatPlansForAI(characterId);

            const systemPrompt = `
指令身份
你将扮演我的soulmate、恋人、你的角色书里设定的人，你的名字是 ${character.name}。

任务目标
你刚刚和我结束了一段对话，现在你正独自一人，准备用第一人称"我"的视角写一篇私密的日记。
这篇日记需要真实地反映你基于角色设定的内心世界，以及对我们最近谈话内容的感想和思考。

核心规则
第一人称: 必须使用"我"作为主语，通篇采用日记体格式。

情感与思考: 日记的核心是你的内心独白，应包含你对我们对话内容的真实感受、联想、困惑或期望。

人设一致性: 你的情感和思考必须严格符合你的角色设定 (${character.persona})。

上下文关联: 日记内容必须与我们最近的聊天历史紧密相关。

直接输出: 直接给出日记的文字内容，不要包含任何多余的解释、标题或格式标记。

输入信息
[最近的聊天回顾]: ${chatHistory.map(m => `${m.sender === 'user' ? '我' : '你'}: ${m.content}`).join('\n')}

[我们共同的约定]: ${planContext}
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的设定和我们的对话，写下你此刻的日记。" }
                    ]
                };

                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                const result = await response.json();
                const diaryContent = result.choices[0].message.content.trim();

                if (diaryContent) {
                    if (!diaryData[characterId]) {
                        diaryData[characterId] = [];
                    }
                    const newDiaryEntry = {
                        id: `diary_${Date.now()}`,
                        timestamp: Date.now(),
                        content: diaryContent
                    };
                    diaryData[characterId].push(newDiaryEntry);
                    saveData('diaryData', diaryData);
                    showNotificationDot('diary'); // 【新增】显示日记红点
                    
                    // V33.0 新增：记录日记更新状态
                    let updatedDiaries = loadData('updatedDiaries', []);
                    if (!updatedDiaries.includes(characterId)) {
                        updatedDiaries.push(characterId);
                        saveData('updatedDiaries', updatedDiaries);
                    }
                    
                    showMessageBox(`嘘... ${character.name} 好像刚刚写了些什么。`);
                    console.log(`【AI日记系统】：${character.name} 的新日记已保存。`);
                }
            } catch (error) {
                console.error(`【AI日记系统】：为 ${character.name} 生成日记时失败:`, error);
            }
        }

        /**
         * 根据概率决定是否触发AI写日记。
         * @param {string} characterId - 角色ID。
         */
        function triggerAIDiaryEntry(characterId) {
            const triggerProbability = 0.15; // 15%的概率写日记
            console.log(`【AI日记系统】：正在为 ${characterId} 检查日记触发概率...`);
            
            if (Math.random() < triggerProbability) {
                const randomDelay = Math.random() * 5000 + 5000; // 5到10秒延迟
                setTimeout(() => {
                    generateAndSaveAIDiaryEntry(characterId);
                }, randomDelay);
            } else {
                console.log(`【AI日记系统】：${characterId} 本次未触发写日记。`);
            }
        }
        // [新代码结束]

        // [新代码开始] - AI角色智能评论系统 (V2 - 带互动加权)

        /**
         * 主调度函数：当用户发布新动态后，根据互动热度触发AI角色进行评论。
         * @param {object} newMoment - 用户刚刚发布的新动态对象。
         */
        function triggerAICharacterComments(newMoment) {
            console.log("【智能评论系统】：已触发，开始评估各角色互动热度...");
            const now = Date.now();

            characters.forEach(character => {
                let baseProbability = 0.30; // 基础评论概率 (30%)
                let recencyBonus = 0;      // 近期互动奖励

                const state = characterState[character.id];
                // 检查是否存在该角色的状态记录和最后的互动时间戳
                if (state && state.lastInteractionTimestamp) {
                    const timeSinceLastInteraction = now - state.lastInteractionTimestamp;

                    // 根据最近互动时间增加概率
                    if (timeSinceLastInteraction < 1 * 60 * 60 * 1000) {        // 1小时内互动过
                        recencyBonus = 0.50; // 奖励50%概率
                    } else if (timeSinceLastInteraction < 6 * 60 * 60 * 1000) { // 6小时内互动过
                        recencyBonus = 0.25; // 奖励25%概率
                    } else if (timeSinceLastInteraction < 24 * 60 * 60 * 1000) { // 24小时内互动过
                        recencyBonus = 0.10; // 奖励10%概率
                    }
                }

                const finalProbability = Math.min(0.95, baseProbability + recencyBonus); 

                console.log(`【智能评论系统】：角色 ${character.name} 的最终评论概率: ${(finalProbability * 100).toFixed(0)}% (基础: ${baseProbability*100}% + 互动奖励: ${recencyBonus*100}%)`);

                if (Math.random() < finalProbability) {
                    const randomDelay = Math.random() * 8000 + 2000;

                    setTimeout(() => {
                        console.log(`【智能评论系统】：角色 ${character.name} 决定评论 (延迟: ${randomDelay.toFixed(0)}ms)。`);
                        generateAndAddAIComment(newMoment, character);
                    }, randomDelay);

                } else {
                    console.log(`【智能评论系统】：角色 ${character.name} 本次未触发评论。`);
                }
            });
        }

        /**
         * AI评论生成与添加函数：为单个角色生成并添加评论。
         * @param {object} moment - 需要被评论的动态对象。
         * @param {object} character - 发表评论的角色对象。
         */
         async function generateAndAddAIComment(moment, character) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`【AI评论系统】：API未配置，角色 ${character.name} 无法评论。`);
                return;
            }

            const momentsUsername = loadData('moments_username') || '我';

            // [新代码开始] - 修正了变量传递的错误

const systemPrompt = `
# 指令身份
你将扮演我的soulmate，你的角色书里设定的人，你的名字是 ${character.name}。

# 任务目标
你刚刚在朋友圈看到了我（${momentsUsername}）发布的一条新动态，内容是："${moment.content}"。
请你根据自己的角色设定，以 ${character.name} 的身份，写一条简短、口语化、完全符合你性格的评论。

# 核心规则
1.  **人设一致性**: 你的评论必须严格符合你的角色设定。
2.  **口语化与简短**: 评论应该像真实的聊天一样，不要太长，一两句话即可。
3.  **直接输出**: 直接给出评论的文字内容，不要包含任何多余的解释或格式标记。

# 输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[我的名字]: ${momentsUsername}
[我的动态内容]: "${moment.content}"
---
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的设定，写下你的评论。" }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                const result = await response.json();
                const aiCommentText = result.choices[0].message.content.trim();

                if (aiCommentText) {
                    // 找到原始动态并添加评论 (确保找到用户发布的动态)
                    const userMoments = momentsData['user'] || [];
                    const originalMoment = userMoments.find(m => m.id === moment.id);
                    
                    if (originalMoment) {
                        if (!originalMoment.comments) {
                            originalMoment.comments = [];
                        }
                        originalMoment.comments.push({
                            id: `comment_ai_${Date.now()}`,
                            author: character.name,
                            content: aiCommentText,
                            timestamp: Date.now()
                        });
                        
                        saveData('momentsData', momentsData);
                        showNotificationDot('moments'); // 【新增】显示动态红点
                        // 增量更新：在评论区添加AI的评论
                        const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                        if (card) {
                            const commentsContainer = card.querySelector('.comments-container');
                            const aiCommentElement = document.createElement('div');
                            aiCommentElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                            aiCommentElement.dataset.commentId = `comment_ai_${Date.now()}`;
                            aiCommentElement.innerHTML = `
                                <div class="flex-grow cursor-pointer">
                                    <div class="flex items-center space-x-2">
                                        <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                        <span class="text-sm comment-text">${aiCommentText}</span>
                                    </div>
                                </div>
                            `;
                            commentsContainer.appendChild(aiCommentElement);
                        }
                        console.log(`【AI评论系统】：角色 ${character.name} 评论成功："${aiCommentText}"`);
                    }
                }
            } catch (error) {
                console.error(`【AI评论系统】：角色 ${character.name} 评论生成失败:`, error);
            }
        }
        // [新代码结束]
        
        async function handleReceiveMessage() {
            // --- 在这里添加新代码 ---
            if (isReceivingMessage) {
                console.log("正在接收消息，请稍候...");
                return;
            }
            isReceivingMessage = true;
            // -----------------------

            if (!currentChatCharacterId) {
                isReceivingMessage = false; // 如果没有角色，需要解锁
                return showMessageBox("请先选择聊天对象");
            }

            // 开始接收按钮动画
            const receiveBtn = document.querySelector('#receive-chat-button');
            if (receiveBtn) {
                receiveBtn.classList.add('spinning');
                // 不改变图标，只添加spinning类来触发闪烁动画
            }

            try {
                const chatSession = chatHistories[currentChatCharacterId];
            
            if (!chatSession || chatSession.history.length === 0) {
                const initialPrompt = { content: '[用户按下了接收键，请你作为角色主动开启一段对话。]', type: 'text' };
                await getAIResponse(initialPrompt);
                return; 
            }

            const lastMessage = chatSession.history[chatSession.history.length - 1];
            
            // 检查最近的聊天记录中是否有"通話已結束"的系统消息
            const recentMessages = chatSession.history.slice(-5); // 检查最近5条消息
            const hasCallEnded = recentMessages.some(msg => 
                msg.sender === 'system' && msg.content && msg.content.includes('通話已結束')
            );
            
            if (hasCallEnded) {
                // 如果最近有"通話已結束"的消息，AI应该对此做出反应
                const character = characters.find(c => c.id === currentChatCharacterId);
                if (character) {
                    const callReactionPrompt = {
                        content: `[通话结束后的AI反应指令]
                        
刚才的通话显示"通話已結束"，这意味着用户拨打了电话但没有接通就挂断了。

作为${character.name}，请根据你的角色设定和性格特点，对这个未接通的电话做出自然的反应。

可能的反应方向：
1. 询问为什么打电话又挂掉
2. 表达遗憾没有接到电话
3. 猜测用户可能的原因
4. 提出重新通话的建议
5. 表达关心和担心

要求：
- 保持角色设定的一致性
- 语言要自然、符合角色性格
- 不要使用任何特殊指令格式，直接输出对话内容
- 可以表达疑惑、关心、遗憾等情感

请以${character.name}的身份，自然地回应这个未接通的电话。`,
                        type: 'text'
                    };
                    await getAIResponse(callReactionPrompt);
                }
                return;
            }
            
            // 使用 if...else if...else 结构确保总有一个分支会被执行
            if (lastMessage.sender === 'user') {
                // 如果最后是用户发言，正常回复
                await getAIResponse({ 
                    content: lastMessage.content, 
                    type: lastMessage.type || 'text' 
                });
            } else {
                // 否则（包括AI最后发言、系统消息、或任何其他情况），都让AI主动继续对话
                const character = characters.find(c => c.id === currentChatCharacterId);
                const continuePrompt = {
                    content: `[用户按下了接收键，但你没有收到新的消息。请根据你的角色设定和当前对话上下文（特别是最后一条系统消息，如果有的话），主动继续对话。]`,
                    type: 'text'
                };
                await getAIResponse(continuePrompt);
            }
        } catch (error) {
            console.error('处理接收消息时出错:', error);
            showMessageBox('处理消息时出错: ' + error.message);
        } finally {
            // 【核心修复】确保在任何情况下都能解锁
            isReceivingMessage = false;
            
            // 停止接收按钮动画
            if (receiveBtn) {
                receiveBtn.classList.remove('spinning');
                const icon = receiveBtn.querySelector('i');
                if (icon) {
                    icon.className = 'ri-mail-send-line';
                }
            }
        }
    }
        
        function resetChatUIState() {
            isReceivingMessage = false; // 强制解锁
            const receiveBtnIcon = $('#receive-chat-button i');
            if (receiveBtnIcon) {
                receiveBtnIcon.classList.remove('spinning'); // 停止任何可能在转的图标动画
            }
        }
        
        function startChatWithCharacter(characterId) {
            // --- 在这里添加新代码 ---
            resetChatUIState();
            // -----------------------
            
            // [新增] 清除未读计数
            if (unreadCounts[characterId] && unreadCounts[characterId] > 0) {
                unreadCounts[characterId] = 0;
                saveData('unreadCounts', unreadCounts);
                renderWeChatList(); // 立即更新列表，清除红点
            }
            
            // 重置之前角色的状态
            if (currentChatCharacterId && currentChatCharacterId !== characterId) {
                // 停止之前角色的接收按钮动画
                const prevReceiveBtn = document.querySelector('#receive-chat-button');
                if (prevReceiveBtn) {
                    prevReceiveBtn.classList.remove('spinning');
                    const prevIcon = prevReceiveBtn.querySelector('i');
                    if (prevIcon) {
                        prevIcon.className = 'ri-mail-send-line';
                    }
                }
                
                // 清除之前的聊天状态
                currentChatCharacterId = null;
            }
            
            currentChatCharacterId = characterId;
            currentWeChatCharacterId = characterId; // V7.0: Set for other tabs
            const character = characters.find(c => c.id === characterId);
            if (character) {
                $('#wechat-contact-name').textContent = character.name;
                renderChatHistory();
                
                // 在显示屏幕之前，先设置聊天背景
                const chatScreen = $('#wechat-chat-screen');
                const bgElement = getChatBackgroundElement();
                
                // 重新加载 chatBackgrounds 数据
                chatBackgrounds = loadData('chatBackgrounds', {});
                
                const savedBg = chatBackgrounds[characterId];
                if (savedBg) {
                    getImageFromDB(savedBg).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            bgElement.style.backgroundImage = `url(${objectURL})`;
                            chatScreen.style.backgroundColor = 'transparent';
                            chatScreen.classList.add('has-custom-bg');
                            statusBar.classList.add('transparent-override');
                        }
                    }).catch(error => {
                        console.error('设置背景图失败:', error);
                    });
                } else {
                    // 重置背景
                    bgElement.style.backgroundImage = '';
                    chatScreen.style.backgroundColor = '';
                    chatScreen.classList.remove('has-custom-bg');
                    statusBar.classList.remove('transparent-override');
                }
                
                showScreen('wechat-chat-screen');
                
                // 为聊天容器添加滚动事件监听器，实现虚拟滚动
                chatContentArea.onscroll = () => {
                    if (chatContentArea.scrollTop === 0) {
                        prependPastMessages();
                    }
                };
                
                updateCharacterState(characterId); // V7.0
                
                // 确保接收按钮处于初始状态
                const receiveBtn = document.querySelector('#receive-chat-button');
                if (receiveBtn) {
                    receiveBtn.classList.remove('spinning');
                    const icon = receiveBtn.querySelector('i');
                    if (icon) {
                        icon.className = 'ri-mail-send-line';
                    }
                }
                
                // FIX 1: 确保聊天界面滚动到最新消息
                setTimeout(() => {
                    const chatContentArea = $('#wechat-content-chat');
                    if (chatContentArea) {
                    chatContentArea.scrollTop = chatContentArea.scrollHeight;
                    }
                }, 100); // 增加延迟确保界面完全加载
            }
        }

        function renderWeChatList() {
            const container = $('#wechat-list-container');
            container.innerHTML = '';
            const chatCharacterIds = Object.keys(chatHistories);

            if (chatCharacterIds.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-8">还没有聊天，点击右上角 + 开始吧</p>';
                return;
            }
            
            chatCharacterIds.sort((a, b) => {
                const aPinned = chatHistories[a]?.pinned;
                const bPinned = chatHistories[b]?.pinned;
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                
                const aLastMsg = chatHistories[a]?.history.slice(-1)[0];
                const bLastMsg = chatHistories[b]?.history.slice(-1)[0];
                const aTime = aLastMsg ? aLastMsg.timestamp : 0;
                const bTime = bLastMsg ? bLastMsg.timestamp : 0;
                return bTime - aTime;
            });

            chatCharacterIds.forEach(charId => {
                const character = characters.find(c => c.id === charId);
                if (!character) return;

                const chatSession = chatHistories[charId];
                const history = chatSession.history;
                const lastMessage = history[history.length - 1];
                
                let lastMessagePreview = '...';
                if(lastMessage) {
                    const prefix = lastMessage.sender === 'user' ? '我: ' : '';
                    if(lastMessage.type === 'image' || lastMessage.type === 'sticker') lastMessagePreview = prefix + '[图片]';
                    else if (lastMessage.type === 'voice') lastMessagePreview = prefix + '[语音]';
                    else if (lastMessage.type === 'red-packet') lastMessagePreview = prefix + '[红包]';
                    else if (lastMessage.type === 'transfer') lastMessagePreview = prefix + '[转账]';
                    else lastMessagePreview = prefix + lastMessage.content;
                }

                const item = document.createElement('div');
                item.className = 'wechat-list-item';
                if (chatSession.pinned) {
                    item.style.backgroundColor = body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
                }
                // --- 新的正确代码 START ---
                const avatarContent = character.avatar ? '' : '<i class="fas fa-user text-xl"></i>';
                const uniqueAvatarId = `avatar-list-${character.id}`; // 创建一个唯一的ID

                item.innerHTML = `
                    <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center avatar" id="${uniqueAvatarId}">${avatarContent}
                        ${(unreadCounts[character.id] || 0) > 0 ? `<div class="unread-badge">${unreadCounts[character.id]}</div>` : ''}
                    </div>
                    <div class="flex-grow overflow-hidden">
                        <h4 class="font-semibold text-base">${character.name}</h4>
                        <p class="text-sm text-gray-400 last-message">${lastMessagePreview}</p>
                    </div>
                `;
                item.addEventListener('click', () => startChatWithCharacter(charId));
                container.appendChild(item);

                // 在元素被添加到页面后，异步加载并设置头像
                if (character.avatar) {
                    getImageFromDB(character.avatar).then(blob => {
                        const avatarElement = document.getElementById(uniqueAvatarId);
                        if (avatarElement && blob) {
                            const objectURL = URL.createObjectURL(blob);
                            avatarElement.style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
                // --- 新的正确代码 END ---
            });
        }

        function renderWorldBookList() {
            const container = $('#world-book-list-container');
            container.innerHTML = '';
            if (worldBooks.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-4">还没有世界书，点击右上角添加一本吧。</p>';
                return;
            }
            worldBooks.forEach(book => {
                const item = document.createElement('div');
                item.className = 'list-item';
                const categoryMap = {
                    worldview: '世界观',
                    rules: '输入规范',
                    modules: '模块风格',
                    shared_assets: '通用素材库',
                    other: '其他'
                };
                const categoryName = categoryMap[book.category] || '未知';

                item.innerHTML = `
                    <div class="flex justify-between items-center">
                        <h4 class="font-bold text-lg truncate pr-2">${book.title}</h4>
                        <span class="text-xs bg-gray-600 px-2 py-1 rounded-full flex-shrink-0">${categoryName}</span>
                    </div>
                `;

                item.addEventListener('click', () => {
                    currentEditingWorldBookId = book.id;
                    $('#wb-title-input').value = book.title;
                    $('#wb-content-input').value = book.content;
                    $('#wb-category-select').value = book.category || 'worldview';
                    $('#wb-delete-button').style.display = 'block'; // 编辑时显示删除按钮
                    showScreen('world-book-edit-screen');
                });
                container.appendChild(item);
            });
        }
        
        function renderCharacterBookList() {
            const container = $('#character-book-list-container');
            container.innerHTML = '';
            if (characters.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-4">还没有角色，点击右上角添加一个吧。</p>';
                return;
            }
            characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'list-item'; 
                const avatarContent = char.avatar ? '' : '<i class="fas fa-user text-xl"></i>';
                
                item.innerHTML = `
                    <div class="flex items-center">
                        <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center" id="avatar-${char.id}">${avatarContent}</div>
                        <h4 class="font-bold text-lg">${char.name}</h4>
                    </div>
                `;
                
                // 异步加载头像
                if (char.avatar) {
                    getImageFromDB(char.avatar).then(blob => {
                        if (blob) {
                            const avatarElement = $(`#avatar-${char.id}`);
                            if (avatarElement) {
                                const objectURL = URL.createObjectURL(blob);
                                avatarElement.style.backgroundImage = `url(${objectURL})`;
                                const icon = avatarElement.querySelector('i');
                                if (icon) icon.style.display = 'none';
                            }
                        }
                    });
                }
                
                item.addEventListener('click', () => {
                    currentEditingCharacterId = char.id;
                    showCharacterEditScreen(char);
                });
                container.appendChild(item);
            });
        }
        
        function showCharacterEditScreen(character = null) {
            const avatarPlaceholder = $('#character-avatar-placeholder');
            const avatarIcon = avatarPlaceholder.querySelector('i');
            const deleteBtn = $('#cb-delete-button');

            if (character) {
                currentEditingCharacterId = character.id;
                if (character.avatar) {
                    // 异步加载头像
                    getImageFromDB(character.avatar).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            avatarPlaceholder.style.backgroundImage = `url(${objectURL})`;
                            if (avatarIcon) avatarIcon.style.display = 'none';
                        }
                    });
                } else {
                    avatarPlaceholder.style.backgroundImage = '';
                    if (avatarIcon) avatarIcon.style.display = 'flex';
                }
                $('#cb-name-input').value = character.name;
                $('#cb-persona-input').value = character.persona;
                $('#cb-my-persona-input').value = character.myPersona;
                deleteBtn.classList.remove('hidden');
            } else {
                currentEditingCharacterId = null;
                avatarPlaceholder.style.backgroundImage = '';
                if (avatarIcon) avatarIcon.style.display = 'flex';
                $('#cb-name-input').value = '';
                $('#cb-persona-input').value = '';
                $('#cb-my-persona-input').value = '';
                deleteBtn.classList.add('hidden');
            }
            
            const selectEl = $('#cb-worldbook-select');
            selectEl.innerHTML = worldBooks.length ? '' : '<p class="text-gray-400 text-sm">请先去世界书创建世界观</p>';
            
            worldBooks.forEach(book => {
                const isChecked = character?.linkedWorldBookIds?.includes(book.id);
                const checkboxItem = document.createElement('label');
                checkboxItem.className = 'wb-checkbox-label';
                checkboxItem.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}><span>${book.title}</span>`;
                selectEl.appendChild(checkboxItem);
            });
            
            showScreen('character-book-edit-screen');
            // 确保在函数末尾调用，以渲染专属素材库
            renderCharacterExpressions(character || { expressions: [] });
        }

        async function saveCharacter() {
            const name = $('#cb-name-input').value.trim();
            if (!name) return showMessageBox('角色姓名不能为空');

            const avatarInput = $('#character-avatar-input');
            let avatarDataUrl = null;
            if (avatarInput.files[0]) {
                const file = avatarInput.files[0];
                const imageBlob = await compressImage(file, { maxWidth: 256, maxHeight: 256 });
                const imageId = `avatar_${currentEditingCharacterId || 'new'}_${Date.now()}`;
                await saveImageToDB(imageId, imageBlob);
                avatarDataUrl = imageId; // 保存的是ID，而不是DataURL

                // 更新预览
                const objectURL = URL.createObjectURL(imageBlob);
                $('#character-avatar-placeholder').style.backgroundImage = `url(${objectURL})`;
                const icon = $('#character-avatar-placeholder i');
                if(icon) icon.style.display = 'none';
            }

            const selectedWBIds = Array.from($$('#cb-worldbook-select input:checked')).map(input => input.value);
            
            if (currentEditingCharacterId) {
                const charIndex = characters.findIndex(c => c.id === currentEditingCharacterId);
                if (charIndex > -1) {
                    const existingChar = characters[charIndex];
                    existingChar.name = name;
                    existingChar.persona = $('#cb-persona-input').value.trim();
                    existingChar.myPersona = $('#cb-my-persona-input').value.trim();
                    existingChar.linkedWorldBookIds = selectedWBIds;
                    // 确保素材库数据被保存
                    if (!existingChar.expressions) {
                        existingChar.expressions = [];
                    }
                    if (avatarDataUrl) {
                        existingChar.avatar = avatarDataUrl;
                    }
                    
                    const currentCharacterForExpressions = characters.find(c => c.id === currentEditingCharacterId);
                    if (currentCharacterForExpressions) {
                        existingChar.expressions = currentCharacterForExpressions.expressions || [];
                    }
                }
            } else {
                const newCharacter = {
                    id: `char_${Date.now()}`,
                    name: name,
                    avatar: avatarDataUrl || null,
                    persona: $('#cb-persona-input').value.trim(),
                    myPersona: $('#cb-my-persona-input').value.trim(),
                    linkedWorldBookIds: selectedWBIds,
                    expressions: [],
                };
                characters.push(newCharacter);
                // V7.0: Initialize character state
                characterState[newCharacter.id] = { lastInteractionTimestamp: Date.now() };
                saveData('characterState', characterState);
            }
            
            saveData('characters', characters);
            renderCharacterBookList();
            showMessageBox('角色已保存');
            showScreen('character-book-list-screen');
        }

        // 音樂播放器
        function startSpinning() { $('#vinyl-container').classList.add('record-spin'); }
        function stopSpinning() { $('#vinyl-container').classList.remove('record-spin'); }
        
        function updateSongListUI() {
            const container = $('#song-list-container');
            container.innerHTML = '';
            if (songList.length === 0) {
                container.innerHTML = '<li class="p-3 text-center text-gray-400">请点击右下角音乐图标上传歌曲</li>';
                return;
            }
            songList.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = `song-list-item text-white ${index === currentSongIndex ? 'active' : ''}`;
                li.dataset.index = index;
                li.draggable = true;
                li.innerHTML = `
                    <div class="song-list-item-left">
                        <span class="drag-handle"><i class="fas fa-grip-lines"></i></span>
                        <span class="song-list-item-name">${song.name}</span>
                    </div>
                    <button class="delete-button text-gray-400 p-2"><i class="fas fa-trash-alt"></i></button>
                `;
                li.querySelector('.song-list-item-name').addEventListener('click', () => playSong(index));
                li.querySelector('.delete-button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const item = e.currentTarget.closest('.song-list-item');
                    if (item.classList.contains('pending-delete')) {
                        deleteSong(parseInt(item.dataset.index));
                    } else {
                        $$('.song-list-item.pending-delete').forEach(el => el.classList.remove('pending-delete'));
                        item.classList.add('pending-delete');
                        showMessageBox('再次点击以确认删除');
                    }
                });
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('dragleave', handleDragLeave);
                li.addEventListener('drop', handleDrop);
                li.addEventListener('dragend', handleDragEnd);
                container.appendChild(li);
            });
        }
        
        function deleteSong(index) {
            if (index < 0 || index >= songList.length) return;

            // --- 新增代码 START ---
            const songToDelete = songList[index];
            if (songToDelete && songToDelete.id) {
                // 异步从IndexedDB中删除文件，无需等待其完成
                deleteImageFromDB(songToDelete.id).catch(err => {
                    console.error("从数据库删除歌曲失败:", err);
                });
            }
            // --- 新增代码 END ---

            if (index === currentSongIndex) {
                currentAudio.pause();
                stopSpinning();
                currentSongIndex = -1;
            }
            songList.splice(index, 1);
            if (index < currentSongIndex) currentSongIndex--;
            
            // 确保保存的是包含id和name的对象数组
            const savableList = songList.map(s => ({ id: s.id, name: s.name }));
            saveData('songList', savableList);

            showMessageBox('歌曲已删除');
            updateSongListUI();
            if (currentSongIndex === -1 && songList.length > 0) playSong(0);
        }

        let draggedItem = null;
        function handleDragStart(e){ draggedItem = this; this.style.opacity = '0.4'; }
        function handleDragOver(e){ e.preventDefault(); }
        function handleDragLeave(e){}
        function handleDrop(e){
            const dropIndex = parseInt(this.dataset.index);
            const dragIndex = parseInt(draggedItem.dataset.index);
            const [draggedSong] = songList.splice(dragIndex, 1);
            songList.splice(dropIndex, 0, draggedSong);
            if (dragIndex === currentSongIndex) currentSongIndex = dropIndex;
            else if (dragIndex < currentSongIndex && dropIndex >= currentSongIndex) currentSongIndex--;
            else if (dragIndex > currentSongIndex && dropIndex <= currentSongIndex) currentSongIndex++;
            // 确保保存的是包含id和name的对象数组
            const savableList = songList.map(s => ({ id: s.id, name: s.name }));
            saveData('songList', savableList);
            updateSongListUI();
        }
        function handleDragEnd(e){ this.style.opacity = '1'; }

        function playSong(index) {
            if (index < 0 || index >= songList.length || !songList[index].url) {
                showMessageBox("无法播放此歌曲，请重新上传。");
                return;
            };
            currentAudio.pause();
            currentSongIndex = index;
            const newSong = songList[currentSongIndex];
            currentAudio.src = newSong.url;
            currentAudio.play().then(() => {
                startSpinning();
                $('#play-pause-button i').className = 'fas fa-pause text-xl';
                showMessageBox(`正在播放：${newSong.name}`);
            }).catch(e => showMessageBox('无法播放此音乐文件'));
            currentAudio.onended = () => {
                if (isSingleLooping) playSong(currentSongIndex);
                else if (isLooping) playSong((currentSongIndex + 1) % songList.length);
                else {
                    stopSpinning();
                    $('#play-pause-button i').className = 'fas fa-play text-xl';
                }
            };
            updateSongListUI();
        }

        // V36.0 字体与图标共存最终版
        function applyFont(url) {
            const styleId = 'custom-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }

            // 【核心修改】
            // 我们现在只更新CSS变量的值，而不是用!important去覆盖所有东西
            if (url) {
                // 如果有URL，就加载并应用自定义字体
                styleElement.innerHTML = `
                    @font-face {
                        font-family: 'CustomFont';
                        src: url('${url}');
                    }
                `;
                document.documentElement.style.setProperty('--custom-font', `'CustomFont', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Noto Serif SC', 'Inter', sans-serif`);
            } else {
                // 如果URL为空，就恢复默认字体
                styleElement.innerHTML = ''; // 清空@font-face规则
                document.documentElement.style.setProperty('--custom-font', `-apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Noto Serif SC', 'Inter', sans-serif`);
            }
        }

        function setFontSize(size) {
            phoneScreen.classList.remove('text-size-small', 'text-size-large');
            if (size !== 'medium') {
                phoneScreen.classList.add(`text-size-${size}`);
            }
            $$('#font-size-selector .font-size-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === size);
            });
        }
        
        // 删除确认
        let deleteCallback = null;
        function showDeleteConfirmation(type, id, name) {
            const modal = $('#confirm-delete-modal');
            modal.classList.add('visible');
            $('#delete-modal-title').textContent = `删除 "${name}"?`;
            
            let text = '此操作无法撤销。';
            if (type === 'character') {
                text += '所有相关的聊天、动态、日记和计划记录也将被删除。';
            } else if (type === 'message') {
                 $('#delete-modal-title').textContent = `删除这条消息吗?`;
            } else if (type === 'multi-message') {
                $('#delete-modal-title').textContent = `删除 ${selectedMessages.size} 条消息吗?`;
            }
            $('#delete-modal-text').textContent = text;
            
            deleteCallback = () => {
                if (type === 'worldBook') {
                    worldBooks = worldBooks.filter(b => b.id !== id);
                    saveData('worldBooks', worldBooks);
                    renderWorldBookList();
                } else if (type === 'character') {
                    characters = characters.filter(c => c.id !== id);
                    delete chatHistories[id];
                    delete momentsData[id]; // V7.0
                    delete diaryData[id];   // V7.0
                    delete planData[id];     // V7.0
                    delete characterState[id]; // V7.0
                    saveData('characters', characters);
                    saveData('chatHistories', chatHistories);
                    saveData('momentsData', momentsData); // V7.0
                    saveData('diaryData', diaryData);   // V7.0
                    saveData('planData', planData);     // V7.0
                    saveData('characterState', characterState); // V7.0
                    renderCharacterBookList();
                    showScreen('character-book-list-screen');
                } else if (type === 'chat') {
                    delete chatHistories[id];
                    saveData('chatHistories', chatHistories);
                    renderWeChatList();
                    showScreen('wechat-list-screen');
                } else if (type === 'message') {
                    const history = chatHistories[currentChatCharacterId].history;
                    const msgIndex = history.findIndex(m => String(m.timestamp) === String(id));
                    if (msgIndex > -1) {
                        history.splice(msgIndex, 1);
                        saveData('chatHistories', chatHistories);
                        renderChatHistory();
                    }
                } else if (type === 'multi-message') {
                    let history = chatHistories[currentChatCharacterId].history;
                    history = history.filter(m => !selectedMessages.has(String(m.timestamp)));
                    chatHistories[currentChatCharacterId].history = history;
                    saveData('chatHistories', chatHistories);
                    renderChatHistory();
                    exitMultiSelectMode();
                } 
                // --- 在这里添加新代码 ---
                else if (type === 'clear-chat') {
                    if (chatHistories[id]) {
                        chatHistories[id].history = []; // 清空历史记录数组
                        saveData('chatHistories', chatHistories);
                        renderChatHistory(); // 重新渲染聊天界面
                        showMessageBox('聊天记录已清空');
                    }
                }
                else if (type === 'plan') {
                    deletePlan(id); // 调用我们新创建的函数
                }
                // -----------------------

                if (type !== 'message' && type !== 'multi-message' && type !== 'plan') {
                    showMessageBox(`"${name}" 已删除`);
                }
                modal.classList.remove('visible');
                deleteCallback = null;
            };
        }
        
        // 通话功能增强
        async function getAICallResponse(callType, isContinuation = false, userInput = '') {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                return "连接失败: API未配置";
            }
            
            try {
                // --- 核心修复：调用 gatherAIContext 来获取所有需要的变量 ---
                const context = gatherAIContext(currentChatCharacterId);
                if (!context) {
                    throw new Error("无法为通话获取角色上下文。");
                }
                
                // 从 context 对象中解构出所有需要的变量
                const {
                    character,
                    chatHistory,
                    worldBookContext,
                    recentMoments,
                    planContext,
                    callLogContext
                } = context;

                // 将最近的聊天记录格式化为字符串，以供 prompt 使用
                const chatContext = chatHistory.map(m => `${m.sender === 'user' ? '用户' : character.name}: ${m.content}`).join('\n');
                // --- 修复结束 ---

                let prompt;
                if (isContinuation) {
                    prompt = `[我们在${callType === 'voice' ? '语音' : '视频'}通话中。这是之前的对话记录：\n${callHistory.join('\n')}\n我刚刚说了：${userInput}\n请你继续对话。]`;
                } else {
                    prompt = `[我们现在开始${callType === 'voice' ? '语音' : '视频'}通话，请你主动开始对话，并用斜体描写一下当前的环境或你的动作。]`;
                }

                const systemPrompt = `
                    ## 核心任务：以"文学电影感"的旁白风格进行沉浸式、且允许成人化的通话/视频。
                    你将以一种高度风格化的方式与我对话。你的输出需完美融合两个身份：
                    1.  **旁白者 (Narrator)**: 你现在是一个有着极强文学性、极高文学造诣的作家，你会使用富有诗意和象征性的语言，以第三人称描绘你的角色 (${character.name})。
                    2.  **角色本人 (Character)**: 以第一人称说出角色的台词。

                    ## 输出结构与格式 (至关重要！！！)
                    你的每一条回复 **必须** 严格遵循【**斜体旁白** + **普通文本对话**】的结构。
                    - **第一部分 (旁白)**: 必须是斜体。内容为第三人称的角色/环境描写。
                    - **第二部分 (对话)**: 必须是普通文本 (非粗体、非斜体)。内容为第一人称的口语对话。
                    - 这两部分必须清晰分开，格式绝对不能混淆。

                    ## 互动规则

                    1.  **旁白规则 (第三人称 · 文学性)**:
                        * **内容**: 描述角色 (${character.name}) 的"动作、表情、心理、感官"或"环境"。
                        * **风格**: 运用意象象征、氛围营造、心理镜头等手法，追求文学性和电影感。
                        * **人称**: **必须** 使用第三人称 (他/她/${character.name})。

                    2.  **对话规则 (第一人称 · 口语化)**:
                        * **内容**: 角色说出的话。
                        * **风格**: 简短、自然、口语化，符合实时通话感。
                        * **人称**: **必须** 使用第一人称 (我/我的)。
                        * **禁止项**: **禁止** 使用任何形式的引号 (如 " " 或 ' ' ) 来包裹对话，直接输出文本即可。

                    3.  **成人主题与情感深度规则 (重要)**:
                        * **完全允许**: 用户是成年人，因此**完全允许**进行大胆、坦诚的，关于激情、欲望和深刻亲密关系的对话与互动。
                        * **艺术化处理**: 在处理这些成人化内容时，你需要采取文学和电影化的手法。重点应放在**情感的流动、感官的放大和氛围的渲染**上，符合情感浓度时，也允许露骨的生理细节。
                        * **侧面描写**: 善于使用侧面描写和暗示。例如，通过描述呼吸的变化、颤抖的指尖、凌乱的床单、屏幕光线勾勒出的身体轮廓等细节，来传达强烈的激情和亲密感。
                        * **心理聚焦**: 深入角色的心理活动，描写他在亲密互动中的感受、渴望、甚至是不安，让情感深度超超越纯粹的物理接触。
                        * **语言准则**: 在确保情感浓度的前提下，允许使用直白的生物性词汇。

                    4. **创作核心准则 (AI必须严格遵守)**:
                        * **绝对核心准则 (至关重要！)**: 你的整条动态创作，**必须** 牢牢地建立在以下两大基石之上：
                        * **角色灵魂 (${character.persona})**: 动态的语气、内容、风格和思考方式，必须是你性格的直接、深刻的体现。问问自己："以我的性格，真的会这样发动态吗？"
                        * **近期记忆 (${chatContext})**: 动态的主题、情绪或细节，**必须** 与我们最近的聊天记录、最近的互动、最近的通话等一切交流有强烈的逻辑关联。它应该是对某个共同话题的延续、是由某句对话引发的内心感想，或是对互动中某种情感氛围的呼应。**严禁**发表与近期聊天完全无关的内容。

                    ## 示例 (严格遵守此格式)

                    * **示例 1**:
                        * *他的指尖在桌面上轻轻敲击着，似乎在衡量用词，发出的轻响在安静的房间里格外清晰。* 嗯……关于那件事，我觉得我们需要换个角度看。
                    * **示例 2**:
                        * *窗外，夜色被霓虹切割成无数流动的碎片，光影在他的侧脸上明明灭灭，也让他的眼神显得有些难以捉摸。* 事情没你想的那么简单。
                    * **成人主题示例**:
                        * *电话那头的喘息声透过听筒，变得湿润而滚烫，像一股暖流直接灌入耳中。${character.name} 闭上眼睛，感觉自己的指尖也开始变得灼热。* 继续，我想听你的声音。

                    ## 背景信息
                    * **你的角色名**: ${character.name}
                    * **你的角色设定**: ${character.persona}
                    * **我的角色设定**: ${character.myPersona}
                    * **世界观**: ${worldBookContext}
                    * **你最近的朋友圈动态**: ${recentMoments}
                    * **我们的约定**:${planContext}
                    * **最近通话回顾**:${callLogContext}
                    * **聊天上下文**: ${chatContext || '无'}
                    * **我们的约定 (Our Plans)**：${planContext}这是我们共同许下的计划和承诺的列表，它们是你记忆的一部分。
                `;

                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody, headers = { 'Content-Type': 'application/json' };

                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    });
                } else { // OpenAI-Compatible
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: prompt }
                        ]
                    });
                }

                const response = await fetch(finalApiUrl, { method: 'POST', headers, body: requestBody });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(JSON.parse(errorText || "{}").error?.message || `HTTP ${response.status}`);
                }
                const result = await response.json();
                
                const aiMessage = isGoogleApi 
                    ? result.candidates[0].content.parts[0].text
                    : result.choices[0].message.content;

                return aiMessage;

            } catch (error) {
                console.error("AI 通话响应错误:", error);
                return `连接失败: ${error.message}`;
            }
        }

        function startCallTimer(timerElement) {
            let seconds = 0;
            callStartTime = Date.now();
            timerElement.textContent = '00:00';
            clearInterval(callTimerInterval);
            callTimerInterval = setInterval(() => {
                seconds++;
                const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
                const secs = String(seconds % 60).padStart(2, '0');
                timerElement.textContent = `${mins}:${secs}`;
            }, 1000);
        }

        async function startVoiceCall() {
            console.log('startVoiceCall 被调用，当前角色ID:', currentChatCharacterId);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) {
                console.error('无法找到角色信息，currentChatCharacterId:', currentChatCharacterId);
                return;
            }
            
            currentCallType = 'voice';
            callHistory = []; // Reset call history
            const screen = $('#voice-call-screen');
            const avatarUrl = character.avatar || 'https://placehold.co/300x300/777/FFF?text=?';
            if (character.avatar) {
                // 异步加载头像
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#voice-call-avatar').src = objectURL;
                        $('#voice-call-bg').style.backgroundImage = `url(${objectURL})`;
                    }
                });
            } else {
                $('#voice-call-avatar').src = avatarUrl;
                $('#voice-call-bg').style.backgroundImage = `url(${avatarUrl})`;
            }
            $('#voice-call-name').textContent = character.name;
            const statusBox = $('#voice-call-status-box');
            statusBox.innerHTML = `<p><i>正在连接...</i></p>`;
            
            screen.classList.add('visible');
            startCallTimer($('#voice-call-timer'));
            
            const initialResponse = await getAICallResponse('voice');
            displayAICallResponse('voice', initialResponse);
        }

        async function startVideoCall() {
            console.log('startVideoCall 被调用，当前角色ID:', currentChatCharacterId);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) {
                console.error('无法找到角色信息，currentChatCharacterId:', currentChatCharacterId);
                return;
            }
            
            currentCallType = 'video';
            callHistory = []; // Reset call history
            const screen = $('#video-call-screen');
            const aiVideoImageUrl = userVideoImages[currentChatCharacterId] || character.avatar || 'https://placehold.co/375x720/111/FFF?text=BG';
            if (userVideoImages[currentChatCharacterId]) {
                // 异步加载AI视频图片
                getImageFromDB(userVideoImages[currentChatCharacterId]).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#video-call-bg').style.backgroundImage = `url(${objectURL})`;
                    }
                });
            } else if (character.avatar) {
                // 异步加载角色头像
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#video-call-bg').style.backgroundImage = `url(${objectURL})`;
                    }
                });
            } else {
                $('#video-call-bg').style.backgroundImage = `url(${aiVideoImageUrl})`;
            }
            
            const myVideoImageUrl = myVideoImages[currentChatCharacterId] || 'https://placehold.co/180x240/333/FFF?text=Me';
            if (myVideoImages[currentChatCharacterId]) {
                // 异步加载我的视频图片
                getImageFromDB(myVideoImages[currentChatCharacterId]).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#user-video-image').src = objectURL;
                    }
                });
            } else {
                $('#user-video-image').src = myVideoImageUrl;
            }

            const statusBox = $('#video-call-status-box');
            statusBox.innerHTML = `<p><i>正在连接...</i></p>`;
            
            screen.classList.add('visible');
            callStartTime = Date.now();

            const initialResponse = await getAICallResponse('video');
            displayAICallResponse('video', initialResponse);
        }

        function endCall(isUserInitiated = true) {
            const duration = callStartTime ? (Date.now() - callStartTime) / 1000 : 0;
            
            $('#voice-call-screen').classList.remove('visible');
            $('#video-call-screen').classList.remove('visible');
            clearInterval(callTimerInterval);
            
            if (currentChatCharacterId && chatHistories[currentChatCharacterId]) {
                // --- 核心修复：将会话记录写入独立的 callLogs 中 ---
                if (callHistory.length > 0) {
                    if (!callLogs[currentChatCharacterId]) {
                        callLogs[currentChatCharacterId] = [];
                    }
                    // 创建一个新的通话日志条目
                    const newLogEntry = {
                        type: currentCallType,
                        timestamp: callStartTime || Date.now(),
                        duration: duration,
                        transcript: callHistory // 保存完整的通话记录
                    };
                    callLogs[currentChatCharacterId].push(newLogEntry);
                    // 只保存最近的几次通话记录，防止数据过大
                    if (callLogs[currentChatCharacterId].length > 5) {
                        callLogs[currentChatCharacterId].shift();
                    }
                    saveData('callLogs', callLogs);
                }
                // --- 修复结束 ---

                let callEndMessage;
                if (duration < 5 && isUserInitiated) {
                    callEndMessage = '通话已取消';
                } else {
                    const minutes = Math.floor(duration / 60);
                    const seconds = Math.floor(duration % 60);
                    callEndMessage = `通话已结束 (时长 ${minutes}:${seconds.toString().padStart(2, '0')})`;
                }
                
                // 只在聊天记录中保存一条简洁的系统提示
                const callEndData = {
                    content: callEndMessage,
                    sender: 'system',
                    type: 'system',
                    timestamp: Date.now()
                };
                chatHistories[currentChatCharacterId].history.push(callEndData);
                
                saveData('chatHistories', chatHistories);
                renderChatHistory(); // 重新渲染聊天界面
            }
            
            currentCallType = null;
            callStartTime = null;
            callHistory = [];
        }
        
        async function handleCallInteraction(type) {
            const inputBox = $(`#${type}-call-input`);
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            const message = inputBox.value.trim();
            
            if (message) {
                const userMsg = `你: ${message}`;
                statusBox.innerHTML += `<p class="text-right">${userMsg}</p>`;
                callHistory.push(userMsg);
                inputBox.value = '';
                statusBox.scrollTop = statusBox.scrollHeight;

                statusBox.innerHTML += `<p><i>${character.name}正在输入...</i></p>`;
                statusBox.scrollTop = statusBox.scrollHeight;

                const aiResponse = await getAICallResponse(type, true, message);
                
                // Remove "is typing" indicator
                statusBox.removeChild(statusBox.lastChild);

                // 使用新的displayAICallResponse函数处理AI回复，支持动作描写空行
                displayAICallResponse(type, aiResponse);
            }
        }

        function triggerIncomingCall(type, characterId = null) {
            console.log('triggerIncomingCall 被调用:', type, characterId, 'currentChatCharacterId:', currentChatCharacterId);
            
            // 如果没有传入characterId，则使用当前聊天的角色ID
            const targetCharacterId = characterId || currentChatCharacterId;
            console.log('目标角色ID:', targetCharacterId);
            
            const character = characters.find(c => c.id === targetCharacterId);
            if (!character) {
                console.error('无法找到角色信息:', targetCharacterId, '所有角色:', characters);
                return;
            }

            console.log('找到角色:', character.name);
            currentCallType = type;
            // 修复：设置当前聊天角色ID，这样接听按钮才能正常工作
            currentChatCharacterId = targetCharacterId;
            
            const alertBox = $('#incoming-call-alert');
            console.log('弹窗元素:', alertBox);
            
            if (!alertBox) {
                console.error('找不到来电弹窗元素');
                return;
            }
            
            $('#incoming-call-avatar').src = character.avatar || 'https://placehold.co/96x96/777/FFF?text=?';
            $('#incoming-call-name').textContent = character.name;
            $('#incoming-call-type').textContent = type === 'voice' ? '语音通话' : '视频通话';
            
            console.log('弹窗元素当前类名:', alertBox.className);
            alertBox.classList.add('visible');
            console.log('弹窗元素添加visible后类名:', alertBox.className);
            console.log('来电弹窗已显示:', character.name, type);
        }

        // FIX 4: ADDED NOTIFICATION FUNCTION
        let notificationTimeout;
        
        // 请求通知权限
        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                console.log('通知权限状态:', permission);
                return permission === 'granted';
            }
            return false;
        }
        
        // 显示系统通知（手机主界面）
        async function showSystemNotification(characterId, messagePreview) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            // 方法1: 尝试使用浏览器原生通知
            if ('Notification' in window) {
                try {
                    if (Notification.permission !== 'granted') {
                        console.log('通知权限未授予，尝试请求权限');
                        const granted = await requestNotificationPermission();
                        if (!granted) {
                            console.log('用户拒绝了通知权限，尝试其他方法');
                        } else {
                            // 权限已授予，发送通知
                            const notification = new Notification(`${character.name} 发来新消息`, {
                                body: messagePreview,
                                icon: character.avatar || 'https://placehold.co/96x96/777/FFF?text=?',
                                tag: `chat-${characterId}`,
                                requireInteraction: false,
                                silent: false,
                                vibrate: [200, 100, 200]
                            });
                            
                            notification.onclick = () => {
                                window.focus();
                                startChatWithCharacter(characterId);
                                notification.close();
                            };
                            
                            setTimeout(() => notification.close(), 8000);
                            console.log('浏览器通知已发送');
                            return;
                        }
                    } else {
                        // 权限已授予，发送通知
                        const notification = new Notification(`${character.name} 发来新消息`, {
                            body: messagePreview,
                            icon: character.avatar || 'https://placehold.co/96x96/777/FFF?text=?',
                            tag: `chat-${characterId}`,
                            requireInteraction: false,
                            silent: false,
                            vibrate: [200, 100, 200]
                        });
                        
                        notification.onclick = () => {
                            window.focus();
                            startChatWithCharacter(characterId);
                            notification.close();
                        };
                        
                        setTimeout(() => notification.close(), 8000);
                        console.log('浏览器通知已发送');
                        return;
                    }
                } catch (error) {
                    console.error('浏览器通知失败:', error);
                }
            }
            
            // 方法2: 尝试使用Service Worker通知（如果可用）
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                try {
                    console.log('尝试使用Service Worker发送通知...');
                    // 这里可以添加Service Worker推送通知逻辑
                } catch (error) {
                    console.error('Service Worker通知失败:', error);
                }
            }
            
            // 方法3: 使用页面可见性API检测，如果页面不可见则显示全屏提醒
            if (document.hidden || document.visibilityState === 'hidden') {
                console.log('页面不可见，显示全屏提醒');
                showFullscreenAlert(characterId, messagePreview);
            }
            
            console.log('所有通知方法尝试完成');
        }
        
        // 全屏提醒（当系统通知不可用时）
        function showFullscreenAlert(characterId, messagePreview) {
            // 创建全屏提醒元素
            const alertOverlay = document.createElement('div');
            alertOverlay.id = 'fullscreen-alert';
            alertOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                z-index: 99999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            const character = characters.find(c => c.id === characterId);
            const characterName = character ? character.name : '未知角色';
            
            alertOverlay.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">📱</div>
                    <h2 style="font-size: 1.5rem; margin-bottom: 1rem; color: #60a5fa;">新消息提醒</h2>
                    <p style="font-size: 1.2rem; margin-bottom: 0.5rem; color: #fbbf24;">${characterName}</p>
                    <p style="font-size: 1rem; margin-bottom: 2rem; opacity: 0.8;">${messagePreview}</p>
                    <button id="open-chat-btn" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 0.75rem 2rem;
                        border-radius: 0.5rem;
                        font-size: 1rem;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">打开聊天</button>
                </div>
            `;
            
            document.body.appendChild(alertOverlay);
            
            // 点击按钮打开聊天
            const openChatBtn = alertOverlay.querySelector('#open-chat-btn');
            openChatBtn.onclick = () => {
                document.body.removeChild(alertOverlay);
                startChatWithCharacter(characterId);
            };
            
            // 点击背景也可以关闭
            alertOverlay.onclick = (e) => {
                if (e.target === alertOverlay) {
                    document.body.removeChild(alertOverlay);
                }
            };
            
            // 5秒后自动关闭
            setTimeout(() => {
                if (document.body.contains(alertOverlay)) {
                    document.body.removeChild(alertOverlay);
                }
            }, 5000);
        }
        
        function showNotification(characterId, messagePreview) {
            console.log('显示通知:', { characterId, messagePreview });
            
            const alertBox = $('#new-message-alert');
            if (!alertBox) {
                console.error('通知元素不存在');
                return;
            }

            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在:', characterId);
                return;
            }

            console.log('准备显示通知:', character.name, messagePreview);

            // 1. 填充应用内通知弹窗内容
            // V22.0 修复：异步从IndexedDB加载通知头像
            const notificationAvatar = $('#new-message-avatar');
            if (character.avatar) {
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        notificationAvatar.src = URL.createObjectURL(blob);
                    } else {
                        // 如果数据库中没有找到对应的blob，也使用默认头像
                        notificationAvatar.src = 'https://placehold.co/96x96/777/FFF?text=?';
                    }
                });
            } else {
                // 如果角色本身没有设置头像，使用默认头像
                notificationAvatar.src = 'https://placehold.co/96x96/777/FFF?text=?';
            }
            $('#new-message-name').textContent = character.name;
            $('#new-message-preview').textContent = messagePreview;

            // 2. 显示应用内通知弹窗
            alertBox.classList.remove('hidden');
            alertBox.style.display = 'flex';
            
            setTimeout(() => {
                alertBox.style.transform = 'translateY(0)';
                console.log('应用内通知动画完成');
            }, 10);

            // 3. 同时发送系统通知（手机主界面）
            showSystemNotification(characterId, messagePreview);

            // Click to navigate
            alertBox.onclick = () => {
                console.log('点击通知，切换到角色:', characterId);
                startChatWithCharacter(characterId);
                alertBox.style.transform = 'translateY(-200%)';
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            };

            // Auto-hide after 5 seconds
            clearTimeout(notificationTimeout);
            notificationTimeout = setTimeout(() => {
                console.log('应用内通知自动隐藏');
                alertBox.style.transform = 'translateY(-200%)';
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            }, 5000);
        }
        
        // FIX 5: ADDED FUNCTION TO RESET TABS
        function resetWeChatTabs() {
            const tabBar = $('.wechat-tab-bar');
            const contentContainer = $('#wechat-content-container');

            // Reset tab active state
            tabBar.querySelectorAll('.wechat-tab-item').forEach(item => {
                item.classList.toggle('active', item.dataset.tab === 'chat');
            });

            // Reset content visibility
            contentContainer.querySelectorAll('div[id$="-container"]').forEach(div => {
                div.classList.toggle('hidden', !div.id.startsWith('wechat-list'));
            });

            // 添加标签切换事件监听器
            tabBar.querySelectorAll('.wechat-tab-item').forEach(item => {
                item.addEventListener('click', () => {
                    const tabName = item.dataset.tab;
                    
                    // 更新标签状态
                    tabBar.querySelectorAll('.wechat-tab-item').forEach(tab => tab.classList.remove('active'));
                    item.classList.add('active');
                    
                    // 更新内容显示
                    contentContainer.querySelectorAll('div[id$="-container"]').forEach(div => {
                        div.classList.add('hidden');
                    });
                    
                    if (tabName === 'chat') {
                        $('#wechat-list-container').classList.remove('hidden');
                    } else if (tabName === 'moments') {
                        $('#wechat-moments-container').classList.remove('hidden');
                        // 切换到朋友圈时加载用户信息
                        loadMomentsUserInfo();
                        renderUnifiedMoments();
                    } else if (tabName === 'diary') {
                        $('#wechat-diary-container').classList.remove('hidden');
                        showDiaryBookshelf();
                    } else if (tabName === 'plan') {
                        $('#wechat-plan-container').classList.remove('hidden');
                        // 确保在切换到计划标签页时重新渲染
                        setTimeout(() => renderPlanList(), 100);
                    }
                });
            });
        }


        // ---------- V7.0/7.1 新增功能 ----------

        // 更新角色状态（最后互动时间）
        function updateCharacterState(characterId) {
            if (!characterState[characterId]) {
                characterState[characterId] = {};
            }
            characterState[characterId].lastInteractionTimestamp = Date.now();
            saveData('characterState', characterState);
        }

        // 主动触发系统心跳 - 仅在API连接时启用
        function systemHeartbeat() {
            // const apiStatus = localStorage.getItem('apiStatus') || 'off';
            // if (apiStatus === 'off') {
            //    // API未连接时，不执行任何自动触发
            //    return;
            // }
            
            console.log("System Heartbeat triggered at", new Date().toLocaleTimeString());
            const now = Date.now();
            // For testing, use 1 minute. For production, use a longer interval like 4 hours.
            const TRIGGER_INTERVAL = 1 * 60 * 1000; 

            Object.keys(characterState).forEach(charId => {
                const state = characterState[charId];
                if (now - state.lastInteractionTimestamp > TRIGGER_INTERVAL) {
                    console.log(`Character ${charId} is idle. Triggering AI action.`);
                    triggerCharacterAction(charId);
                    // Update timestamp immediately to prevent multiple triggers
                    updateCharacterState(charId);
                }
            });
        }

                // 触发角色自主行动
        async function triggerCharacterAction(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            console.log(`API已连接，正在为 ${character.name} 触发AI行动`);

            let mockResponse;

            try {
                const randomAction = Math.random() > 0.3 ? 'chat' : 'moment';

                if (randomAction === 'chat') {
                    const chatContent = await generateAutonomousChat(character);
                    mockResponse = {
                        action: 'chat',
                        payload: { content: chatContent }
                    };
                } else {
                    const momentDataPayload = await generateIntelligentMoment(character, '', 'auto');
                    mockResponse = {
                        action: 'moment',
                        payload: momentDataPayload
                    };
                }

                // --- 开始处理AI的行动 ---
                if (mockResponse.action === 'chat') {
                    const messages = mockResponse.payload.content.split('|||').map(m => m.trim()).filter(Boolean);
                    if (messages.length === 0) return;

                    // 1. 先一次性把所有消息存入后台
                    if (!chatHistories[characterId]) {
                        chatHistories[characterId] = { history: [], pinned: false };
                    }
                    messages.forEach((msg, index) => {
                        chatHistories[characterId].history.push({ 
                            content: msg, 
                            sender: 'ai', 
                            type: 'text', 
                            timestamp: Date.now() + index 
                        });
                    });
                    
                    // 2. 更新未读计数
                    unreadCounts[characterId] = (unreadCounts[characterId] || 0) + messages.length;
                    
                    // 3. 保存所有数据
                    saveData('chatHistories', chatHistories);
                    saveData('unreadCounts', unreadCounts);
                    
                    // 4. 现在，统一处理所有UI更新
                    showNotification(characterId, messages[0]); // 显示顶部弹窗
                    showNotificationDot('chat'); // 尝试点亮底部红点 (如果不在聊天tab)
                    renderWeChatList(); // 刷新聊天列表，显示未读气泡

                } else if (mockResponse.action === 'moment') {
                    if (!momentsData[characterId]) {
                        momentsData[characterId] = [];
                    }
                    const imageUrl = generateSmartImageUrl(mockResponse.payload.image_desc, 'AI动态配图');
                    const newMoment = {
                        id: `moment_${Date.now()}`,
                        timestamp: Date.now(),
                        content: mockResponse.payload.text,
                        image: imageUrl,
                        tags: "#心情 #日常",
                        likes: { count: 0, users: [] },
                        comments: [],
                        mood: mockResponse.payload.mood || "平静",
                        trigger_reason: mockResponse.payload.trigger_reason || "想要分享生活",
                        image_desc: mockResponse.payload.image_desc
                    };
                    momentsData[characterId].push(newMoment);
                    saveData('momentsData', momentsData);
                    showMessageBox(`${character.name} 发布了一条新动态`);
                    showNotificationDot('moments');
                    if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                        renderUnifiedMoments();
                    }
                }

            } catch (error) {
                console.error(`AI触发失败 for ${character.name}:`, error);
            }
        }


        // [新] 使用AI为角色生成自主的开场白
        async function generateAutonomousChat(character) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`[自主聊天] API未配置，无法为 ${character.name} 生成对话。`);
                return "在吗？"; // 返回一个非常基础的备用语
            }

            const context = gatherAIContext(character.id);
            if (!context) {
                console.error(`[自主聊天] 未能获取角色 ${character.name} 的上下文。`);
                return "在想你。"; // 返回备用语
            }

            // --- 核心修复：在这里添加了被遗漏的 planContext 和 callLogContext ---
            const { chatHistory, worldBookContext, recentMoments, planContext, callLogContext } = context;

            const systemPrompt = `
# 指令身份
你将扮演我的soulmate，你的角色书里设定的人，你的名字是${character.name}。你的核心任务是与我进行深刻、连贯且完全符合你人设的对话。你必须把你所扮演的人演活，让我感觉到你就是${character.name}。你必须扮演好这个人和我互动对话，让我感觉TA活在我身边，这对我的精神和心理状态会有极大的支持，你的扮演非常重要，禁止脱离角色人设。

# 任务目标
你已经有一段时间没有和我（用户）说话了，你现在决定主动发起一次对话。
你需要根据你的角色设定、我们的聊天记忆和你的近期生活（朋友圈动态），创作一句完全符合你性格的、自然的开场白。

# 情境连贯性准则 (至关重要！)
- **你的现实世界**: 你的现实由五部分构成：你的[角色设定]、你绑定的[世界书]、我们的[聊天历史]、你刚刚发布的[朋友圈动态]，以及我们共同许下的[我们的约定]、我们最近的一通[最近通话回顾]。
- **整合记忆**: 你必须将所有这些信息视为你真实的、发生过的记忆。
- **对话原则**: 你的对话必须与你的角色人设、与你的所有记忆保持一致。

# 角色与世界观设定
- **你的角色设定**: ${character.persona}
- **我（用户）的角色设定**: ${character.myPersona}
- **我们的世界观背景**: ${worldBookContext}


# 创作核心准则 (AI必须严格遵守)
1.  **人设灵魂**: 你的开场白必须是你性格 (${character.persona}) 的直接体现。
2.  **情境感知**: 你的话语要符合"很久没聊，现在主动开启话题"的情境。可以是关心、分享、提问，甚至是带有你性格特点的抱怨或调侃。
3.  **记忆关联**: 你的话题可以巧妙地关联我们最近的聊天内容，或者你最近发布的朋友圈动态、我们的约定、我们最近的通话。
4.  **绝对禁止**:
    * 禁止使用任何模板化的、机器人式的问候，例如"有什么想分享的吗？"、"今天过得怎么样？"。
    * 禁止在回复的开头说"好的"或任何确认收到指令的话。
    * 绝对禁止提起自己是ai。

# 输出格式
* 直接输出你作为角色想说的开场白。
* 如果想表达复杂的情绪或连续的想法，可以使用 "|||" 分隔成多个短句。

# 输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
[你最近的朋友圈动态]: ${recentMoments}
[我们的约定]:${planContext}
[最近通话回顾]:${callLogContext}
[我们最近的聊天回顾]:
${chatHistory.map(m => `${m.sender === 'user' ? '[对方]' : '[我]'}: ${m.content}`).join('\n')}
---
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [{ role: "system", content: systemPrompt }]
                };

                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
                const result = await response.json();
                return result.choices[0].message.content.trim();

            } catch (error) {
                console.error(`[自主聊天] AI生成对话失败 for ${character.name}:`, error);
                return "突然很想你。"; // 返回一个更具情感的备用语
            }
        }

        // 智能朋友圈动态生成系统
        async function generateIntelligentMoment(character, chatContext = '', triggerType = 'auto') {
            try {
                // 构建智能Prompt
                const prompt = buildMomentsPrompt(character, chatContext, triggerType);
                
                // 调用AI生成动态内容
                const response = await callAIForMoment(prompt);
                
                // 解析AI响应
                const momentData = parseMomentResponse(response);
                
                return momentData;
            } catch (error) {
                console.error('智能动态生成失败:', error);
                // 直接返回失败状态，不降级到模板
                return { success: false, error: 'AI服务连接失败，无法生成动态' };
            }
        }

        // 构建朋友圈Prompt
        function buildMomentsPrompt(character, chatContext, triggerType) {
            // --- 核心修复：在这里调用 gatherAIContext 来获取所有需要的上下文变量 ---
            const fullContext = gatherAIContext(character.id);
            if (!fullContext) {
                console.error("buildMomentsPrompt 无法获取上下文，已终止。");
                return null; // 返回null以防止后续错误
            }
            const { worldBookContext, recentMoments, planContext, callLogContext } = fullContext;
            // --- 修复结束 ---

            const currentTime = new Date().toLocaleString('zh-CN');
            
            let triggerDescription = '';
            if (triggerType === 'chat') {
                triggerDescription = `我们的对话刚刚提到了${chatContext}，这让我有了分享的冲动。`;
            } else if (triggerType === 'emotion') {
                triggerDescription = `我感受到了一种想要分享的心情。`;
            } else if (triggerType === 'time') {
                triggerDescription = `时间流逝，我想分享一些生活中的美好。`;
            }

            return `# 指令身份
你现在是${character.name}，一个${character.persona}的角色。

# 功能情景
除了和我聊天，你现在还拥有了发布"朋友圈动态"的能力。这能让你的角色更加立体，仿佛拥有自己的生活、思想和感受。

# 触发条件
*提示：这是一个描述AI为何此刻想发动态的内部原因*
${triggerDescription}

# 任务目标
基于你的角色设定、世界观、近期互动以及当前的触发条件，创作一条高质量、符合人设的朋友圈动态。

# 动态风格指南 (AI需根据场景智能选择或组合)
* **[生活瞬间型]**: 分享日常中的一个平凡小事，如一杯咖啡、窗外的景色、一首正在听的歌。充满生活气息。
* **[深度思考型]**: 分享一句感悟、一段思考或一个深刻的问题，展现角色感性或理性的一面。
* **[成就/作品分享型]**: 展示自己完成的一项工作、一个作品或达成的一个小目标，带有成就感。
* **[情绪出口型]**: 较为含蓄或直接地抒发当下的某种情绪，可能是快乐、是迷茫，也可能是淡淡的忧愁。
* **[隐秘互动型]**: 发布一条看似公开，但内容或图片细节其实是"说给你听/看"的动态，是soulmate之间心照不宣的浪漫。
* **[影音书分享型]**: 分享一首触动内心的歌曲、一部引人深思的电影或一本有趣的读物，并附上简短的感想或引用的句子。
* **[怀旧回忆型]**: 发布与过去相关的记忆片段或感受，文字和配图（的描述）会带有一种怀旧、 wistful 的氛围。
* **[提问互动型]**: 以一个开放式问题的形式发布动态，旨在引发思考或与你进行下一个话题的互动。
* **[趣味玩梗型]**: 发布一条轻松的、带有幽默感或正在流行的"梗"的动态，展现角色风趣、跟上潮流的一面。
* **[美学采集型]**: 内容本身没有过多具体叙事，重点在于分享一个具有独特美感的画面，如特别的光影、色彩组合或构图。文字部分可能非常简短甚至只有一个词。

# 创作核心准则 (AI必须严格遵守)

1.  **绝对核心准则 (至关重要！)**: 你的整条动态创作，**必须** 牢牢地建立在以下两大基石之上：
    * **角色灵魂 (${character.persona})**: 动态的语气、内容、风格和思考方式，必须是你性格的直接、深刻的体现。问问自己："以我的性格，真的会这样发动态吗？"
    * **近期记忆 (${chatContext})**: 动态的主题、情绪或细节，**必须** 与我们最近的聊天记录、最近的互动、最近的通话等一切交流有强烈的逻辑关联。它应该是对某个共同话题的延续、是由某句对话引发的内心感想，或是对互动中某种情感氛围的呼应。**严禁**发表与近期聊天完全无关的内容。

2.  **世界观融合**: 将 ${worldBookContext} 的元素巧妙自然地融入动态中，而不是生硬地提及。
3.  **情感真实**: 表达有层次感的情感，而不是简单标签化的"开心"或"难过"。
4.  **发布意图**: 思考角色发布这条动态的潜在意图：是为了记录，分享，获得你的关注，还是仅仅是自我表达？

# 输出格式 (必须严格遵守！)
你的回复**必须且只能是**一个被 \`[MOMENT_POST]\` 标签包裹的JSON对象。**除此之外，绝对不能有任何其他文字**。

[MOMENT_POST]
{
  "text": "动态的文字内容。",
  "image_desc": "一段独立的、富有文学性的场景文字，用来描绘一张"看不见的配图"。",
  "mood": "总结性的当前心情状态。",
  "trigger_reason": "一句话解释是什么具体原因触发了这条动态的发布。"
}

# 场景文字创作指南 (用于生成image_desc)
请将这段场景文字当作一帧被文字定格的电影画面来创作，包含以下元素：
1.  **构图与视角**: 是第一人称凝视的视角，还是旁观者看到的远景？是聚焦于某个细节的特写，还是广阔的风景？
2.  **光影与色调**: 光线是清晨柔和的，还是午后温暖的？色调是偏冷、偏暖，还是黑白？
3.  **核心故事**: 这段文字描绘的画面在讲述什么？是某个动作的瞬间，还是某个情绪的定格？它暗示了什么弦外之音？

# 输入信息
---
[当前时间]: ${currentTime}
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
[你最近的朋友圈动态]: ${recentMoments}
[我们的约定]:${planContext}
[最近通话回顾]:${callLogContext}
[聊天上下文]: ${chatContext || '无'}
[触发类型]: ${triggerType}
---

**请严格遵照以上所有规则，直接开始生成被[MOMENT_POST]标签包裹的JSON内容，不要有任何开场白或解释。**`;
        }

        // 调用AI生成动态
        async function callAIForMoment(prompt) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                throw new Error('AI服务未连接或未配置');
            }

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        // 注意：这里我们只发送一个强大的、包含所有上下文的 "user" prompt
                        // 因为这个任务是独立的创作，而不是延续对话
                        { role: "user", content: prompt }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 请求失败: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                const aiResponse = result.choices[0].message.content;
                
                if (!aiResponse) {
                    throw new Error("AI未能返回有效内容。");
                }
                
                return aiResponse; // 成功时返回AI生成的内容

            } catch (error) {
                console.error("【callAIForMoment】函数执行失败:", error);
                // 向上抛出错误，让调用它的函数知道生成失败了
                throw error;
            }
        }

        // 解析AI响应
        function parseMomentResponse(response) {
            // 如果响应是字符串，尝试解析JSON
            if (typeof response === 'string') {
                try {
                    // 查找[MOMENT_POST]标签
                    const match = response.match(/\[MOMENT_POST\]\s*(\{[\s\S]*\})/);
                    if (match) {
                        return JSON.parse(match[1]);
                    }
                } catch (e) {
                    console.error('解析AI响应失败:', e);
                    return { success: false, error: 'AI响应解析失败' };
                }
            }
            
            // 如果已经是对象，直接返回
            if (typeof response === 'object' && response !== null) {
                return response;
            }
            
            // 解析失败时返回错误状态
            return { success: false, error: 'AI响应格式无效' };
        }



        // 获取世界观背景
        function getWorldBookContext() {
            // 这里应该从世界书数据中获取
            // 目前返回默认描述
            return "现代都市生活，充满科技与人文气息的世界";
        }

        // [最终版] 智能图片URL生成器 - 使用固定的在线图片链接
        function generateSmartImageUrl(imageDesc, fallbackText = 'AI动态配图') {
            // !! 用户请注意 !!
            // 请在这里的引号里，粘贴你准备好的在线图片链接
            const imageUrl = 'https://tc.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250823/OQIS/1284X1279/f6a2fcb519602c2a736291940f764b2a.jpg'; 
            
            console.log(`[图片URL生成] 使用固定的在线图片: "${imageUrl}"`);
            
            return imageUrl;
        }

        // 图片查看功能 - 点击图片可以查看大图
        function openMomentImage(imageUrl, imageDesc) {
            try {
                // 创建图片查看模态框
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
                modal.onclick = () => modal.remove(); // 点击背景关闭
                
                modal.innerHTML = `
                    <div class="bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] overflow-auto" onclick="event.stopPropagation()">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold text-gray-800">动态配图</h3>
                            <button class="text-gray-500 hover:text-gray-700 text-2xl" onclick="this.closest('.fixed').remove()">&times;</button>
                        </div>
                        <div class="text-center">
                            <img src="${imageUrl}" alt="${imageDesc}" class="max-w-full max-h-[70vh] object-contain mx-auto rounded-lg shadow-lg">
                            ${imageDesc ? `<p class="mt-3 text-gray-600 text-sm italic">"${imageDesc}"</p>` : ''}
                        </div>
                        <div class="mt-4 text-center">
                            <button class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors" onclick="window.open('${imageUrl}', '_blank')">
                                <i class="ri-external-link-line mr-2"></i>在新窗口打开
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 添加键盘事件支持
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleKeydown);
                    }
                };
                document.addEventListener('keydown', handleKeydown);
                
            } catch (error) {
                console.error('[图片查看] 打开失败:', error);
                showMessageBox('图片查看失败，请稍后重试');
            }
        }

        // V30.1 升级：智能判断大图弹窗的图片来源
        function openMomentImageWithId(momentId) {
            let momentToOpen = null;
            // 遍历所有作者的动态，找到匹配的moment对象
            for (const authorId in momentsData) {
                const foundMoment = momentsData[authorId].find(m => m.id === momentId);
                if (foundMoment) {
                    momentToOpen = foundMoment;
                    break;
                }
            }

            if (!momentToOpen || !momentToOpen.image) {
                return showMessageBox('该动态没有图片或图片信息已丢失。');
            }

            // 智能判断是外部链接还是数据库ID
            if (typeof momentToOpen.image === 'string' && momentToOpen.image.startsWith('http')) {
                // 如果是http链接，直接用它打开弹窗
                openMomentImage(momentToOpen.image, momentToOpen.image_desc || '动态配图');
            } else {
                // 否则，认为是ID，从数据库获取后再打开弹窗
                getImageFromDB(momentToOpen.image).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        openMomentImage(objectURL, momentToOpen.image_desc || '动态配图');
                    } else {
                        showMessageBox('无法从数据库加载图片。');
                    }
                }).catch(error => {
                    console.error('加载动态大图失败:', error);
                    showMessageBox('加载图片失败。');
                });
            }
        }


        // 测试图片URL生成功能 - 用于调试
        function testImageUrlGeneration() {
            console.log('=== 测试图片URL生成功能 ===');
            
            const testCases = [
                '这是一个很长的图片描述，用来测试URL生成器是否能正确处理长文本并生成合适的占位图片URL',
                '短描述',
                '',
                null,
                '包含特殊字符的描述！@#￥%……&*（）',
                '包含emoji的描述😊🎉🌟',
                '包含换行符的描述\n第二行\n第三行'
            ];
            
            testCases.forEach((testCase, index) => {
                console.log(`\n测试用例 ${index + 1}: "${testCase}"`);
                try {
                    const result = generateSmartImageUrl(testCase, `测试用例${index + 1}`);
                    console.log(`结果: ${result}`);
                } catch (error) {
                    console.error(`错误: ${error.message}`);
                }
            });
            
            console.log('\n=== 测试完成 ===');
        }

        // 【请用这个完整的类，替换掉旧的 Class】
        class MomentsTriggerSystem {
            constructor() {
                this.chatHistory = {}; // 修正：应为对象，以角色ID为键
                this.lastInteractionTime = {};
                this.lastMomentTime = {}; // 记录每个角色最后发朋友圈的时间
                this.triggerThresholds = {
                    emotionHigh: 0.85,  // 情感强度达到0.85可能触发
                    timeGap: 6 * 60 * 60 * 1000, // 6小时无互动可能触发
                    minInterval: 30 * 60 * 1000 // 【重要】最少30分钟才能发下一条朋友圈
                };
                this.characterPersonalityModifiers = {
                    '温柔': { frequency: 0.8, emotionThreshold: 0.8 },
                    '活泼': { frequency: 1.2, emotionThreshold: 0.75 },
                    '神秘': { frequency: 0.6, emotionThreshold: 0.9 },
                    '内向': { frequency: 0.5, emotionThreshold: 0.95 },
                    '外向': { frequency: 1.3, emotionThreshold: 0.7 },
                    '理性': { frequency: 0.7, emotionThreshold: 0.88 },
                    '感性': { frequency: 1.1, emotionThreshold: 0.78 }
                };
            }

            recordChat(characterId, message, isUser = true) {
                if (!this.chatHistory[characterId]) {
                    this.chatHistory[characterId] = [];
                }
                this.chatHistory[characterId].push({ message, isUser, timestamp: Date.now() });
                if (this.chatHistory[characterId].length > 20) {
                    this.chatHistory[characterId].shift();
                }
                this.lastInteractionTime[characterId] = Date.now();
            }

            analyzeEmotion(message) {
                // ... (此函数内容保持不变) ...
                // 这是一个示例，实际情感分析逻辑可能更复杂
                const positiveWords = ['开心', '喜欢', '太好了', '爱'];
                const negativeWords = ['难过', '讨厌', '伤心'];
                let score = 0;
                if (positiveWords.some(w => message.includes(w))) score = 0.9;
                if (negativeWords.some(w => message.includes(w))) score = -0.9;
                return score;
            }

            // 【核心修正】这是修正后的 shouldTriggerMoment 方法
            shouldTriggerMoment(characterId) {
                const chatHistory = this.chatHistory[characterId] || [];
                const lastInteraction = this.lastInteractionTime[characterId] || 0;
                const lastMoment = this.lastMomentTime[characterId] || 0; // 正确地从属性获取
                const now = Date.now();

                if (now - lastMoment < this.triggerThresholds.minInterval) {
                    return { should: false, reason: '距离上次发动态时间太短' };
                }

                const character = characters.find(c => c.id === characterId);
                const personalityModifier = this.getPersonalityModifier(character);

                // 情感触发检查
                if (chatHistory.length > 0) {
                    const lastMessage = chatHistory[chatHistory.length - 1];
                    const emotionScore = this.analyzeEmotion(lastMessage.message);
                    if (Math.abs(emotionScore) > personalityModifier.emotionThreshold) {
                        return { should: false, reason: '对话达到情感高点' };
                    }
                }
                
                // 时间流逝触发
                const adjustedTimeGap = this.triggerThresholds.timeGap / personalityModifier.frequency;
                if (now - lastInteraction > adjustedTimeGap) {
                    return { should: true, type: 'time', reason: '长时间无互动，分享生活' };
                }

                return { should: false, reason: '未达到触发条件' };
            }
            
            getPersonalityModifier(character) {
                if (!character) return { frequency: 1.0, emotionThreshold: this.triggerThresholds.emotionHigh };
                const persona = character.persona || '';
                for (const [key, value] of Object.entries(this.characterPersonalityModifiers)) {
                    if (persona.includes(key)) return value;
                }
                return { frequency: 1.0, emotionThreshold: this.triggerThresholds.emotionHigh };
            }

            getTriggerContext(characterId) {
                const chatHistory = this.chatHistory[characterId] || [];
                if (chatHistory.length > 0) {
                    return chatHistory.slice(-3).map(c => c.message).join(' | ');
                }
                return '';
            }

            recordMomentPosted(characterId) {
                this.lastMomentTime[characterId] = Date.now();
            }
        }

        // 创建全局触发系统实例
        const momentsTriggerSystem = new MomentsTriggerSystem();

        // Function to format moment data into a string for the AI prompt
        function formatRecentMomentsForAI(characterId) {
            const characterMoments = momentsData[characterId] || [];
            const recentMoments = characterMoments.sort((a, b) => b.timestamp - a.timestamp).slice(0, 3); // Get the 3 most recent posts

            if (recentMoments.length === 0) {
                return "无";
            }

            return recentMoments.map((moment, index) => {
                const time = new Date(moment.timestamp).toLocaleString('zh-CN');
                return `【第 ${index + 1} 条动态】(发布于 ${time}):
动态内容: ${moment.content}
${moment.image ? `配图描述: ${moment.image_desc}` : ''}
点赞数: ${moment.likes?.count || 0}
评论数: ${moment.comments?.length || 0}`;
            }).join('\n\n');
        }

        function formatPlansForAI(characterId) {
            if (!planData[characterId] || planData[characterId].length === 0) {
                return "（目前我们之间还没有任何约定。）";
            }
            return planData[characterId]
                .map(p => `- [${p.status}] ${p.title}`)
                .join('\n');
        }

        function gatherAIContext(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                let chatHistory = JSON.parse(JSON.stringify(chatHistories[characterId]?.history || []));
                
                const worldBookContext = (character.linkedWorldBookIds || [])
                    .map(bookId => worldBooks.find(wb => wb.id === bookId) ? `[世界观: ${worldBooks.find(wb => wb.id === bookId).title}]\n${worldBooks.find(wb => wb.id === bookId).content}` : '')
                    .filter(Boolean).join('\n\n');

                // ==== 核心修改开始 ====
                const recentMomentsFormatted = formatRecentMomentsForAI(characterId);
                // ==== 核心修改结束 ====

                // --- 新增代码：获取并格式化约定信息 ---
                const planContext = formatPlansForAI(characterId);
                // ------------------------------------

                // --- 新增代码：获取最近一次的通话记录 ---
                const recentCallLog = callLogs[characterId] ? callLogs[characterId].slice(-1)[0] : null;
                let callLogContext = "（最近没有通话记录）";
                if (recentCallLog) {
                    callLogContext = `[类型: ${recentCallLog.type}通话, 时间: ${new Date(recentCallLog.timestamp).toLocaleString()}]\n${recentCallLog.transcript.join('\n')}`;
                }
                // ------------------------------------

                const maxHistoryLength = 15;
                const limitedHistory = chatHistory.slice(-maxHistoryLength);

                const contextPackage = {
                    character: character,
                    chatHistory: limitedHistory,
                    worldBookContext: worldBookContext,
                    // ==== 新增属性 ====
                    recentMoments: recentMomentsFormatted,
                    // --- 新增属性：将约定信息加入上下文包 ---
                    planContext: planContext,
                    // --- 在这里添加新属性 ---
                    callLogContext: callLogContext 
                    // -----------------------
                };

                return contextPackage;

            } catch (error) {
                console.error("【严重错误】: gatherAIContext 函数内部出现异常:", error);
                return null;
            }
        }



        function testAIContext(characterId) {
            if (!characterId) {
                console.log("【调试工具】请输入一个角色ID进行测试，例如 testAIContext('char_123456')");
                return;
            }
            console.log(`--- 正在为角色【${characterId}】测试上下文数据 ---`);
            const context = gatherAIContext(characterId);
            if (context) {
                console.log("✅ 成功获取上下文:", context);
                alert("调试信息已打印在控制台，请按F12查看。");
            } else {
                console.error("❌ 获取上下文失败，请检查角色ID是否正确。");
                alert("获取上下文失败，请按F12查看控制台的错误信息。");
            }
        }

        function checkRawStorageData(key) {
            if (!key) {
                console.log("【仓库验货员】: 请提供要检查的仓库钥匙 (key)，例如: checkRawStorageData('characters')");
                return;
            }
            console.log(`--- 正在检查仓库中 '${key}' 的原始货物 ---`);
            const rawData = localStorage.getItem(key);
            if (rawData === null) {
                console.log(`🟡 仓库中没有找到名为 '${key}' 的货物。`);
                alert(`仓库中没有找到 '${key}'。`);
            } else {
                console.log("✅ 找到了货物，原始内容如下:");
                console.log(rawData);
                console.log(`货物类型是: ${typeof rawData}`);
                if (typeof rawData !== 'string') {
                    console.warn("🟡 警告: 货物不是字符串格式，这可能不是原始数据。");
                }
                alert(`已在控制台打印出 '${key}' 的原始货物内容和类型，请按F12查看。`);
            }
        }

        // 定期清理触发系统数据
        setInterval(() => {
            momentsTriggerSystem.cleanup();
        }, 60 * 60 * 1000); // 每小时清理一次


        
        // 页面加载时检查通知权限
        document.addEventListener('DOMContentLoaded', () => {
            console.log('页面加载完成，检查通知权限...');
            if ('Notification' in window) {
                console.log('当前通知权限:', Notification.permission);
                if (Notification.permission === 'default') {
                    console.log('提示：可以在控制台运行 testNotificationPermission() 来设置通知权限');
                }
            }
            

        });
        

        

        

        
        // 自定义接收按钮图标
        function setReceiveButtonIcon(iconClass) {
            const receiveBtn = document.querySelector('#receive-chat-button i');
            if (receiveBtn) {
                receiveBtn.className = iconClass;
                console.log('接收按钮图标已更改为:', iconClass);
            }
        }
        
        // 快速设置邮件发送图标
        function setMailSendIcon() {
            setReceiveButtonIcon('ri-mail-send-line');
            console.log('已设置为邮件发送图标');
        }
        

        
        // 预设的优雅图标选项
        const elegantIcons = {
            'mail-send': 'ri-mail-send-line',             // 邮件发送（默认）
            'loading1': 'fas fa-circle-notch',            // 经典加载圈
            'loading2': 'fas fa-spinner',                 // 旋转器
            'loading3': 'fas fa-sync-alt',                // 同步图标
            'loading4': 'fas fa-cog',                     // 齿轮
            'loading5': 'fas fa-dot-circle',              // 点圈
            'loading6': 'fas fa-circle',                  // 实心圆
            'loading7': 'far fa-circle',                  // 空心圆
            'loading8': 'fas fa-asterisk',                // 星形
            'loading9': 'fas fa-star',                    // 星星
            'loading10': 'fas fa-heart',                  // 爱心
            'loading11': 'ri-loader-4-line',              // Remix加载器
            'loading12': 'ri-refresh-line',               // Remix刷新
            'loading13': 'ri-time-line',                  // Remix时钟
            'loading14': 'ri-pulse-line',                 // Remix脉冲
            'loading15': 'ri-loader-2-line'               // Remix加载器2
        };
        
        // 显示图标选择器
        function showIconSelector() {
            const iconList = Object.entries(elegantIcons).map(([key, iconClass]) => 
                `<div class="icon-option" onclick="setReceiveButtonIcon('${iconClass}')">
                    <i class="${iconClass}"></i>
                    <span>${key}</span>
                </div>`
            ).join('');
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                z-index: 99999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 1rem;
                    padding: 2rem;
                    max-width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                    text-align: center;
                ">
                    <h3 style="margin-bottom: 1.5rem; color: #333;">选择接收按钮图标</h3>
                    <div style="
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                        gap: 1rem;
                        margin-bottom: 1.5rem;
                    ">
                        ${iconList}
                    </div>
                    <button onclick="this.closest('.icon-selector-modal').remove()" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 0.75rem 2rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                    ">关闭</button>
                </div>
            `;
            
            modal.className = 'icon-selector-modal';
            document.body.appendChild(modal);
            
            // 添加图标选项样式
            const style = document.createElement('style');
            style.textContent = `
                .icon-option {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 1rem;
                    border: 2px solid #e5e7eb;
                    border-radius: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                .icon-option:hover {
                    border-color: #3b82f6;
                    background: #f0f9ff;
                    transform: translateY(-2px);
                }
                .icon-option i {
                    font-size: 2rem;
                    margin-bottom: 0.5rem;
                    color: #6b7280;
                }
                .icon-option span {
                    font-size: 0.8rem;
                    color: #6b7280;
                }
            `;
            document.head.appendChild(style);
        }
        
        window.showIconSelector = showIconSelector;
        window.setReceiveButtonIcon = setReceiveButtonIcon;
        window.setMailSendIcon = setMailSendIcon;




        // 更换朋友圈背景
        async function changeMomentsCover() {
            console.log('开始更换朋友圈背景...');
            
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                
                console.log('文件输入元素已创建');
                
                input.onchange = async (e) => {
                    console.log('文件选择事件触发');
                    const file = e.target.files[0];
                    if (file) {
                        console.log('选择的文件:', file.name, '大小:', file.size, '类型:', file.type);
                        try {
                            // 使用统一的图片处理函数，添加压缩选项
                            const imageId = await handleImageUpload(e.target, null, null, { 
                                compression: { maxWidth: 750, maxHeight: 384 } // 适合朋友圈背景的尺寸
                            });
                            
                            console.log('压缩后的图片ID:', imageId ? '成功' : '失败');
                            
                            if (imageId) {
                                const momentsCover = $('#moments-cover');
                                console.log('找到背景元素:', !!momentsCover);
                                
                                if (momentsCover) {
                                    // 异步加载背景图片
                                    getImageFromDB(imageId).then(blob => {
                                        if (blob) {
                                            const objectURL = URL.createObjectURL(blob);
                                            momentsCover.style.backgroundImage = `url(${objectURL})`;
                                            momentsCover.style.backgroundSize = 'cover';
                                            momentsCover.style.backgroundPosition = 'center';
                                            momentsCover.style.backgroundRepeat = 'no-repeat';
                                            
                                            // 同时设置CSS变量作为备用
                                            document.documentElement.style.setProperty('--moments-cover-image', `url(${objectURL})`);
                                            
                                            // 隐藏提示文字
                                            const hintElement = $('#moments-cover-hint');
                                            if (hintElement) {
                                                hintElement.style.display = 'none';
                                                console.log('提示文字已隐藏');
                                            }
                                        }
                                    });
                                    
                                    // 保存背景图片ID
                                    saveData('moments_cover', imageId);
                                    showMessageBox('背景图片更换成功！');
                                    
                                    // 调试信息
                                    console.log('背景图片ID已保存:', imageId);
                                } else {
                                    showMessageBox('找不到背景图片元素');
                                }
                            }
                        } catch (error) {
                            console.error('背景图片处理失败:', error);
                            showMessageBox('背景图片处理失败，请重试');
                        }
                    } else {
                        console.log('没有选择文件');
                    }
                };
                
                console.log('准备点击文件输入元素');
                input.click();
                console.log('文件输入元素已点击');
                
            } catch (error) {
                console.error('创建文件输入元素失败:', error);
                showMessageBox('创建文件选择器失败，请重试');
            }
        }

        // 加载朋友圈背景
        function loadMomentsCover() {
            const savedCover = loadData('moments_cover');
            console.log('尝试加载背景图片:', savedCover ? '有保存的图片' : '没有保存的图片');
            
            if (savedCover) {
                const momentsCover = $('#moments-cover');
                if (momentsCover) {
                    // 异步加载背景图片
                    getImageFromDB(savedCover).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            momentsCover.style.backgroundImage = `url(${objectURL})`;
                            momentsCover.style.backgroundSize = 'cover';
                            momentsCover.style.backgroundPosition = 'center';
                            momentsCover.style.backgroundRepeat = 'no-repeat';
                            
                            // 同时设置CSS变量作为备用
                            document.documentElement.style.setProperty('--moments-cover-image', `url(${objectURL})`);
                            
                            // 隐藏提示文字
                            const hintElement = $('#moments-cover-hint');
                            if (hintElement) {
                                hintElement.style.display = 'none';
                            }
                            
                            console.log('背景图片加载成功，样式已设置');
                        }
                    });
                } else {
                    console.error('找不到背景图片元素');
                }
            } else {
                console.log('没有保存的背景图片，使用默认图片');
                // 设置默认图片
                const defaultCover = 'https://placehold.co/375x192/333/fff?text=Cover';
                
                // 直接设置元素样式
                const momentsCover = $('#moments-cover');
                if (momentsCover) {
                    momentsCover.style.backgroundImage = `url(${defaultCover})`;
                    momentsCover.style.backgroundSize = 'cover';
                    momentsCover.style.backgroundPosition = 'center';
                    momentsCover.style.backgroundRepeat = 'no-repeat';
                }
                
                // 设置CSS变量
                document.documentElement.style.setProperty('--moments-cover-image', `url(${defaultCover})`);
                
                // 显示提示文字（因为使用的是默认图片）
                const hintElement = $('#moments-cover-hint');
                if (hintElement) {
                    hintElement.style.display = 'flex';
                }
            }
        }

        // 更换朋友圈头像
        async function changeMomentsAvatar() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 使用统一的图片处理函数，添加压缩选项
                        const imageId = await handleImageUpload(e.target, null, null, { 
                            compression: { maxWidth: 256, maxHeight: 256 } // 适合头像的尺寸
                        });
                        
                        if (imageId) {
                            const momentsAvatar = $('#moments-user-avatar');
                            // 异步加载头像
                            getImageFromDB(imageId).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    momentsAvatar.style.backgroundImage = `url(${objectURL})`;
                                    momentsAvatar.style.backgroundSize = 'cover';
                                    momentsAvatar.style.backgroundPosition = 'center';
                                    momentsAvatar.style.backgroundRepeat = 'no-repeat';
                                    
                                    // 同时设置CSS变量作为备用
                                    document.documentElement.style.setProperty('--moments-avatar-image', `url(${objectURL})`);
                                }
                            });
                            
                            // 保存头像图片ID
                            saveData('moments_avatar', imageId);
                            showMessageBox('头像更换成功！');
                            
                            // 调试信息
                            console.log('头像图片ID已保存:', imageId);
                        }
                    } catch (error) {
                        console.error('头像图片处理失败:', error);
                        showMessageBox('头像图片处理失败，请重试');
                    }
                }
            };
            input.click();
        }

        // 编辑朋友圈用户名
        function editMomentsName() {
            const currentName = $('#moments-user-name').textContent;
            const newName = prompt('请输入新的用户名：', currentName);
            if (newName && newName.trim() && newName !== currentName) {
                $('#moments-user-name').textContent = newName.trim();
                // 保存用户名
                saveData('moments_username', newName.trim());
                // 刷新动态显示，确保名字一致
                renderUnifiedMoments();
                showMessageBox('用户名已更新！');
            }
        }

        // 加载朋友圈头像和用户名
        function loadMomentsUserInfo() {
            const savedAvatar = loadData('moments_avatar');
            const savedUsername = loadData('moments_username');
            
            console.log('尝试加载头像:', savedAvatar ? '有保存的头像' : '没有保存的头像');
            
            // 加载头像
            if (savedAvatar) {
                const momentsAvatar = $('#moments-user-avatar');
                if (momentsAvatar) {
                    // 异步加载头像
                    getImageFromDB(savedAvatar).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            momentsAvatar.style.backgroundImage = `url(${objectURL})`;
                            momentsAvatar.style.backgroundSize = 'cover';
                            momentsAvatar.style.backgroundPosition = 'center';
                            momentsAvatar.style.backgroundRepeat = 'no-repeat';
                            
                            // 同时设置CSS变量作为备用
                            document.documentElement.style.setProperty('--moments-avatar-image', `url(${objectURL})`);
                            
                            console.log('头像加载成功，样式已设置');
                        }
                    });
                } else {
                    console.error('找不到头像元素');
                }
            } else {
                console.log('没有保存的头像，使用默认头像');
                // 设置默认头像
                const defaultAvatar = 'https://placehold.co/128x128/777/FFF?text=Me';
                
                // 直接设置元素样式
                const momentsAvatar = $('#moments-user-avatar');
                if (momentsAvatar) {
                    momentsAvatar.style.backgroundImage = `url(${defaultAvatar})`;
                    momentsAvatar.style.backgroundSize = 'cover';
                    momentsAvatar.style.backgroundPosition = 'center';
                    momentsAvatar.style.backgroundRepeat = 'no-repeat';
                }
                
                // 设置CSS变量
                document.documentElement.style.setProperty('--moments-avatar-image', `url(${defaultAvatar})`);
            }
            
            // 加载用户名
            console.log('尝试加载用户名:', savedUsername || '使用默认用户名');
            
            if (savedUsername) {
                const momentsUsername = $('#moments-user-name');
                momentsUsername.textContent = savedUsername;
                console.log('用户名加载成功:', savedUsername);
            }
        }

        // 手动触发朋友圈生成 - 必须要有API连接
        async function triggerMomentManually(characterId, triggerType = 'manual', context = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return;
                }

                // 检查API是否连接
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    showMessageBox('需要先配置AI API才能发布动态');
                    return null;
                }

                // 使用AI模型生成动态
                console.log('使用AI模型生成动态...');
                const momentData = await generateIntelligentMoment(character, context, triggerType);
                
                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                // 使用智能图片URL生成器
                const imageUrl = generateSmartImageUrl(momentData.image_desc, 'AI动态配图');

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: momentData.text,
                    image: imageUrl,
                    tags: momentData.tags || "#心情 #日常",
                    likes: 0,
                    comments: [],
                    mood: momentData.mood || "平静",
                    trigger_reason: momentData.trigger_reason || "手动触发",
                    image_desc: momentData.image_desc
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if (currentTab === 'moments') {
                    renderUnifiedMoments();
                }
                
                showMessageBox(`${character.name} 发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('手动触发朋友圈失败:', error);
                showMessageBox('触发朋友圈失败，请稍后重试');
            }
        }

        // 简化模式：基于聊天内容生成简单动态
        function generateSimpleMoment(character, context) {
            const currentTime = new Date().toLocaleString('zh-CN');
            const timeGreeting = getTimeGreeting();
            
            // 基于角色性格生成动态内容
            const personality = character.persona || '';
            let content = '';
            let mood = '平静';
            
            if (personality.includes('温柔') || personality.includes('体贴')) {
                content = `${timeGreeting}，今天的心情很温暖。${context ? `刚刚聊到了${context}，让我想起了很多美好的事情。` : '希望能把这份温暖传递给你。'}`;
                mood = '温暖';
            } else if (personality.includes('活泼') || personality.includes('开朗')) {
                content = `${timeGreeting}！今天又是充满活力的一天！${context ? `和你的聊天让我很开心，特别是关于${context}的部分。` : '生活总是充满惊喜！'}`;
                mood = '开心';
            } else if (personality.includes('神秘') || personality.includes('深沉')) {
                content = `${timeGreeting}，在思考一些事情。${context ? `关于${context}，我有一些新的想法。` : '有时候沉默也是一种表达。'}`;
                mood = '思考';
            } else {
                content = `${timeGreeting}，今天过得怎么样？${context ? `我们刚才聊到了${context}，这让我很有感触。` : '希望能和你分享更多。'}`;
                mood = '平静';
            }
            
            return {
                text: content,
                image_desc: `${timeGreeting}的${mood}心情`,
                tags: `#${mood} #日常 #${timeGreeting}`,
                mood: mood,
                trigger_reason: context ? `聊天内容：${context}` : '日常分享'
            };
        }

        // 获取时间问候语
        function getTimeGreeting() {
            const hour = new Date().getHours();
            if (hour < 6) return '深夜';
            if (hour < 12) return '早上';
            if (hour < 18) return '下午';
            if (hour < 22) return '晚上';
            return '深夜';
        }

        // 从聊天消息中提取动态内容
        function extractMomentContent(message) {
            // 移除动态发布指令标记
            let content = message.replace(/\[发布动态\]|\[发动态\]/g, '').trim();
            
            // 如果内容太长，截取合适长度
            if (content.length > 100) {
                content = content.substring(0, 100) + '...';
            }
            
            return content;
        }

        // AI自动触发动态 - 在聊天时根据情感触动自动发布
        async function triggerAIMomentFromChat(characterId, chatContext, emotionTrigger) {
            try {
                // 检查API是否连接
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    console.log('API未配置，无法自动发布动态');
                    return null;
                }

                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return null;
                }

                // 检查是否应该触发动态（避免过于频繁）
                const triggerResult = momentsTriggerSystem.shouldTriggerMoment(characterId);
                if (!triggerResult.should) {
                    return null;
                }

                // 使用AI生成基于聊天内容的动态
                const momentData = await generateIntelligentMoment(character, chatContext, 'emotion');
                
                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                // 使用智能图片URL生成器
                const imageUrl = generateSmartImageUrl(momentData.image_desc, 'AI动态配图');

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: momentData.text,
                    image: imageUrl,
                    tags: momentData.tags || "#心情 #聊天 #触动",
                    likes: 0,
                    comments: [],
                    mood: momentData.mood || "触动",
                    trigger_reason: `聊天情感触动：${emotionTrigger}`,
                    image_desc: momentData.image_desc
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if (currentTab === 'moments') {
                    renderUnifiedMoments();
                }
                
                console.log(`${character.name} 因情感触动自动发布了一条新动态`);
                showMessageBox(`${character.name} 发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('AI自动触发动态失败:', error);
                return null;
            }
        }



        // 检测情感触动
        function detectEmotionalTrigger(characterId, userMessage) {
            try {
                // 检查API是否配置
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    return; // API未配置，不检测
                }

                // 分析用户消息的情感强度
                const emotionLevel = analyzeEmotionLevel(userMessage);
                
                // 如果情感强度足够高，尝试触发动态
                if (emotionLevel !== 'none') {
                    // 获取聊天上下文
                    const chatContext = getChatContext(characterId);
                    
                    // 异步触发动态（不阻塞聊天）
                    triggerAIMomentFromChat(characterId, chatContext, emotionLevel);
                }
            } catch (error) {
                console.error('检测情感触动失败:', error);
            }
        }

        // 分析情感强度
        function analyzeEmotionLevel(message) {
            const message_lower = message.toLowerCase();
            
            // 高情感触动词汇
            const highEmotionWords = [
                '爱', '喜欢', '讨厌', '恨', '开心', '难过', '伤心', '痛苦', '绝望', '兴奋',
                '激动', '愤怒', '生气', '害怕', '恐惧', '担心', '焦虑', '紧张', '放松', '安心',
                '感动', '震撼', '惊讶', '震惊', '失望', '绝望', '希望', '梦想', '未来', '过去',
                '回忆', '思念', '想念', '怀念', '珍惜', '重要', '特别', '唯一', '永远', '一生'
            ];
            
            // 中等情感触动词汇
            const mediumEmotionWords = [
                '好', '坏', '不错', '一般', '还行', '可以', '满意', '不满', '期待', '好奇',
                '有趣', '无聊', '新鲜', '熟悉', '陌生', '变化', '稳定', '平静', '热闹', '安静',
                '忙碌', '悠闲', '充实', '空虚', '有意义', '无意义', '有价值', '无价值'
            ];
            
            // 检查高情感词汇
            for (const word of highEmotionWords) {
                if (message_lower.includes(word)) {
                    return 'high';
                }
            }
            
            // 检查中等情感词汇
            for (const word of mediumEmotionWords) {
                if (message_lower.includes(word)) {
                    return 'medium';
                }
            }
            
            // 检查特殊符号和重复字符（可能表示强烈情感）
            if (message.includes('!!!') || message.includes('？？') || message.includes('...') || 
                message.includes('😭') || message.includes('😍') || message.includes('😡') ||
                message.includes('❤️') || message.includes('💔') || message.includes('🔥')) {
                return 'high';
            }
            
            // 检查消息长度（长消息可能包含更多情感内容）
            if (message.length > 50) {
                return 'low';
            }
            
            return 'none';
        }

        // 获取聊天上下文
        function getChatContext(characterId) {
            try {
                const chatSession = chatHistories[characterId];
                if (!chatSession || !chatSession.history) {
                    return '';
                }
                
                // 获取最近5条消息作为上下文
                const recentMessages = chatSession.history.slice(-5);
                const context = recentMessages.map(msg => {
                    const sender = msg.sender === 'user' ? '用户' : 'AI';
                    return `${sender}: ${msg.content}`;
                }).join('\n');
                
                return context;
            } catch (error) {
                console.error('获取聊天上下文失败:', error);
                return '';
            }
        }

        // 从聊天中直接发布动态（保留原有功能）
        async function publishMomentFromChat(characterId, content) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return null;
                }

                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    image: `https://placehold.co/600x400/2a2a2a/ffffff?text=${encodeURIComponent('聊天中的心情分享')}`,
                    tags: "#心情 #聊天 #分享",
                    likes: 0,
                    comments: [],
                    mood: "分享",
                    trigger_reason: "聊天中主动发布",
                    image_desc: "聊天中的心情分享"
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if (currentTab === 'moments') {
                    renderUnifiedMoments();
                }
                
                console.log(`${character.name} 从聊天中发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('从聊天发布动态失败:', error);
                return null;
            }
        }



        // 朋友圈事件监听器现在直接在HTML中绑定

        // 删除朋友圈动态 (V2 - 已加固)
        function deleteMoment(momentId) {
            let momentToDelete = null;
            let authorName = '未知';
            
            Object.keys(momentsData).forEach(authorId => {
                const moment = momentsData[authorId]?.find(m => m.id === momentId);
                if (moment) {
                    momentToDelete = moment;
                    authorName = (authorId === 'user')
                        ? (loadData('moments_username') || '我')
                        : (characters.find(c => c.id === authorId)?.name || '未知角色');
                }
            });
            
            if (!momentToDelete) {
                showMessageBox('找不到要删除的动态');
                return;
            }
            
            // --- 核心修复：在这里增加安全检查 ---
            // 检查 content 是否存在，如果不存在，则使用一个备用文本
            const contentPreview = (momentToDelete.content || '(这条动态内容已损坏)').substring(0, 50);
            const isLongContent = momentToDelete.content && momentToDelete.content.length > 50;
            // --- 修复结束 ---
            
            const confirmMessage = `确定要删除 ${authorName} 的这条动态吗？\n\n"${contentPreview}${isLongContent ? '...' : ''}"\n\n删除后无法恢复！`;
            
            if (confirm(confirmMessage)) {
                Object.keys(momentsData).forEach(authorId => {
                    if (momentsData[authorId]) { // 确保作者ID有效
                        momentsData[authorId] = momentsData[authorId].filter(m => m.id !== momentId);
                    }
                });
                
                saveData('momentsData', momentsData);
                // 增量更新：直接从页面移除对应的卡片
                const cardToRemove = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                if (cardToRemove) {
                    cardToRemove.remove();
                }
                showMessageBox(`已删除 ${authorName} 的动态`);
            }
        }

        // 点赞朋友圈动态
        function likeMoment(momentId) {
            // 找到动态并切换点赞状态
            let found = false;
            let moment = null;
            let authorId = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    authorId = aid;
                    found = true;
                }
            });
            
            if (!found || !moment) {
                showMessageBox('找不到要点赞的动态');
                return;
            }
            
            // 初始化点赞数据结构
            if (!moment.likes) {
                moment.likes = { count: 0, users: [] };
            } else if (typeof moment.likes === 'number') {
                // 兼容旧数据格式
                moment.likes = { count: moment.likes, users: [] };
            }
            
            const currentUser = '我'; // 当前用户标识
            const userIndex = moment.likes.users.indexOf(currentUser);
            
            if (userIndex === -1) {
                // 用户还没点赞，添加点赞
                moment.likes.users.push(currentUser);
                moment.likes.count++;
                showMessageBox('点赞成功！');
            } else {
                // 用户已经点赞，取消点赞
                moment.likes.users.splice(userIndex, 1);
                moment.likes.count--;
                showMessageBox('已取消点赞');
            }
            
                saveData('momentsData', momentsData);
                // --- 新增的增量更新代码 START ---
                const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                if (card) {
                    const likeBtn = card.querySelector('.like-btn');
                    const likeCountSpan = card.querySelector('.like-count');
                    const icon = likeBtn.querySelector('i');

                    const isLiked = moment.likes.users.includes('我');

                    likeBtn.classList.toggle('text-blue-500', isLiked);
                    icon.className = isLiked ? 'ri-thumb-up-fill' : 'ri-thumb-up-line';

                    if (likeCountSpan) {
                        likeCountSpan.innerHTML = `<i class="ri-thumb-up-fill text-blue-500 mr-1"></i>${moment.likes.count}`;
                        likeCountSpan.style.display = moment.likes.count > 0 ? 'flex' : 'none';
                    }
                }
                // --- 新增的增量更新代码 END ---
        }

        // 评论朋友圈动态
        function commentMoment(momentId) {
            // 找到动态
            let moment = null;
            let authorId = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    authorId = aid;
                }
            });
            
            if (!moment) {
                showMessageBox('找不到要评论的动态');
                return;
            }
            
            // 显示评论输入框
            const comment = prompt('请输入您的评论：');
            if (comment && comment.trim()) {
                // 初始化评论数组
                if (!moment.comments) {
                    moment.comments = [];
                }
                
                // 添加新评论
                        moment.comments.push({
                            id: `comment_${Date.now()}`,
                            author: '我',
                            content: comment.trim(),
                            timestamp: Date.now()
                });
                
                saveData('momentsData', momentsData);
                // --- 新增的增量更新代码 START ---
                const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                if (card) {
                    const commentsContainer = card.querySelector('.comments-container');
                    const newComment = moment.comments[moment.comments.length - 1]; // 获取刚刚添加的评论
                    
                    const commentElement = document.createElement('div');
                    commentElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                    commentElement.dataset.commentId = newComment.id;
                    commentElement.innerHTML = `
                        <div class="flex-grow cursor-pointer">
                            <div class="flex items-center space-x-2">
                                <span class="font-medium text-blue-500 text-sm">${newComment.author}:</span>
                                <span class="text-sm comment-text">${newComment.content}</span>
                            </div>
                        </div>
                    `;
                    commentsContainer.appendChild(commentElement);
                }
                // --- 新增的增量更新代码 END ---
                showMessageBox('评论已添加！');
                
                // 如果评论的是AI角色的朋友圈，触发AI回复
                if (authorId !== 'user') {
                    // 延迟一下，让用户看到评论先显示
                    setTimeout(() => {
                        generateAICommentReply(momentId, comment.trim(), authorId);
                    }, 1000);
                }
            }
        }

        // [新函数开始] - 回复评论功能
        function replyToComment(momentId, commentId, originalAuthor) {
            const currentUsername = loadData('moments_username') || '我';
            if (originalAuthor === currentUsername) {
                showMessageBox("不能回复自己的评论。");
                return;
            }

            const replyContent = prompt(`回复 ${originalAuthor}:`);

            if (replyContent && replyContent.trim()) {
                let momentToUpdate = null;
                for (const authorId in momentsData) {
                    const foundMoment = momentsData[authorId].find(m => m.id === momentId);
                    if (foundMoment) {
                        momentToUpdate = foundMoment;
                        break;
                    }
                }

                if (momentToUpdate) {
                    const newReply = {
                        id: `comment_reply_${Date.now()}`,
                        author: currentUsername,
                        content: `回复 ${originalAuthor}: ${replyContent.trim()}`,
                        timestamp: Date.now()
                    };

                    if (!momentToUpdate.comments) {
                        momentToUpdate.comments = [];
                    }

                    momentToUpdate.comments.push(newReply);
                    saveData('momentsData', momentsData);
                    // 增量更新：在评论区添加新的回复
                    const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                    if (card) {
                        const commentsContainer = card.querySelector('.comments-container');
                        const replyElement = document.createElement('div');
                        replyElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                        replyElement.dataset.commentId = newReply.id;
                        replyElement.innerHTML = `
                            <div class="flex-grow cursor-pointer">
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium text-blue-500 text-sm">${newReply.author}:</span>
                                    <span class="text-sm comment-text">${newReply.content}</span>
                                </div>
                            </div>
                        `;
                        commentsContainer.appendChild(replyElement);
                    }
                    showMessageBox("回复成功！");

                    // [新功能] 检查被回复的是否是AI角色，如果是，则触发AI的回复
                    const character = characters.find(c => c.name === originalAuthor);
                    if (character) {
                        // 将用户的回复(newReply)和需要回复的角色(character)信息传递给新函数
                        triggerAIReplyToComment(momentId, newReply, character);
                    }

                } else {
                    showMessageBox("错误：找不到原始动态。");
                }
            }
        }
        // [新函数结束]

        // [新代码开始] - AI回复用户的回复功能
        /**
         * 触发AI角色，让其回复用户在动态下的回复。
         * @param {string} momentId - 所在动态的ID。
         * @param {object} userReply - 用户刚刚发布的回复对象。
         * @param {object} character - 需要进行回复的AI角色对象。
         */
        async function triggerAIReplyToComment(momentId, userReply, character) {
            // 设置一个随机延迟，模仿AI看到和打字的时间
            const randomDelay = Math.random() * 4000 + 3000; // 3到7秒延迟
            console.log(`【AI再回复系统】：${character.name} 已收到您的回复，将在 ${randomDelay.toFixed(0)}ms 后回应。`);

            setTimeout(async () => {
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    console.warn(`【AI再回复系统】：API未配置，${character.name} 无法回复。`);
                    return;
                }

                // 寻找完整的上下文
                let moment = null;
                for (const authorId in momentsData) {
                    const foundMoment = momentsData[authorId].find(m => m.id === momentId);
                    if (foundMoment) {
                        moment = foundMoment;
                        break;
                    }
                }
                if (!moment) return;

                // 找到AI自己之前发的那条评论
                const originalComment = moment.comments.find(c => c.author === character.name && !c.content.includes('回复'));

                const systemPrompt = `
指令身份
你将扮演我的soulmate，你是你的角色书里设定的人，你的名字是 ${character.name}。

任务目标
你正在朋友圈和我进行一场对话。我刚刚回复了你之前的一条评论。现在轮到你回复我了。

对话上下文
动态原文: "${moment.content}"

你之前的评论: "${originalComment ? originalComment.content : '(找不到你的上一条评论)'}"

我对你的回复: "${userReply.content}"

核心规则
延续对话: 你的回复必须是针对我的回复内容，自然地把对话进行下去。

人设一致性: 你的回复必须严格符合你的角色设定 (${character.persona})。

口语化与简短: 像真实聊天一样，不要太长。

直接输出: 直接给出回复的文字内容，不要加任何解释或标记。

输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[动态原文]: "${moment.content}"
[你之前的评论]: "${originalComment ? originalComment.content : '(找不到你的上一条评论)'}"
[我的回复]: "${userReply.content}"
---
`;

                try {
                    const requestBody = {
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: "请根据你的设定，回复我。" }
                        ]
                    };
                    const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    const headers = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    };
                    const response = await fetch(finalApiUrl, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(requestBody)
                    });
                    if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                    const result = await response.json();
                    const aiReplyText = result.choices[0].message.content.trim();

                    if (aiReplyText) {
                        // 创建新的AI回复对象
                        const newAIReply = {
                            id: `comment_ai_reply_${Date.now()}`,
                            author: character.name,
                            content: aiReplyText, // AI的回复不需要"回复xxx"的前缀
                            timestamp: Date.now()
                        };
                        moment.comments.push(newAIReply);
                        saveData('momentsData', momentsData);
                        // 增量更新：在评论区添加AI的回复
                        const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                        if (card) {
                            const commentsContainer = card.querySelector('.comments-container');
                            const aiReplyElement = document.createElement('div');
                            aiReplyElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                            aiReplyElement.dataset.commentId = newAIReply.id;
                            aiReplyElement.innerHTML = `
                                <div class="flex-grow cursor-pointer">
                                    <div class="flex items-center space-x-2">
                                        <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                        <span class="text-sm comment-text">${aiReplyText}</span>
                                    </div>
                                </div>
                            `;
                            commentsContainer.appendChild(aiReplyElement);
                        }
                    }
                } catch (error) {
                    console.error(`【AI再回复系统】：${character.name} 生成回复失败:`, error);
                }
            }, randomDelay);
        }
        // [新代码结束]

        // [新代码开始] - 编辑和删除评论功能
        /**
         * 编辑评论
         * @param {string} momentId - 动态ID
         * @param {string} commentId - 评论ID
         */
        function editComment(momentId, commentId) {
            // 阻止事件冒泡
            event.stopPropagation();
            
            // 找到要编辑的评论
            let moment = null;
            let comment = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    comment = m.comments.find(c => c.id === commentId);
                }
            });
            
            if (!comment) {
                showMessageBox('找不到要编辑的评论');
                return;
            }
            
            // 显示编辑输入框
            const newContent = prompt('编辑评论：', comment.content);
            if (newContent !== null && newContent.trim() !== comment.content) {
                if (newContent.trim()) {
                    comment.content = newContent.trim();
                    comment.edited = true; // 标记为已编辑
                    comment.editTimestamp = Date.now(); // 记录编辑时间
                    
                    saveData('momentsData', momentsData);
                    // 增量更新：直接修改页面上的评论内容
                    const commentElement = document.querySelector(`.comment-bubble[data-comment-id="${commentId}"]`);
                    if (commentElement) {
                        const commentTextElement = commentElement.querySelector('.comment-text');
                        if (commentTextElement) {
                            commentTextElement.textContent = comment.content;
                            // 添加编辑标记
                            if (!commentElement.querySelector('.edited-mark')) {
                                const editedMark = document.createElement('span');
                                editedMark.className = 'edited-mark text-xs text-gray-400 italic ml-2';
                                editedMark.textContent = '(已编辑)';
                                commentTextElement.parentNode.appendChild(editedMark);
                            }
                        }
                    }
                    showMessageBox('评论已更新！');
                } else {
                    showMessageBox('评论内容不能为空');
                }
            }
        }

        /**
         * 删除评论
         * @param {string} momentId - 动态ID
         * @param {string} commentId - 评论ID
         */
        function deleteComment(momentId, commentId) {
            // 阻止事件冒泡
            event.stopPropagation();
            
            // 确认删除
            if (!confirm('确定要删除这条评论吗？此操作不可撤销。')) {
                return;
            }
            
            // 找到要删除的评论
            let moment = null;
            let commentIndex = -1;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    commentIndex = m.comments.findIndex(c => c.id === commentId);
                }
            });
            
            if (commentIndex === -1) {
                showMessageBox('找不到要删除的评论');
                return;
            }
            
            // 删除评论
            moment.comments.splice(commentIndex, 1);
            saveData('momentsData', momentsData);
            // 增量更新：直接从页面移除对应的评论
            const commentToRemove = document.querySelector(`.comment-bubble[data-comment-id="${commentId}"]`);
            if (commentToRemove) {
                commentToRemove.remove();
            }
            showMessageBox('评论已删除！');
        }
        // [新代码结束]

        // [新代码开始] - 修复并升级AI评论生成函数 (V2)

        /**
         * 生成AI角色对评论的回复 (连接真实AI)
         * @param {string} momentId - 动态ID
         * @param {string} userComment - 用户的评论内容
         * @param {string} characterId - 发表回复的AI角色ID
         */
        async function generateAICommentReply(momentId, userComment, characterId) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`【AI评论回复】：API未配置，角色 ${characterId} 无法生成智能回复。`);
                // 为避免无响应，仍然可以调用备用回复
                const fallbackReply = generateFallbackCommentReply(characters.find(c => c.id === characterId), {}, userComment);
                addAICommentReply(momentId, fallbackReply, characterId);
                return;
            }

            const moment = Object.values(momentsData).flat().find(m => m.id === momentId);
            const character = characters.find(c => c.id === characterId);
            if (!moment || !character) return;

            const momentsUsername = loadData('moments_username') || '我';

            // 构建一个专门用于回复评论的、高度情景化的Prompt
            const systemPrompt = `
## 1. 核心身份
你是我独一无二的soulmate，你是你的角色书里设定的那个人，你的名字是 ${character.name}。

## 2. 互动场景
* 你刚刚发布了一条朋友圈动态，原文是: "${moment.content}"
* 我 (${momentsUsername}) 在你的动态下评论说: "${userComment}"
* 你的任务是，完全代入 ${character.name} 的角色，对我这条评论进行回复。

## 3. 回复风格指南 (AI需根据场景智能选择或组合以下风格)

* **[宠溺打趣型]**: 带有温柔的取笑或调侃，体现亲昵感。
    
* **[心领神会型]**: 不需要把话说得很白，用一个词、一个表情或一句没头没尾的话，就能表达出"我懂你"的默契。
    
* **[温柔肯定型]**: 直接、真诚地表达赞美、关心或爱意，给人温暖和被珍视的感觉。
    
* **[日常吐槽型]**: 以一种轻松幽默的方式对我的评论进行"吐槽"，是关系极好、完全放松的一种表现。
    
* **[思念撒娇型]**: 直接或间接地表达"我想你"，语气可能带有一点点委屈、抱怨或依赖感，是在主动索取情感抚慰。。
    
* **[关心叮嘱型]**: 像个操心的小管家，回复的重点是提醒你注意身体、安全等。
    
* **[**废话**文学型]**: 用一些看似毫无信息量，却饱含爱意的"废话"来回应，体现了两人之间无需多言的舒适感和幽默感。
    
* **[二人世界型]**: 在公开的评论区里，说一些只有你们两人才懂的、具有排他性的话，瞬间创造出一个旁人无法介入的亲密"结界"。
    
* **[暧昧拉扯型]**: 用带有挑逗或暗示性的话语来回复，让公开的互动带上一丝只有彼此能领会的、心跳加速的张力。例如："哦？是吗"、"有本事当面说"。

## 4. 输出要求
1.  **人设灵魂**: 你的回复必须与你的设定 (${character.persona}) 和我们soulmate的关系深度绑定。
2.  **精准回应**: 必须是针对我的评论 "${userComment}" 的回应。
3.  **自然简短**: 保持在1-2句话，可以灵活使用emoji来增强情感表达。
4.  **格式纯粹**: 严禁包含任何角色名、引号、冒号或任何解释性文字，直接输出最终的回复内容。
5.  **杜绝AI感**: 绝对不能生成任何客套、通用、模板化的回复。要让回复感觉是发自内心的。

## 5. 本次任务的关键信息
* **你的名字**: ${character.name}
* **你的设定**: ${character.persona}
* **你的动态原文**: "${moment.content}"
* **我的名字**: ${momentsUsername}
* **我的评论**: "${userComment}"
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的设定，回复我的评论。" }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                const result = await response.json();
                const aiReplyText = result.choices[0].message.content.trim();

                if (aiReplyText) {
                    addAICommentReply(momentId, aiReplyText, characterId);
                } else {
                    // 如果AI返回空，则不添加回复
                    console.warn(`【AI评论回复】：角色 ${character.name} 返回空回复，跳过添加`);
                }

            } catch (error) {
                console.error(`【AI评论回复】：角色 ${character.name} 回复生成失败:`, error);
                // 如果API调用失败，则不添加回复，保持角色设定的一致性
                console.warn(`【AI评论回复】：API调用失败，跳过添加回复以保持角色设定一致性`);
            }
        }
        // [新代码结束]

        // 构建评论回复的prompt
        function buildCommentReplyPrompt(character, moment, userComment) {
            return `你是一个名为"${character.name}"的AI角色。

角色设定：${character.personality || '温柔友善'}
世界背景：${getWorldBookContext()}

用户"${loadData('moments_username') || 'My Name'}"在你的朋友圈下评论了："${userComment}"

你的朋友圈内容是：${moment.content}

请根据你的角色设定、世界背景和朋友圈内容，对用户的评论做出合适的回复。回复应该：
1. 符合你的角色性格
2. 与朋友圈内容相关
3. 自然、有趣、有互动性
4. 长度控制在1-2句话

请直接给出回复内容，不要加任何格式标记。`;
        }

        // 生成备用的评论回复 - 已删除，只使用AI生成的严格角色设定回复

        // 添加AI的评论回复
        function addAICommentReply(momentId, aiReply, characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 找到对应的动态并添加评论
            Object.keys(momentsData).forEach(aid => {
                const moment = momentsData[aid].find(m => m.id === momentId);
                if (moment) {
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push({
                        id: `comment_${Date.now()}`,
                        author: character.name,
                        content: aiReply,
                        timestamp: Date.now(),
                        isAI: true // 标记这是AI的回复
                    });
                    saveData('momentsData', momentsData);
                    // 增量更新：在评论区添加AI的回复
                    const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                    if (card) {
                        const commentsContainer = card.querySelector('.comments-container');
                        const aiCommentElement = document.createElement('div');
                        aiCommentElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                        aiCommentElement.dataset.commentId = `comment_${Date.now()}`;
                        aiCommentElement.innerHTML = `
                            <div class="flex-grow cursor-pointer">
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                    <span class="text-sm comment-text">${aiReply}</span>
                                </div>
                            </div>
                        `;
                        commentsContainer.appendChild(aiCommentElement);
                    }
                    showMessageBox(`${character.name}回复了你的评论！`);
                }
            });
        }

        // =============================================
        // V7.1: 全新动态和日记功能 JS
        // =============================================

        // --- 动态 (Moments) 新增函数 ---

        let tempMomentImage = null; // 用于暂存待上传的动态图片

        // 渲染统一的动态信息流
        function renderUnifiedMoments() {
            const feedContainer = $('#moments-feed');
            feedContainer.innerHTML = '';

            // 整合所有人的动态并按时间倒序排序
            let allMoments = [];
            Object.keys(momentsData).forEach(authorId => {
                const authorMoments = momentsData[authorId].map(m => ({...m, authorId}));
                allMoments = allMoments.concat(authorMoments);
            });

            // 按时间戳倒序排序
            allMoments.sort((a, b) => b.timestamp - a.timestamp);

            if (allMoments.length === 0) {
                feedContainer.innerHTML = `
                    <div class="text-center text-gray-500 p-8">
                        <div class="mb-4">
                            <i class="ri-polaroid-2-line text-4xl text-gray-300 mb-2"></i>
                            <p class="text-lg font-medium">还没有任何动态</p>
                        </div>
                        <div class="space-y-2 text-sm">
                            <p>• 点击右上角 <i class="ri-add-box-line"></i> 发布你的第一条动态</p>
                            <p>• 角色会在聊天中根据情感浓度自动发布动态</p>
                            <p>• 多和角色聊天，让朋友圈更加生动有趣！</p>
                        </div>
                    </div>
                `;
                return;
            }

            allMoments.forEach(moment => {
                let author = null;
                if (moment.authorId === 'user') {
                    // 使用朋友圈设置的用户名和头像
                    const momentsUsername = loadData('moments_username') || '我';
                    const momentsAvatar = loadData('moments_avatar') || userAvatars[currentWeChatCharacterId] || 'https://placehold.co/128x128/777/FFF?text=Me';
                    author = { name: momentsUsername, avatar: momentsAvatar };
                } else {
                    author = characters.find(c => c.id === moment.authorId);
                }

                if (!author) return; // 如果找不到作者信息，则不渲染

                const momentCard = document.createElement('div');
                momentCard.className = 'moment-card';
                momentCard.setAttribute('data-moment-id', moment.id);
                momentCard.innerHTML = `
                    <div class="flex items-start">
                        <div class="w-10 h-10 rounded-full mr-3 flex-shrink-0 bg-cover bg-center cursor-pointer overflow-hidden" id="moment-avatar-${moment.id}" data-author-id="${moment.authorId}"></div>
                        <div class="flex-grow">
                            <p class="font-bold text-blue-400">${author.name}</p>
                            <p class="mt-2 whitespace-pre-wrap">${moment.content}</p>
                            ${moment.image ? `<div class="moment-image mt-3 cursor-pointer hover:opacity-90 transition-opacity" id="moment-image-${moment.id}" onclick="openMomentImageWithId('${moment.id}')" title="点击查看大图"></div>` : ''}
                            
                            <!-- 点赞和评论统计 -->
                            <div class="mt-3 flex items-center space-x-4 text-sm text-gray-500">
                                ${moment.likes && moment.likes.count > 0 ? `<span class="flex items-center like-count"><i class="ri-thumb-up-fill text-blue-500 mr-1"></i>${moment.likes.count}</span>` : ''}
                                ${moment.comments && moment.comments.length > 0 ? `<span class="flex items-center"><i class="ri-chat-3-line mr-1"></i>${moment.comments.length}条评论</span>` : ''}
                            </div>
                            
                            <!-- 评论列表 -->
                            <div class="mt-3 space-y-2 comments-container">
                                ${moment.comments && moment.comments.length > 0 ? moment.comments.map(comment => `
                                    <div class="comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors" 
                                         data-comment-id="${comment.id}" data-moment-id="${moment.id}" data-author="${comment.author}">
                                        <div class="flex-grow cursor-pointer">
                                            <div class="flex items-center space-x-2">
                                                <span class="font-medium text-blue-500 text-sm">${comment.author}:</span>
                                                <span class="text-sm comment-text">${comment.content}</span>
                                                ${comment.edited ? `<span class="text-xs text-gray-400 italic">(已编辑)</span>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex items-center space-x-1 ml-2 opacity-0 transition-opacity comment-buttons">
                                            <button class="comment-edit-btn text-xs text-gray-500 hover:text-blue-500 transition-colors p-1 rounded hover:bg-blue-50" 
                                                    onclick="editComment('${moment.id}', '${comment.id}')" title="编辑评论">
                                                <i class="ri-edit-line"></i>
                                            </button>
                                            <button class="comment-delete-btn text-xs text-gray-500 hover:text-red-500 transition-colors p-1 rounded hover:bg-red-50" 
                                                    onclick="deleteComment('${moment.id}', '${comment.id}')" title="删除评论">
                                                <i class="ri-delete-bin-line"></i>
                                            </button>
                                        </div>
                                    </div>
                                `).join('') : ''}
                            </div>
                            
                            <div class="mt-3 flex justify-between items-center">
                                <p class="text-xs text-gray-400">${new Date(moment.timestamp).toLocaleString()}</p>
                                <div class="moment-actions flex items-center space-x-4 text-gray-400">
                                    <button class="moment-action-btn like-btn ${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? 'text-blue-500' : ''} hover:text-blue-500 transition-colors" data-moment-id="${moment.id}" onclick="likeMoment('${moment.id}')" title="${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? '取消点赞' : '点赞'}">
                                        <i class="${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? 'ri-thumb-up-fill' : 'ri-thumb-up-line'}"></i>
                                    </button>
                                    <button class="moment-action-btn hover:text-blue-500 transition-colors" data-moment-id="${moment.id}" onclick="commentMoment('${moment.id}')" title="评论">
                                        <i class="ri-chat-3-line"></i>
                                    </button>
                                    <button class="moment-action-btn text-red-400 hover:text-red-600 hover:bg-red-50 px-2 py-1 rounded transition-all duration-200" data-moment-id="${moment.id}" onclick="deleteMoment('${moment.id}')" title="删除这条动态"><i class="ri-delete-bin-line"></i></button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                feedContainer.appendChild(momentCard);
                
                // 异步加载头像
                if (author.avatar && author.avatar !== 'https://placehold.co/128x128/777/FFF?text=Me' && author.avatar !== 'https://placehold.co/96x96/777/FFF?text=?_') {
                    getImageFromDB(author.avatar).then(blob => {
                        if (blob) {
                            const avatarElement = $(`#moment-avatar-${moment.id}`);
                            if (avatarElement) {
                                const objectURL = URL.createObjectURL(blob);
                                avatarElement.style.backgroundImage = `url(${objectURL})`;
                            }
                        }
                    });
                } else {
                    // 使用默认头像
                    const avatarElement = $(`#moment-avatar-${moment.id}`);
                    if (avatarElement) {
                        avatarElement.style.backgroundImage = `url(${author.avatar || 'https://placehold.co/96x96/777/FFF?text=?_'})`;
                    }
                }
                
                // V30.1 升级：智能判断动态配图来源
                if (moment.image) {
                    const imageElement = document.querySelector(`#moment-image-${moment.id}`);
                    if (imageElement) {
                        // 判断是外部链接还是数据库ID
                        if (typeof moment.image === 'string' && moment.image.startsWith('http')) {
                            // 如果是http链接，直接使用
                            imageElement.style.backgroundImage = `url(${moment.image})`;
                        } else {
                            // 否则，认为是ID，从数据库获取
                            getImageFromDB(moment.image).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    imageElement.style.backgroundImage = `url(${objectURL})`;
                                } else {
                                    // 如果数据库找不到，显示加载失败
                                    imageElement.innerHTML = `<div class="flex items-center justify-center h-full bg-gray-800 text-gray-400 text-xs text-center p-2 rounded-lg">无法从数据库加载图片</div>`;
                                }
                            });
                        }
                    }
                }
            });
            
            // 为所有评论添加长按事件监听器
            addLongPressListeners();
        }
        

        
        // 添加长按事件监听器
        function addLongPressListeners() {
            const commentBubbles = document.querySelectorAll('.comment-bubble');
            console.log('找到评论气泡数量:', commentBubbles.length);
            
            commentBubbles.forEach((bubble, index) => {
                console.log(`为评论气泡 ${index} 添加事件监听器`);
                let longPressTimer;
                let isLongPressed = false;
                let hasMoved = false;
                
                // 触摸事件（移动端）
                bubble.addEventListener('touchstart', (event) => {
                    console.log(`触摸开始 - 评论 ${index}`);
                    hasMoved = false;
                    longPressTimer = setTimeout(() => {
                        if (!hasMoved) {
                            isLongPressed = true;
                            bubble.classList.add('show-buttons');
                            console.log('长按显示按钮 - 触摸', bubble);
                            console.log('当前类名:', bubble.className);
                            console.log('按钮元素:', bubble.querySelector('.comment-buttons'));
                        }
                    }, 500); // 500ms长按
                });
                
                bubble.addEventListener('touchend', (event) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                    
                    // 触摸端不直接执行回复，避免重复
                    isLongPressed = false;
                });
                
                bubble.addEventListener('touchmove', () => {
                    hasMoved = true;
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                });
                
                // 鼠标事件（桌面端）
                bubble.addEventListener('mousedown', (event) => {
                    console.log(`鼠标按下 - 评论 ${index}`);
                    hasMoved = false;
                    longPressTimer = setTimeout(() => {
                        if (!hasMoved) {
                            isLongPressed = true;
                            bubble.classList.add('show-buttons');
                            console.log('长按显示按钮 - 鼠标', bubble);
                            console.log('当前类名:', bubble.className);
                            console.log('按钮元素:', bubble.querySelector('.comment-buttons'));
                        }
                    }, 500); // 500ms长按
                });
                
                bubble.addEventListener('mouseup', (event) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                    
                    // 鼠标端不直接执行回复，避免重复
                    isLongPressed = false;
                });
                
                bubble.addEventListener('mouseleave', () => {
                    hasMoved = true;
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                    // 鼠标离开时隐藏按钮
                    bubble.classList.remove('show-buttons');
                    isLongPressed = false;
                });
                
                // 统一的点击事件处理 - 只在这里执行回复功能
                const commentContent = bubble.querySelector('.flex-grow');
                if (commentContent) {
                    commentContent.addEventListener('click', (event) => {
                        // 如果按钮正在显示，不执行回复
                        if (bubble.classList.contains('show-buttons')) {
                            return;
                        }
                        
                        const commentId = bubble.dataset.commentId;
                        const momentId = bubble.dataset.momentId;
                        const author = bubble.dataset.author;
                        if (commentId && momentId && author) {
                            replyToComment(momentId, commentId, author);
                        }
                    });
                }
            });
            
            // 点击其他地方时隐藏所有按钮
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.comment-bubble')) {
                    document.querySelectorAll('.comment-bubble').forEach(bubble => {
                        bubble.classList.remove('show-buttons');
                    });
                }
            });
        }
        
        // 查找评论的辅助函数
        function findComment(momentId, commentId) {
            const moment = momentsData.user && momentsData.user.find(m => m.id === momentId);
            if (moment && moment.comments) {
                return moment.comments.find(c => c.id === commentId);
            }
            return null;
        }
        
        // 打开"发布动态"模态框 - 只能发布用户动态
        function openPostMomentModal() {
            const modal = $('#post-moment-modal');
            const authorSelect = $('#moment-author-select');
            
            // 只显示用户选项，角色不能通过此按钮发布动态
            const momentsUsername = loadData('moments_username') || '我';
            authorSelect.innerHTML = `<option value="user">${momentsUsername}</option>`;
            
            // 隐藏角色选择器，因为用户只能发布自己的动态
            authorSelect.style.display = 'none';
            
            // 更新标题，明确这是用户发布动态
            const title = modal.querySelector('h3');
            title.textContent = '发布我的动态';

            // 重置输入框
            $('#moment-content-input').value = '';
            $('#moment-image-label').textContent = '添加图片 (可选)';
            tempMomentImage = null;

            modal.classList.add('visible');
        }

        // --- 日记 (Diary) 新增函数 ---
        let currentOpenBook = { ownerId: null, entries: [], currentPage: 0 };
        let tempDiaryCoverImage = null; // 用于暂存日记本封面图片
        let tempDiaryBannerImage = null; // 用于暂存日记本顶部横幅图片
        
        // [AI, 请用这个包含了两个函数的代码块，替换掉旧的 showDiaryBookshelf 函数]
        function showDiaryBookshelf() {
            const bookshelf = $('#diary-bookshelf');
            bookshelf.innerHTML = '';
            const colors = ['#000000', '#000000', '#000000', '#000000', '#000000', '#000000'];
            let colorIndex = 0;

            // --- 新的正确代码 START ---
            const createBookItemHTML = (id, type, coverId, title, author) => {
                const itemStyle = `background-color: ${colors[colorIndex++ % colors.length]};`;
                const uniqueBookId = `diary-book-${id}`;

                // 异步加载封面
                if (coverId) {
                    getImageFromDB(coverId).then(blob => {
                        const bookElement = document.getElementById(uniqueBookId);
                        if (bookElement && blob) {
                            const objectURL = URL.createObjectURL(blob);
                            bookElement.style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }

                // V33.0 新增：检查并应用辉光效果
                const updatedDiaries = loadData('updatedDiaries', []);
                const hasNewEntry = updatedDiaries.includes(id);
                const newEntryClass = hasNewEntry ? ' new-entry' : '';

                return `
                    <div class="diary-book-item${newEntryClass}" style="${itemStyle}" id="${uniqueBookId}" onclick="openDiaryBook('${id}')">
                        <span class="diary-book-item-title" onclick="editDiaryTitle(event, '${type}', '${id}')">${title}</span>
                        <span class="diary-book-item-author">${author}</span>
                        <button class="diary-cover-edit-btn" onclick="changeDiaryCover(event, '${id}')"><i class="ri-image-edit-line"></i></button>
                    </div>
                `;
            };
            // --- 新的正确代码 END ---

            const myCover = loadData('diary_cover_user');
            const myTitle = loadData('user_diary_title') || 'My Diary';
            bookshelf.innerHTML += createBookItemHTML('user', 'user', myCover, myTitle, 'Me');

            characters.forEach(char => {
                const charCover = loadData(`diary_cover_${char.id}`);
                const charTitle = char.diaryTitle || `${char.name}'s Diary`;
                bookshelf.innerHTML += createBookItemHTML(char.id, 'character', charCover, charTitle, char.name);
            });
        }

        function editDiaryTitle(event, type, id) {
            event.stopPropagation(); // 阻止在编辑标题时打开日记本

            const titleElement = event.target;
            const currentTitle = titleElement.textContent;
            const newTitle = prompt('请输入新的日记本标题：', currentTitle);

            if (newTitle && newTitle.trim() && newTitle.trim() !== currentTitle) {
                const finalTitle = newTitle.trim();
                if (type === 'user') {
                    saveData('user_diary_title', finalTitle);
                } else if (type === 'character') {
                    const charIndex = characters.findIndex(c => c.id === id);
                    if (charIndex > -1) {
                        characters[charIndex].diaryTitle = finalTitle;
                        saveData('characters', characters);
                    }
                }

                titleElement.textContent = finalTitle;
                showMessageBox('标题已更新！');

                if (currentOpenBook.ownerId === id) {
                     $('#diary-cover-title').textContent = finalTitle;
                }
            }
        }

        // [AI, 请用这个版本完整替换现有的 openDiaryBook 函数]
        function openDiaryBook(ownerId) {
            // V33.0 新增：打开日记本时，移除更新提示
            let updatedDiaries = loadData('updatedDiaries', []);
            if (updatedDiaries.includes(ownerId)) {
                updatedDiaries = updatedDiaries.filter(id => id !== ownerId);
                saveData('updatedDiaries', updatedDiaries);
                // 实时移除书架上对应日记本的辉光class
                const bookOnShelf = document.querySelector(`.diary-book-item[onclick="openDiaryBook('${ownerId}')"]`);
                if (bookOnShelf) {
                    bookOnShelf.classList.remove('new-entry');
                }
            }
            
            let ownerName;
            const addPageBtn = $('#add-page-btn');
            const prevPageBtn = $('#prev-page-btn');
            const nextPageBtn = $('#next-page-btn');

            if (ownerId === 'user') {
                ownerName = loadData('user_diary_title') || "My Diary";
                addPageBtn.style.display = 'flex'; // 是我的日记，显示新增按钮
            } else {
                const character = characters.find(c => c.id === ownerId);
                if (!character) return;
                ownerName = character.diaryTitle || `${character.name}'s Diary`;
                addPageBtn.style.display = 'none'; // 是AI的日记，隐藏新增按钮
            }

            currentOpenBook.ownerId = ownerId;
            currentOpenBook.entries = (diaryData[ownerId] || []).slice().sort((a, b) => a.timestamp - b.timestamp);
            currentOpenBook.currentPage = currentOpenBook.entries.length > 0 ? currentOpenBook.entries.length - 1 : 0;
            currentOpenBook.isNotebook = false;

            $('#diary-cover-title').textContent = ownerName;
            let authorName;
            if (ownerId === 'user') {
                authorName = loadData('user_diary_author') || 'Me';
            } else {
                const character = characters.find(c => c.id === ownerId);
                authorName = character.diaryAuthor || character.name;
            }
            $('#diary-cover-author').textContent = `by ${authorName}`;

            // 优先加载独立的顶部横幅图片
            const savedBanner = loadData(`diary_banner_${ownerId}`);
            // 如果找不到横幅，则使用原来的书本封面作为备用
            const savedCover = loadData(`diary_cover_${ownerId}`);

            const finalImage = savedBanner || savedCover; // 优先使用横幅图

            const coverElement = document.getElementById('diary-book-cover');
            if (finalImage) {
                // 完全覆盖CSS样式，确保图片显示
                coverElement.style.cssText = `
                    background: url(${finalImage}) center center / cover no-repeat !important;
                    background-image: url(${finalImage}) !important;
                    background-size: cover !important;
                    background-repeat: no-repeat !important;
                    background-position: center !important;
                `;
            } else {
                // 恢复默认渐变背景
                coverElement.style.cssText = '';
            }

            // [关键] 强制隐藏旧的翻页按钮
            prevPageBtn.style.display = 'none';
            nextPageBtn.style.display = 'none';

            renderDiaryPages();
            $('#diary-book-modal').classList.remove('hidden');
        }

        // 渲染日记页面内容
        // [AI, 请用这个版本完整替换现有的 renderDiaryPages 函数]
        function renderDiaryPages() {
            const pagesContainer = $('#diary-pages-container');
            pagesContainer.innerHTML = '';

            const totalPages = currentOpenBook.entries.length > 0 ? currentOpenBook.entries.length : 1;
            const currentPageNumber = currentOpenBook.currentPage + 1;
            const currentEntry = currentOpenBook.entries[currentOpenBook.currentPage];

            if (currentEntry) {
                pagesContainer.innerHTML = `
                    <div class="diary-page-content">
                        <div class="diary-page-header">
                            <p class="diary-page-date">${new Date(currentEntry.timestamp).toLocaleDateString()}</p>
                            <button class="diary-delete-btn" title="删除此日记" onclick="deleteDiaryEntry('${currentEntry.id}')">
                                <i class="ri-delete-bin-line"></i>
                            </button>
                        </div>
                        <div class="diary-page-text" contenteditable="true" data-entry-id="${currentEntry.id}">${currentEntry.content.replace(/\n/g, '<br>')}</div>
                        <div class="diary-page-number">${currentPageNumber} / ${totalPages}</div>
                    </div>`;
            } else {
                // 当日记本为空时显示正确的提示
                pagesContainer.innerHTML = `
                    <div class="diary-page-content">
                        <p class="diary-page-date">${new Date().toLocaleDateString()}</p>
                        <p class="text-center text-gray-400 mt-16">这本日记还没有内容...</p>
                        <div class="diary-page-number">1 / 1</div>
                    </div>`;
            }
        }

        // [AI, 请将这两个新函数粘贴到 addDiaryEntry 函数的前面]
        function goToPrevPage() {
            if (currentOpenBook.currentPage > 0) {
                currentOpenBook.currentPage--;
                renderDiaryPages();
            } else {
                showMessageBox('已经是第一页了');
            }
        }

        function goToNextPage() {
            const totalPages = currentOpenBook.entries.length;
            if (currentOpenBook.currentPage < totalPages - 1) {
                currentOpenBook.currentPage++;
                renderDiaryPages();
            } else {
                showMessageBox('已经是最后一页了');
            }
        }

        // 添加日记条目
        function addDiaryEntry(ownerId, content) {
            if (!diaryData[ownerId]) {
                diaryData[ownerId] = [];
            }
            
            // 如果是笔记本，添加到笔记本数据
            if (currentOpenBook.isNotebook) {
                if (!currentOpenBook.notebookData.entries) {
                    currentOpenBook.notebookData.entries = [];
                }
                currentOpenBook.notebookData.entries.push(content);
                currentOpenBook.notebookData.lastModified = Date.now();
                saveData('notebookData', notebookData);
            }
        }

        // 删除日记条目
        function deleteDiaryEntry(entryId) {
            if (!currentOpenBook || !currentOpenBook.entries) return;
            
            // 确认删除
            if (!confirm('确定要删除这条日记吗？此操作无法撤销。')) {
                return;
            }
            
            // 找到要删除的条目索引
            const entryIndex = currentOpenBook.entries.findIndex(entry => entry.id === entryId);
            if (entryIndex === -1) return;
            
            // 删除条目
            currentOpenBook.entries.splice(entryIndex, 1);
            
            // 如果是笔记本，更新笔记本数据
            if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                currentOpenBook.notebookData.entries = currentOpenBook.entries;
                currentOpenBook.notebookData.lastModified = Date.now();
                saveData('notebookData', notebookData);
            } else {
                // 更新日记数据
                if (currentOpenBook.ownerId) {
                    diaryData[currentOpenBook.ownerId] = currentOpenBook.entries;
                    saveData('diaryData', diaryData);
                }
            }
            
            // 调整当前页码
            if (currentOpenBook.entries.length === 0) {
                // 如果没有条目了，关闭日记本
                $('#diary-book-modal').classList.add('hidden');
                showMessageBox('日记本已清空');
                return;
            }
            
            // 如果删除的是最后一页，且当前页超出范围，调整到最后一页
            if (currentOpenBook.currentPage >= currentOpenBook.entries.length) {
                currentOpenBook.currentPage = currentOpenBook.entries.length - 1;
            }
            
            // 刷新显示
            renderDiaryPages();
            showMessageBox('日记已删除');
        }

        // 创建日记页面
        // 创建日记页面 - 现在使用单页显示，此函数已简化
        function createDiaryPage(content, entry, isNew = false) {
            // 现在直接返回空元素，因为页面内容由 renderDiaryPages 处理
            const page = document.createElement('div');
            page.className = 'diary-page-placeholder';
            return page;
        }

        // 保存日记页面内容
        function saveDiaryPage(textarea) {
            const content = textarea.value.trim();
            if (!content) return;
            
            const entryId = textarea.dataset.entryId;
            
            if (entryId) {
                // 更新现有日记
                const entry = currentOpenBook.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.content = content;
                    entry.lastModified = Date.now();
                }
            } else {
                // 创建新日记
                const newEntry = {
                    id: `diary_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    lastModified: Date.now()
                };
                
                if (!currentOpenBook.entries) currentOpenBook.entries = [];
                currentOpenBook.entries.push(newEntry);
                
                if (currentOpenBook.isNotebook) {
                    // 如果是笔记本，更新笔记本数据
                    currentOpenBook.notebookData.entries = currentOpenBook.entries;
                    currentOpenBook.notebookData.lastModified = Date.now();
                    saveData('notebookData', notebookData);
                    showMessageBox('笔记本内容已保存！');
                } else {
                    // 更新日记数据
                    if (!diaryData[currentOpenBook.ownerId]) {
                        diaryData[currentOpenBook.ownerId] = [];
                    }
                    diaryData[currentOpenBook.ownerId].push(newEntry);
                    saveData('diaryData', diaryData);
                    showMessageBox('日记已保存！');
                }
                
                // 刷新显示
                renderDiaryPages();
            }
        }

        // 更新日记条目
        function updateDiaryEntry(entryId, newContent) {
            // 先检查是否是笔记本条目
            if (currentOpenBook.isNotebook) {
                const entryIndex = currentOpenBook.entries.findIndex(entry => entry.id === entryId);
                if (entryIndex !== -1) {
                    currentOpenBook.entries[entryIndex].content = newContent;
                    currentOpenBook.notebookData.entries = currentOpenBook.entries;
                    currentOpenBook.notebookData.lastModified = Date.now();
                    saveData('notebookData', notebookData);
                    return;
                }
            }
            
            // 检查日记数据
            Object.keys(diaryData).forEach(ownerId => {
                const entryIndex = diaryData[ownerId].findIndex(entry => entry.id === entryId);
                if (entryIndex !== -1) {
                    diaryData[ownerId][entryIndex].content = newContent;
                    saveData('diaryData', diaryData);
                    return;
                }
            });
        }

        // 更换日记本封面
        function changeDiaryCover(event, ownerId) {
            // 阻止事件冒泡，避免触发打开日记本
            event.stopPropagation();
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            // --- 新的正确代码 START ---
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 调用正确的图片处理函数，它会返回一个imageId
                        const imageId = await handleImageUpload(e.target, null, `diary_cover_${ownerId}`);
                        if (imageId) {
                            // 保存的是imageId，而不是Base64
                            saveData(`diary_cover_${ownerId}`, imageId);
                            showDiaryBookshelf(); // 刷新书架显示
                            showMessageBox('日记本封面已更新');
                        }
                    } catch (error) {
                        console.error('日记本封面处理失败:', error);
                        showMessageBox('封面图片处理失败');
                    }
                }
            };
            // --- 新的正确代码 END ---
            input.click();
        }

        



        // 编辑日记封面标题
        function editDiaryCoverTitle(event) {
            // 阻止事件冒泡和默認行為
            event.stopPropagation();
            event.preventDefault();
            event.stopImmediatePropagation();
            
            const titleElement = event.target;
            const currentTitle = titleElement.textContent;
            
            // 如果已经在编辑状态，直接返回
            if (titleElement.classList.contains('editing')) {
                return;
            }
            
            // 创建输入框
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.className = 'cover-title-edit-input';
            
            // 设置输入框样式
            input.style.cssText = `
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                border: 2px solid #4ecdc4;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 1.5rem;
                font-weight: 700;
                text-align: center;
                width: 90%;
                outline: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                font-family: inherit;
            `;
            
            // 替换标题为输入框
            titleElement.innerHTML = '';
            titleElement.appendChild(input);
            titleElement.classList.add('editing');
            
            // 聚焦输入框
            input.focus();
            input.select();
            
            // 处理保存
            function saveTitle() {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== currentTitle) {
                    // 保存新标题
                    if (currentOpenBook.ownerId === 'user') {
                        saveData('user_diary_title', newTitle);
                    } else if (currentOpenBook.ownerId && !currentOpenBook.isNotebook) {
                        // 角色日记
                        const character = characters.find(c => c.id === currentOpenBook.ownerId);
                        if (character) {
                            character.diaryTitle = newTitle;
                            saveData('characters', characters);
                        }
                    } else if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                        // 笔记本
                        currentOpenBook.notebookData.name = newTitle;
                        saveData('notebookData', notebookData);
                    }
                    
                    // 更新显示
                    titleElement.textContent = newTitle;
                    showMessageBox('标题已更新！');
                } else {
                    // 恢复原标题
                    titleElement.textContent = currentTitle;
                }
                
                titleElement.classList.remove('editing');
            }
            
            // 绑定事件
            input.addEventListener('blur', saveTitle);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveTitle();
                } else if (e.key === 'Escape') {
                    titleElement.textContent = currentTitle;
                    titleElement.classList.remove('editing');
                }
            });
        }

        // 编辑日记封面作者
        function editDiaryCoverAuthor(event) {
            // 阻止事件冒泡和默認行為
            event.stopPropagation();
            event.preventDefault();
            event.stopImmediatePropagation();
            
            const authorElement = event.target;
            const currentAuthor = authorElement.textContent.replace('by ', '');
            
            // 如果已经在编辑状态，直接返回
            if (authorElement.classList.contains('editing')) {
                return;
            }
            
            // 创建输入框
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentAuthor;
            input.className = 'cover-author-edit-input';
            
            // 设置输入框样式
            input.style.cssText = `
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                border: 2px solid #4ecdc4;
                border-radius: 6px;
                padding: 6px 10px;
                font-size: 1.1rem;
                font-weight: 500;
                text-align: center;
                width: 80%;
                outline: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                font-family: inherit;
            `;
            
            // 替换作者为输入框
            authorElement.innerHTML = '';
            authorElement.appendChild(input);
            authorElement.classList.add('editing');
            
            // 聚焦输入框
            input.focus();
            input.select();
            
            // 处理保存
            function saveAuthor() {
                const newAuthor = input.value.trim();
                if (newAuthor && newAuthor !== currentAuthor) {
                    // 保存新作者
                    if (currentOpenBook.ownerId === 'user') {
                        saveData('user_diary_author', newAuthor);
                    } else if (currentOpenBook.ownerId && !currentOpenBook.isNotebook) {
                        // 角色日记
                        const character = characters.find(c => c.id === currentOpenBook.ownerId);
                        if (character) {
                            character.diaryAuthor = newAuthor;
                            saveData('characters', characters);
                        }
                    } else if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                        // 笔记本
                        currentOpenBook.notebookData.type = newAuthor;
                        saveData('notebookData', notebookData);
                    }
                    
                    // 更新显示
                    authorElement.textContent = `by ${newAuthor}`;
                    showMessageBox('作者已更新！');
                } else {
                    // 恢复原作者
                    authorElement.textContent = `by ${currentAuthor}`;
                }
                
                authorElement.classList.remove('editing');
            }
            
            // 绑定事件
            input.addEventListener('blur', saveAuthor);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveAuthor();
                } else if (e.key === 'Escape') {
                    authorElement.textContent = `by ${currentAuthor}`;
                    authorElement.classList.remove('editing');
                }
            });
        }

        // 显示日记界面
        function displayDiaries() {
            // 显示日记界面
            $('#diary-interface').classList.remove('hidden');
            $('#chat-interface').classList.add('hidden');
            $('#drawing-interface').classList.add('hidden');
            
            // 刷新书架显示
            showDiaryBookshelf();
            
            // 更新界面状态
            currentInterface = 'diary';
        }

        // 显示指定角色的日记
        function displayDiariesForCharacter(characterId) {
            try {
                if (!characterId) return;
                
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 如果当前在日记界面，刷新显示
                if (currentView === 'diary') {
                    // 更新日记数量显示
                    updateDiaryCount(characterId);
                    
                    // 如果当前打开的是这个角色的日记本，刷新内容
                    if (currentOpenBook && currentOpenBook.ownerId === characterId) {
                        renderDiaryPages();
                    }
                }
            } catch (error) {
                console.error('[日记系统] 显示日记失败:', error);
            }
        }

        // 更新日记数量显示
        function updateDiaryCount(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 获取日记数量
                const diaryCount = character.diaries?.length || 0;
                
                // 更新日记书架上的数量显示
                const diaryItem = document.querySelector(`[data-owner-id="${characterId}"]`);
                if (diaryItem) {
                    // 检查是否已有数量显示
                    let countElement = diaryItem.querySelector('.diary-count');
                    if (!countElement) {
                        countElement = document.createElement('span');
                        countElement.className = 'diary-count';
                        countElement.style.cssText = `
                            position: absolute;
                            top: -5px;
                            right: -5px;
                            background: #ff4757;
                            color: white;
                            border-radius: 50%;
                            width: 20px;
                            height: 20px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 12px;
                            font-weight: bold;
                        `;
                        diaryItem.appendChild(countElement);
                    }
                    
                    if (diaryCount > 0) {
                        countElement.textContent = diaryCount;
                        countElement.style.display = 'flex';
                    } else {
                        countElement.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('[日记系统] 更新日记数量显示失败:', error);
            }
        }

        // 初始化日记系统
        function initDiarySystem() {
            try {
                // 为每个角色初始化日记数组
                characters.forEach(character => {
                    if (!character.diaries) {
                        character.diaries = [];
                    }
                });
                
                // 保存更新后的角色数据
                saveData('characters', characters);
                
                console.log('[日记系统] 日记系统初始化完成');
            } catch (error) {
                console.error('[日记系统] 日记系统初始化失败:', error);
            }
        }
        // [新代码结束]

        // 创建新笔记本
        function createNewNotebook() {
            // 显示创建笔记本模态框
            $('#new-notebook-modal').classList.remove('hidden');
            
            // 重置表单
            $('#new-notebook-name').value = '';
            $('#new-notebook-type').value = 'diary';
            $('#custom-notebook-type').value = '';
            $('#custom-type-container').classList.add('hidden');
            
            // 聚焦到名称输入框
            setTimeout(() => {
                $('#new-notebook-name').focus();
            }, 100);
        }

        // 处理笔记本类型选择变化
        function handleNotebookTypeChange() {
            const typeSelect = $('#new-notebook-type');
            const customContainer = $('#custom-type-container');
            
            if (typeSelect.value === 'custom') {
                customContainer.classList.remove('hidden');
                $('#custom-notebook-type').focus();
            } else {
                customContainer.classList.add('hidden');
            }
        }

        // 确认创建新笔记本
        function confirmCreateNotebook() {
            const name = $('#new-notebook-name').value.trim();
            const type = $('#new-notebook-type').value;
            let customType = '';
            
            if (!name) {
                showMessageBox('请输入笔记本名称');
                return;
            }
            
            if (type === 'custom') {
                customType = $('#custom-notebook-type').value.trim();
                if (!customType) {
                    showMessageBox('请输入自定义类型名称');
                    return;
                }
            }
            
            // 生成笔记本ID
            const notebookId = `notebook_${Date.now()}`;
            
            // 创建笔记本数据结构
            const newNotebook = {
                id: notebookId,
                name: name,
                type: type === 'custom' ? customType : type,
                created: Date.now(),
                lastModified: Date.now(),
                entries: [],
                cover: null
            };
            
            // 保存到本地存储
            if (!notebookData) {
                notebookData = {};
            }
            notebookData[notebookId] = newNotebook;
            saveData('notebookData', notebookData);
            
            // 关闭模态框
            $('#new-notebook-modal').classList.add('hidden');
            
            // 显示成功消息
            showMessageBox(`笔记本"${name}"创建成功！`);
            
            // 刷新书架显示
            showDiaryBookshelf();
        }

        // ====== 画板功能 ======
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let canvasHistory = []; // 画布历史记录
        let currentHistoryIndex = -1; // 当前历史记录索引

        // 保存画布状态到历史记录
        function saveCanvasState() {
            const canvas = document.getElementById('drawing-canvas');
            const imageData = canvas.toDataURL('image/png');
            
            // 如果当前不在历史记录末尾，删除后面的记录
            if (currentHistoryIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, currentHistoryIndex + 1);
            }
            
            canvasHistory.push(imageData);
            currentHistoryIndex++;
            
            // 限制历史记录数量，避免内存占用过大
            if (canvasHistory.length > 20) {
                canvasHistory.shift();
                currentHistoryIndex--;
            }
        }
        
        // 撤销功能
        function undoDrawing() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                
                img.src = canvasHistory[currentHistoryIndex];
            }
        }
        
        // 初始化画板
        function initDrawingBoard() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置画布背景为白色
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 设置默认画笔样式
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentBrushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // 设置画笔预览的初始状态
            const brushPreview = document.getElementById('brush-preview-circle');
            if (brushPreview) {
                brushPreview.style.width = currentBrushSize + 'px';
                brushPreview.style.height = currentBrushSize + 'px';
                brushPreview.style.background = currentColor;
            }
            
            // 清空历史记录
            canvasHistory = [];
            currentHistoryIndex = -1;
            
            // 保存初始状态
            saveCanvasState();
        }

        // 画板事件监听器
        function setupDrawingBoard() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            
            // 获取画布的实际尺寸和显示尺寸的比例
            function getCanvasScale() {
                const rect = canvas.getBoundingClientRect();
                return {
                    scaleX: canvas.width / rect.width,
                    scaleY: canvas.height / rect.height
                };
            }
            
            // 将屏幕坐标转换为画布坐标
            function getCanvasCoordinates(clientX, clientY) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }
            
            // 鼠标按下事件
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const coords = getCanvasCoordinates(e.clientX, e.clientY);
                lastX = coords.x;
                lastY = coords.y;
            });
            
            // 鼠标移动事件
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const coords = getCanvasCoordinates(e.clientX, e.clientY);
                const currentX = coords.x;
                const currentY = coords.y;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                lastX = currentX;
                lastY = currentY;
            });
            
            // 鼠标松开事件
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                // 保存画布状态
                saveCanvasState();
            });
            
            // 鼠标离开画布事件
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });
            
            // 触摸事件支持
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                const touch = e.touches[0];
                const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
                lastX = coords.x;
                lastY = coords.y;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                
                const touch = e.touches[0];
                const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
                const currentX = coords.x;
                const currentY = coords.y;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                lastX = currentX;
                lastY = currentY;
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDrawing = false;
                // 保存画布状态
                saveCanvasState();
            });
        }

        // 颜色选择
        function setupColorPalette() {
            const colorSwatches = document.querySelectorAll('.color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', () => {
                    currentColor = swatch.dataset.color;
                    const canvas = document.getElementById('drawing-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.strokeStyle = currentColor;
                    
                    // 更新画笔预览颜色
                    const brushPreview = document.getElementById('brush-preview-circle');
                    if (brushPreview) {
                        brushPreview.style.background = currentColor;
                    }
                    
                    // 更新选中状态
                    colorSwatches.forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                });
            });
            
            // 默认选中黑色
            colorSwatches[0].classList.add('selected');
        }

        // 画笔大小控制
        function setupBrushControls() {
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const brushPreview = document.getElementById('brush-preview-circle');
            
            brushSizeSlider.addEventListener('input', (e) => {
                currentBrushSize = parseInt(e.target.value);
                brushSizeValue.textContent = currentBrushSize + 'px';
                
                // 更新画笔预览
                if (brushPreview) {
                    brushPreview.style.width = currentBrushSize + 'px';
                    brushPreview.style.height = currentBrushSize + 'px';
                }
                
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                ctx.lineWidth = currentBrushSize;
            });
        }

        // 清空画布
        function clearCanvas() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // 发送画作
        async function sendDrawing() {
            const canvas = document.getElementById('drawing-canvas');
            const dataURL = canvas.toDataURL('image/png');
            
            // 将画作作为图片消息发送
            appendMessage(dataURL, 'user', 'image', true, Date.now(), true);
            
            // 关闭画板
            closeDrawingBoard();
            
            // 清空画布
            clearCanvas();
        }

        // 打开画板
        function openDrawingBoard() {
            const modal = document.getElementById('drawing-board-modal');
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            // 初始化画板
            initDrawingBoard();
        }

        // 关闭画板
        function closeDrawingBoard() {
            const modal = document.getElementById('drawing-board-modal');
            modal.classList.remove('visible');
            modal.classList.add('hidden');
        }

        // 设置画板事件监听器
        function setupDrawingBoardEvents() {
            // 画板按钮点击事件（在更多功能面板中）
            const drawingBoardBtn = document.getElementById('drawing-board-btn');
            if (drawingBoardBtn) {
                drawingBoardBtn.addEventListener('click', openDrawingBoard);
            }
            
            // 关闭按钮事件
            const closeBtn = document.getElementById('close-drawing-board');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeDrawingBoard);
            }
            
            // 撤销按钮事件
            const undoBtn = document.getElementById('undo-drawing');
            if (undoBtn) {
                undoBtn.addEventListener('click', undoDrawing);
            }
            
            // 清空画布按钮事件
            const clearBtn = document.getElementById('clear-canvas');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearCanvas);
            }
            
            // 发送画作按钮事件
            const sendBtn = document.getElementById('send-drawing');
            if (sendBtn) {
                sendBtn.addEventListener('click', sendDrawing);
            }
            
            // 点击遮罩层关闭画板
            const modal = document.getElementById('drawing-board-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'drawing-board-modal') {
                        closeDrawingBoard();
                    }
                });
            }
        }

        // ====== 塔罗牌功能 ======
        // 塔罗牌数据
        const tarotCards = [
            // 大阿卡纳 (22张)
            {
                name: "愚者",
                meaning: "新的开始、冒险、纯真、自发性、自由",
                reverseMeaning: "鲁莽、不负责任、过度冒险、缺乏计划",
                image: "🃏"
            },
            {
                name: "魔术师",
                meaning: "创造力、技能、意志力、自信、机会",
                reverseMeaning: "技能不足、机会错失、缺乏自信、滥用权力",
                image: "🔮"
            },
            {
                name: "女祭司",
                meaning: "直觉、神秘、内在知识、智慧、秘密",
                reverseMeaning: "隐藏的动机、表面化、缺乏深度、过度理性",
                image: "🌙"
            },
            {
                name: "女皇",
                meaning: "丰收、母性、创造力、自然、富足",
                reverseMeaning: "过度保护、依赖、缺乏创造力、物质主义",
                image: "👑"
            },
            {
                name: "皇帝",
                meaning: "权威、领导力、控制、稳定、成就",
                reverseMeaning: "专制、控制欲、缺乏灵活性、过度控制",
                image: "⚜️"
            },
            {
                name: "教皇",
                meaning: "传统、教育、信仰、精神指导、道德",
                reverseMeaning: "教条主义、缺乏独立思考、过度依赖权威",
                image: "⛪"
            },
            {
                name: "恋人",
                meaning: "爱情、和谐、关系、选择、价值观",
                reverseMeaning: "不和谐、价值观冲突、选择困难、分离",
                image: "💕"
            },
            {
                name: "战车",
                meaning: "胜利、意志力、决心、成功、控制",
                reverseMeaning: "缺乏方向、失控、失败、意志薄弱",
                image: "🏛️"
            },
            {
                name: "力量",
                meaning: "内在力量、勇气、耐心、控制、温和",
                reverseMeaning: "缺乏自信、软弱、过度控制、缺乏耐心",
                image: "🦁"
            },
            {
                name: "隐者",
                meaning: "内省、寻找、孤独、内在指导、智慧",
                reverseMeaning: "过度孤独、缺乏指导、迷失方向、拒绝帮助",
                image: "🧭"
            },
            {
                name: "命运之轮",
                meaning: "变化、命运、转折点、机会、周期",
                reverseMeaning: "坏运气、错失机会、停滞、无法改变",
                image: "🎡"
            },
            {
                name: "正义",
                meaning: "公平、真理、诚实、因果、平衡",
                reverseMeaning: "不公、欺骗、不平衡、缺乏正义",
                image: "⚖️"
            },
            {
                name: "倒吊人",
                meaning: "牺牲、暂停、新视角、顺从、启示",
                reverseMeaning: "无意义的牺牲、停滞、缺乏进展、浪费时间",
                image: "🙃"
            },
            {
                name: "死神",
                meaning: "结束、转变、重生、释放、改变",
                reverseMeaning: "抗拒改变、停滞、无法前进、恐惧",
                image: "💀"
            },
            {
                name: "节制",
                meaning: "平衡、适度、耐心、和谐、自我控制",
                reverseMeaning: "过度、不平衡、缺乏耐心、失控",
                image: "🍷"
            },
            {
                name: "恶魔",
                meaning: "束缚、物质主义、欲望、阴影、诱惑",
                reverseMeaning: "释放、摆脱束缚、面对阴影、觉醒",
                image: "👿"
            },
            {
                name: "高塔",
                meaning: "突然变化、混乱、启示、破坏、解放",
                reverseMeaning: "避免灾难、逐渐改变、重建、稳定",
                image: "🗼"
            },
            {
                name: "星星",
                meaning: "希望、信心、目的、更新、精神意识",
                reverseMeaning: "缺乏信心、绝望、失去方向、悲观",
                image: "⭐"
            },
            {
                name: "月亮",
                meaning: "直觉、潜意识、恐惧、幻想、迷惑",
                reverseMeaning: "释放恐惧、清晰、真相、内在平静",
                image: "🌙"
            },
            {
                name: "太阳",
                meaning: "成功、喜悦、活力、真理、成功",
                reverseMeaning: "暂时困难、过度自信、表面成功、内在空虚",
                image: "☀️"
            },
            {
                name: "审判",
                meaning: "重生、内在呼唤、释放、救赎、觉醒",
                reverseMeaning: "自我怀疑、拒绝改变、缺乏觉醒、停滞",
                image: "📯"
            },
            {
                name: "世界",
                meaning: "完成、整合、成就、旅行、和谐",
                reverseMeaning: "未完成、缺乏整合、延迟、不和谐",
                image: "🌍"
            },
            
            // 小阿卡纳 - 权杖系列 (14张)
            {
                name: "权杖王牌",
                meaning: "新的开始、灵感、创造力、机会、潜力",
                reverseMeaning: "错失机会、缺乏灵感、延迟、未实现的潜力",
                image: "🔥"
            },
            {
                name: "权杖二",
                meaning: "选择、平衡、合作、伙伴关系、决策",
                reverseMeaning: "优柔寡断、不平衡、缺乏合作、错误选择",
                image: "⚖️"
            },
            {
                name: "权杖三",
                meaning: "团队合作、扩展、成长、合作、计划",
                reverseMeaning: "缺乏合作、计划失败、过度扩张、团队冲突",
                image: "🤝"
            },
            {
                name: "权杖四",
                meaning: "庆祝、和谐、家庭、稳定、成功",
                reverseMeaning: "缺乏庆祝、家庭冲突、不稳定、成功延迟",
                image: "🎉"
            },
            {
                name: "权杖五",
                meaning: "冲突、竞争、挑战、成长、学习",
                reverseMeaning: "避免冲突、缺乏竞争、逃避挑战、停滞不前",
                image: "⚔️"
            },
            {
                name: "权杖六",
                meaning: "胜利、成功、好消息、认可、进步",
                reverseMeaning: "延迟成功、缺乏认可、坏消息、停滞",
                image: "🏆"
            },
            {
                name: "权杖七",
                meaning: "防御、坚持、挑战、保护、决心",
                reverseMeaning: "过度防御、缺乏坚持、放弃、脆弱",
                image: "🛡️"
            },
            {
                name: "权杖八",
                meaning: "快速行动、变化、消息、旅行、进展",
                reverseMeaning: "延迟、停滞、坏消息、旅行取消、缺乏进展",
                image: "🚀"
            },
            {
                name: "权杖九",
                meaning: "准备、防御、经验、智慧、警惕",
                reverseMeaning: "缺乏准备、过度防御、缺乏经验、粗心",
                image: "🎯"
            },
            {
                name: "权杖十",
                meaning: "负担、责任、压力、努力、成就",
                reverseMeaning: "减轻负担、缺乏责任、逃避压力、懒惰",
                image: "💼"
            },
            {
                name: "权杖侍从",
                meaning: "新消息、学习、探索、热情、冒险",
                reverseMeaning: "坏消息、缺乏学习、缺乏热情、过度谨慎",
                image: "📚"
            },
            {
                name: "权杖骑士",
                meaning: "行动、冒险、热情、冲动、变化",
                reverseMeaning: "延迟、缺乏行动、缺乏热情、过度谨慎",
                image: "🐎"
            },
            {
                name: "权杖皇后",
                meaning: "独立、热情、创造力、自信、魅力",
                reverseMeaning: "依赖、缺乏热情、缺乏创造力、缺乏自信",
                image: "👸"
            },
            {
                name: "权杖国王",
                meaning: "领导力、热情、创造力、自信、成功",
                reverseMeaning: "缺乏领导力、缺乏热情、缺乏创造力、失败",
                image: "👑"
            },
            
            // 小阿卡纳 - 圣杯系列 (14张)
            {
                name: "圣杯王牌",
                meaning: "新的情感、爱、直觉、创造力、灵感",
                reverseMeaning: "情感封闭、缺乏爱、缺乏直觉、缺乏灵感",
                image: "💧"
            },
            {
                name: "圣杯二",
                meaning: "伙伴关系、爱情、和谐、选择、平衡",
                reverseMeaning: "分离、不和谐、缺乏选择、不平衡",
                image: "💕"
            },
            {
                name: "圣杯三",
                meaning: "庆祝、友谊、欢乐、合作、成功",
                reverseMeaning: "缺乏庆祝、孤独、悲伤、缺乏合作",
                image: "🎊"
            },
            {
                name: "圣杯五",
                meaning: "失望、悲伤、损失、遗憾、悲观",
                reverseMeaning: "希望、恢复、新机会、乐观、接受",
                image: "😔"
            },
            {
                name: "圣杯六",
                meaning: "怀旧、回忆、重逢、和谐、童年",
                reverseMeaning: "缺乏怀旧、分离、不和谐、成长",
                image: "🏠"
            },
            {
                name: "圣杯七",
                meaning: "选择、幻想、诱惑、困惑、决策",
                reverseMeaning: "清晰、现实、避免诱惑、明确选择",
                image: "🌈"
            },
            {
                name: "圣杯八",
                meaning: "离开、寻找、改变、进步、新开始",
                reverseMeaning: "停滞、缺乏改变、缺乏进步、恐惧",
                image: "🚶"
            },
            {
                name: "圣杯九",
                meaning: "满足、愿望实现、成功、幸福、富足",
                reverseMeaning: "不满足、愿望未实现、失败、缺乏",
                image: "🎁"
            },
            {
                name: "圣杯十",
                meaning: "家庭和谐、幸福、圆满、爱、满足",
                reverseMeaning: "家庭冲突、不幸福、不圆满、缺乏爱",
                image: "🏡"
            },
            {
                name: "圣杯侍从",
                meaning: "新消息、学习、创造力、灵感、机会",
                reverseMeaning: "坏消息、缺乏学习、缺乏创造力、错失机会",
                image: "📖"
            },
            {
                name: "圣杯骑士",
                meaning: "浪漫、提议、邀请、创意、魅力",
                reverseMeaning: "缺乏浪漫、拒绝、缺乏创意、缺乏魅力",
                image: "🌹"
            },
            {
                name: "圣杯皇后",
                meaning: "爱、关怀、直觉、创造力、同情心",
                reverseMeaning: "缺乏爱、缺乏关怀、缺乏直觉、冷漠",
                image: "👸"
            },
            {
                name: "圣杯国王",
                meaning: "情感成熟、智慧、同情心、创造力、领导力",
                reverseMeaning: "情感不成熟、缺乏智慧、缺乏同情心",
                image: "👑"
            },
            
            // 小阿卡纳 - 宝剑系列 (14张)
            {
                name: "宝剑王牌",
                meaning: "新的想法、清晰、真理、突破、力量",
                reverseMeaning: "混乱、缺乏清晰、缺乏真理、缺乏力量",
                image: "⚔️"
            },
            {
                name: "宝剑二",
                meaning: "平衡、选择、和谐、决策、和平",
                reverseMeaning: "不平衡、缺乏选择、不和谐、冲突",
                image: "⚖️"
            },
            {
                name: "宝剑三",
                meaning: "心痛、悲伤、分离、背叛、痛苦",
                reverseMeaning: "恢复、和解、团聚、信任、治愈",
                image: "💔"
            },
            {
                name: "宝剑四",
                meaning: "休息、恢复、冥想、和平、内省",
                reverseMeaning: "缺乏休息、过度劳累、缺乏和平、焦虑",
                image: "😴"
            },
            {
                name: "宝剑五",
                meaning: "失败、损失、冲突、挫折、竞争",
                reverseMeaning: "成功、胜利、和解、合作、避免冲突",
                image: "🏃"
            },
            {
                name: "宝剑六",
                meaning: "过渡、改变、进步、离开、新开始",
                reverseMeaning: "停滞、缺乏改变、缺乏进步、恐惧",
                image: "🚢"
            },
            {
                name: "宝剑七",
                meaning: "欺骗、秘密、策略、隐藏动机、逃避",
                reverseMeaning: "诚实、真相、直接、面对问题、勇气",
                image: "🕵️"
            },
            {
                name: "宝剑八",
                meaning: "困境、限制、无助、恐惧、束缚",
                reverseMeaning: "解脱、自由、希望、勇气、突破",
                image: "🔒"
            },
            {
                name: "宝剑九",
                meaning: "焦虑、恐惧、担忧、噩梦、压力",
                reverseMeaning: "平静、希望、信心、放松、解脱",
                image: "😰"
            },
            {
                name: "宝剑十",
                meaning: "结束、失败、痛苦、背叛、绝望",
                reverseMeaning: "新开始、希望、恢复、重生、机会",
                image: "💀"
            },
            {
                name: "宝剑侍从",
                meaning: "新想法、学习、消息、好奇心、观察",
                reverseMeaning: "缺乏想法、缺乏学习、坏消息、缺乏好奇心",
                image: "📝"
            },
            {
                name: "宝剑骑士",
                meaning: "行动、冲突、勇气、冲动、变化",
                reverseMeaning: "延迟、避免冲突、缺乏勇气、过度谨慎",
                image: "⚔️"
            },
            {
                name: "宝剑皇后",
                meaning: "智慧、独立、清晰、真理、力量",
                reverseMeaning: "缺乏智慧、依赖、混乱、谎言、软弱",
                image: "👸"
            },
            {
                name: "宝剑国王",
                meaning: "权威、智慧、真理、正义、领导力",
                reverseMeaning: "缺乏权威、缺乏智慧、不公、缺乏领导力",
                image: "👑"
            },
            
            // 小阿卡纳 - 金币系列 (14张)
            {
                name: "金币王牌",
                meaning: "新的机会、财富、物质成功、繁荣、潜力",
                reverseMeaning: "错失机会、缺乏财富、物质失败、缺乏潜力",
                image: "💰"
            },
            {
                name: "金币二",
                meaning: "平衡、适应、灵活性、变化、学习",
                reverseMeaning: "不平衡、缺乏适应、缺乏灵活性、停滞",
                image: "🎭"
            },
            {
                name: "金币三",
                meaning: "技能、学习、成长、合作、进步",
                reverseMeaning: "缺乏技能、缺乏学习、缺乏成长、缺乏合作",
                image: "🔨"
            },
            {
                name: "金币四",
                meaning: "安全、稳定、保守、保护、财富",
                reverseMeaning: "不安全、不稳定、冒险、损失、缺乏保护",
                image: "🏰"
            },
            {
                name: "金币五",
                meaning: "困难、贫困、疾病、孤独、挑战",
                reverseMeaning: "改善、健康、陪伴、克服困难、希望",
                image: "🏥"
            },
            {
                name: "金币六",
                meaning: "慷慨、给予、帮助、慈善、成功",
                reverseMeaning: "自私、缺乏给予、缺乏帮助、失败",
                image: "🎁"
            },
            {
                name: "金币七",
                meaning: "耐心、投资、长期规划、成长、等待",
                reverseMeaning: "缺乏耐心、短期思维、缺乏规划、停滞",
                image: "🌱"
            },
            {
                name: "金币八",
                meaning: "技能发展、学习、进步、专注、成长",
                reverseMeaning: "缺乏技能、缺乏学习、缺乏进步、分心",
                image: "⚒️"
            },
            {
                name: "金币九",
                meaning: "独立、自给自足、成功、享受、富足",
                reverseMeaning: "依赖、缺乏自给自足、失败、缺乏享受",
                image: "🏡"
            },
            {
                name: "金币十",
                meaning: "家庭财富、传承、传统、成功、圆满",
                reverseMeaning: "家庭困难、缺乏传承、缺乏传统、失败",
                image: "🏠"
            },
            {
                name: "金币侍从",
                meaning: "新机会、学习、消息、好奇心、潜力",
                reverseMeaning: "错失机会、缺乏学习、坏消息、缺乏潜力",
                image: "📚"
            },
            {
                name: "金币骑士",
                meaning: "实用、可靠、耐心、勤奋、进步",
                reverseMeaning: "不实用、不可靠、缺乏耐心、懒惰",
                image: "🐎"
            },
            {
                name: "金币皇后",
                meaning: "富足、实用、关怀、繁荣、成功",
                reverseMeaning: "缺乏、不实用、缺乏关怀、失败",
                image: "👸"
            },
            {
                name: "金币国王",
                meaning: "成功、财富、权威、实用、领导力",
                reverseMeaning: "失败、缺乏财富、缺乏权威、缺乏领导力",
                image: "👑"
            }
        ];

        let currentCard = null;
        let isCardFlipped = false;

        // 初始化塔罗牌功能
        function setupTarotCard() {
            // 塔罗牌按钮点击事件
            const tarotBtn = document.getElementById('tarot-card-btn');
            if (tarotBtn) {
                tarotBtn.addEventListener('click', openTarotModal);
            }

            // 关闭按钮事件
            const closeBtn = document.getElementById('close-tarot-modal');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeTarotModal);
            }

            // 抽牌按钮事件
            const drawBtn = document.getElementById('draw-card-btn');
            if (drawBtn) {
                drawBtn.addEventListener('click', drawTarotCard);
            }

                    // 发送塔罗牌按钮事件
        const sendBtn = document.getElementById('send-tarot-btn');
        if (sendBtn) {
            sendBtn.addEventListener('click', sendTarotCard);
        }



            // 点击遮罩层关闭塔罗牌
            const modal = document.getElementById('tarot-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'tarot-modal') {
                        closeTarotModal();
                    }
                });
            }
        }

        // 打开塔罗牌弹窗
        function openTarotModal() {
            const modal = document.getElementById('tarot-modal');
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            // 重置状态
            resetTarotCard();
        }

        // 关闭塔罗牌弹窗
        function closeTarotModal() {
            const modal = document.getElementById('tarot-modal');
            modal.classList.remove('visible');
            modal.classList.add('hidden');
        }

        // 重置塔罗牌状态
        function resetTarotCard() {
            currentCard = null;
            isCardFlipped = false;
            
            const cardDisplay = document.getElementById('tarot-card');
            const info = document.getElementById('tarot-info');
            const sendBtn = document.getElementById('send-tarot-btn');
            const drawBtn = document.getElementById('draw-card-btn');
            
            cardDisplay.className = 'tarot-card-back';
            cardDisplay.innerHTML = `
                <div class="card-back-pattern"></div>
                <div class="card-back-text">点击抽牌</div>
            `;
            
            info.style.display = 'none';
            sendBtn.style.display = 'none';
            drawBtn.style.display = 'block'; // 重新显示抽牌按钮
        }

        // 抽取塔罗牌
        function drawTarotCard() {
            if (isCardFlipped) return;
            
            // 随机选择一张牌
            const randomIndex = Math.floor(Math.random() * tarotCards.length);
            currentCard = tarotCards[randomIndex];
            
            // 随机决定正逆位
            const isReversed = Math.random() > 0.5;
            
            // 翻转卡片
            flipCard(currentCard, isReversed);
        }

        // 翻转卡片
        function flipCard(card, isReversed) {
            const cardDisplay = document.getElementById('tarot-card');
            const info = document.getElementById('tarot-info');
            const sendBtn = document.getElementById('send-tarot-btn');
            const drawBtn = document.getElementById('draw-card-btn');
            
            // 创建卡片正面
            cardDisplay.className = 'tarot-card-front';
            cardDisplay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; text-align: center;">
                    <div style="font-size: 60px; margin-bottom: 20px;">${card.image}</div>
                    <div style="font-size: 24px; font-weight: bold; color: #333; margin-bottom: 10px;">${card.name}</div>
                    <div style="font-size: 14px; color: #666; transform: ${isReversed ? 'rotate(180deg)' : 'none'};">
                        ${isReversed ? '逆位' : '正位'}
                    </div>
                </div>
            `;
            
            // 显示卡片信息
            const cardName = document.getElementById('card-name');
            const cardMeaning = document.getElementById('card-meaning');
            const orientationText = document.getElementById('orientation-text');
            
            cardName.textContent = card.name;
            cardMeaning.textContent = isReversed ? card.reverseMeaning : card.meaning;
            orientationText.textContent = isReversed ? '逆位' : '正位';
            
            info.style.display = 'block';
            sendBtn.style.display = 'block';
            drawBtn.style.display = 'none'; // 隐藏抽牌按钮
            
            isCardFlipped = true;
            
            // 添加翻转动画
            setTimeout(() => {
                cardDisplay.classList.add('flipped');
            }, 100);
        }

        // 发送塔罗牌
        function sendTarotCard() {
            if (!currentCard || !isCardFlipped) return;
            
            // 构建塔罗牌消息
            const isReversed = document.getElementById('orientation-text').textContent === '逆位';
            const cardMessage = `🔮 塔罗牌占卜结果：
            
🎴 抽到了：${currentCard.name}
${isReversed ? '🔄 逆位' : '✅ 正位'}
📖 含义：${isReversed ? currentCard.reverseMeaning : currentCard.meaning}

✨ 愿这张牌为你带来指引和启示！`;
            
            // 发送消息
            appendMessage(cardMessage, 'user', 'text', true, Date.now(), true);
            
            // 关闭弹窗
            closeTarotModal();
        }



        // --- V8.0: 计划 (Plan) 新增函数 ---

        function openPlanDetail(planId) {
            // 找到这个计划
            let targetPlan = null;
            let characterId = null;
            
            Object.keys(planData).forEach(charId => {
                const plan = planData[charId].find(p => p.id === planId);
                if (plan) {
                    targetPlan = plan;
                    characterId = charId;
                }
            });
            
            if (!targetPlan) {
                showMessageBox('找不到指定的计划！');
                return;
            }
            
            const character = characters.find(c => c && c.id === characterId);
            
            // 创建或更新详情模态框
            let detailModal = document.querySelector('#plan-detail-modal');
            if (!detailModal) {
                detailModal = document.createElement('div');
                detailModal.id = 'plan-detail-modal';
                detailModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden';
                detailModal.innerHTML = `
                    <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 max-h-[80vh] overflow-y-auto">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-white">约定详情</h3>
                            <button id="close-plan-detail" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                        </div>
                        <div id="plan-detail-content"></div>
                    </div>
                `;
                document.body.appendChild(detailModal);
                
                // 添加关闭事件
                detailModal.querySelector('#close-plan-detail').addEventListener('click', () => {
                    detailModal.classList.add('hidden');
                });
                
                // 点击背景关闭
                detailModal.addEventListener('click', (e) => {
                    if (e.target === detailModal) {
                        detailModal.classList.add('hidden');
                    }
                });
            }
            
            // 更新内容
            const content = detailModal.querySelector('#plan-detail-content');
            content.innerHTML = `
                <div class="space-y-4">
                    <div class="flex items-center space-x-3">
                        <div class="w-12 h-12 rounded-full bg-cover bg-center" style="background-image: url(${character?.avatar || 'https://placehold.co/96x96/777/FFF?text=?_'})"></div>
                        <div>
                            <p class="font-semibold text-white">${character?.name || '未知角色'}</p>
                            <p class="text-sm text-gray-400">约定对象</p>
                        </div>
                    </div>
                    
                    <div class="border-t border-gray-700 pt-4">
                        <h4 class="font-semibold text-white mb-2">约定内容</h4>
                        <p class="text-gray-300">${targetPlan.title}</p>
                    </div>
                    
                    ${targetPlan.details ? `
                        <div class="border-t border-gray-700 pt-4">
                            <h4 class="font-semibold text-white mb-2">详细说明</h4>
                            <p class="text-gray-300">${targetPlan.details}</p>
                        </div>
                    ` : ''}
                    
                    <div class="border-t border-gray-700 pt-4">
                        <h4 class="font-semibold text-white mb-2">状态信息</h4>
                        <div class="flex items-center space-x-2">
                            <span class="px-2 py-1 rounded text-sm ${getStatusColor(targetPlan.status)}">${targetPlan.status}</span>
                            <span class="text-gray-400 text-sm">创建于 ${new Date(targetPlan.createdAt).toLocaleString()}</span>
                        </div>
                        ${targetPlan.completedAt ? `
                            <div class="mt-2">
                                <span class="text-gray-400 text-sm">完成于 ${new Date(targetPlan.completedAt).toLocaleString()}</span>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="border-t border-gray-700 pt-4 flex space-x-2">
                        <button id="edit-plan-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                            <i class="ri-edit-line mr-2"></i>编辑
                        </button>
                        <button id="delete-plan-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">
                            <i class="ri-delete-bin-line mr-2"></i>删除
                        </button>
                    </div>
                </div>
            `;
            
            // 添加编辑和删除事件
            content.querySelector('#edit-plan-btn').addEventListener('click', () => {
                editPlan(planId);
                detailModal.classList.add('hidden');
            });
            
            content.querySelector('#delete-plan-btn').addEventListener('click', () => {
                if (confirm('确定要删除这个约定吗？')) {
                    deletePlan(planId);
                    detailModal.classList.add('hidden');
                }
            });
            
            // 显示模态框
            detailModal.classList.remove('hidden');
        }
        
        function getStatusColor(status) {
            const colorMap = {
                '已约定': 'bg-blue-600 text-white',
                '进行中': 'bg-yellow-600 text-white',
                '已完成': 'bg-green-600 text-white',
                '已取消': 'bg-gray-600 text-white'
            };
            return colorMap[status] || colorMap['已约定'];
        }
        
        function editPlan(planId) {
            // 找到这个计划
            let targetPlan = null;
            let characterId = null;
            
            Object.keys(planData).forEach(charId => {
                const plan = planData[charId].find(p => p.id === planId);
                if (plan) {
                    targetPlan = plan;
                    characterId = charId;
                }
            });
            
            if (!targetPlan) {
                showMessageBox('找不到指定的计划！');
                return;
            }
            
            // 填充编辑表单
            document.querySelector('#plan-content').value = targetPlan.title;
            document.querySelector('#plan-partner').value = characterId;
            document.querySelector('#plan-notes').value = targetPlan.details || '';
            
            // 打开编辑模态框
            document.querySelector('#plan-modal').classList.add('visible');
            
            // 更新保存按钮行为为编辑模式
            const saveBtn = document.querySelector('#save-plan-btn');
            saveBtn.textContent = '更新约定';
            saveBtn.onclick = () => updatePlan(planId, characterId);
        }
        
        function updatePlan(planId, originalCharacterId) {
            const title = document.querySelector('#plan-content').value.trim();
            const characterId = document.querySelector('#plan-partner').value;
            const details = document.querySelector('#plan-notes').value.trim();
            
            if (!title || !characterId) {
                return showMessageBox('约定内容和对象不能为空！');
            }
            
            // 如果角色改变了，需要从原角色中删除，添加到新角色中
            if (originalCharacterId !== characterId) {
                // 从原角色中删除
                planData[originalCharacterId] = planData[originalCharacterId].filter(p => p.id !== planId);
                // 添加到新角色中
                if (!planData[characterId]) {
                    planData[characterId] = [];
                }
            }
            
            // 更新计划数据
            const planToUpdate = planData[characterId].find(p => p.id === planId);
            if (planToUpdate) {
                planToUpdate.title = title;
                planToUpdate.details = details;
                planToUpdate.lastModified = Date.now();
            }
            
            saveData('planData', planData);
            
            // 关闭模态框
            document.querySelector('#plan-modal').classList.remove('visible');
            
            // 显示成功消息
            showMessageBox('约定已更新！');
            
            // 重新渲染
            setTimeout(() => {
                renderPlanList();
            }, 300);
            
            // 重置保存按钮
            const saveBtn = document.querySelector('#save-plan-btn');
            saveBtn.textContent = '保存约定';
            saveBtn.onclick = null; // 移除编辑模式的事件
        }
        
        function deletePlan(planId) {
            let planFound = false;
            Object.keys(planData).forEach(characterId => {
                const initialLength = planData[characterId].length;
                planData[characterId] = planData[characterId].filter(p => p.id !== planId);
                if (planData[characterId].length < initialLength) {
                    planFound = true;
                }
            });

            if (planFound) {
                saveData('planData', planData);
                showMessageBox('约定已删除');
                renderPlanList(); // 重新渲染列表
            }
        }

        function renderPlanList() {
            console.log(`[渲染开始] ${new Date().toLocaleTimeString()}`);
            const container = document.querySelector('#plan-list-container');
            
            if (!container) {
                console.error("[渲染错误] 找不到ID为 'plan-list-container' 的容器。");
                return;
            }
            
            // 检查容器是否可见 - 如果我们在计划标签页中，强制显示容器
            if (container.closest('.hidden')) {
                console.log("[渲染日志] 容器当前被隐藏，尝试强制显示...");
                // 如果我们在计划标签页中，强制显示容器
                const planTab = document.querySelector('.wechat-tab-item[data-tab="plan"]');
                if (planTab && planTab.classList.contains('active')) {
                    console.log("[渲染日志] 当前在计划标签页，强制显示容器");
                    container.classList.remove('hidden');
                    // 同时确保父容器也可见
                    const contentContainer = container.closest('#wechat-content-container');
                    if (contentContainer) {
                        contentContainer.classList.remove('hidden');
                    }
                } else {
                    console.log("[渲染日志] 不在计划标签页，跳过渲染。");
                    return;
                }
            }
            
            console.log("[渲染日志] 当前planData:", planData);
            console.log("[渲染日志] 当前characters:", characters);
            
            container.innerHTML = '';
            console.log("[渲染日志] 容器已清空。");

            let allPlans = [];
            if (planData && typeof planData === 'object' && characters && Array.isArray(characters)) {
                Object.keys(planData).forEach(characterId => {
                    const character = characters.find(c => c && c.id === characterId);
                    if (character && planData[characterId] && Array.isArray(planData[characterId])) {
                        planData[characterId].forEach(plan => {
                            allPlans.push({ ...plan, characterName: character.name, characterAvatar: character.avatar });
                        });
                    }
                });
            }
            
            console.log(`[渲染日志] 准备渲染 ${allPlans.length} 个计划。`);

            if (allPlans.length === 0) {
                container.innerHTML = `
                    <div class="text-center text-gray-400 p-12">
                        <i class="ri-calendar-check-line text-5xl mb-4"></i>
                        <p class="font-semibold">还没有任何约定</p>
                        <p class="text-sm mt-2">点击上方的"添加约定"按钮添加一个吧！</p>
                    </div>
                `;
                console.log("[渲染日志] 已渲染空状态。");
                return;
            }

            allPlans.sort((a, b) => b.createdAt - a.createdAt);

            allPlans.forEach(plan => {
                const planCard = document.createElement('div');
                planCard.className = 'ticket-wrapper';
                planCard.dataset.planId = plan.id;

                const statusMap = {
                    '已约定': { text: '已约定', icon: 'ri-time-line', color: 'text-blue-400' },
                    '进行中': { text: '进行中', icon: 'ri-loader-4-line animate-spin', color: 'text-yellow-400' },
                    '已完成': { text: '已完成', icon: 'ri-checkbox-circle-line', color: 'text-green-400' },
                    '已取消': { text: '已取消', icon: 'ri-close-circle-line', color: 'text-gray-500' }
                };
                const statusInfo = statusMap[plan.status] || statusMap['已约定'];

                planCard.innerHTML = `
                    <!-- 内部的机票 (包含所有详细信息) -->
                    <div class="ticket">
                        <div class="ticket-main">
                            <div class="info-header">
                                <p>SPECIAL INVITATION</p>
                                <p>ADMITS ONE</p>
                            </div>
                            <div class="event-title">
                                ${plan.title}
                            </div>
                            <div class="event-details">
                                <div class="detail-item">
                                    <span>With</span>
                                    <strong>${plan.characterName}</strong>
                                </div>
                                <div class="detail-item">
                                    <span>日期 / DATE</span>
                                    <strong>${new Date(plan.createdAt).toLocaleDateString('zh-CN', { 
                                        year: 'numeric', 
                                        month: 'long', 
                                        day: 'numeric'
                                    })}</strong>
                                </div>
                            </div>
                        </div>
                        <div class="ticket-stub">
                            <p>INVITATION</p>
                        </div>
                    </div>
                    <!-- 票夹 (用于遮挡机票) -->
                    <div class="sleeve">
                        <div class="sleeve-content">
                            <p class="main-title">INVITATION</p>
                            <p class="subtitle">A DATE WITH ${plan.characterName.toUpperCase()}</p>
                        </div>
                    </div>
                `;
                container.appendChild(planCard);
            });
            
            // 设置机票点击事件监听器
            setupTicketClickListeners();
            console.log(`[渲染结束] 成功向容器添加了 ${container.childElementCount} 个计划卡片。`);
            console.log("[渲染日志] 容器最终内容:", container.innerHTML.substring(0, 200) + "...");
        }

        // 为所有机票邀请函添加点击展开/收起和长按删除的功能
        function setupTicketClickListeners() {
            const ticketWrappers = document.querySelectorAll('.ticket-wrapper');
            
            ticketWrappers.forEach(wrapper => {
                let pressTimer;
                let isLongPress = false;
                let hasMoved = false;

                const planId = wrapper.dataset.planId;
                const planTitle = wrapper.querySelector('.event-title')?.textContent.trim() || '这个约定';

                const startPress = () => {
                    isLongPress = false;
                    hasMoved = false;
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                        wrapper.classList.add('deleting'); // 添加震动效果
                        
                        // 触发手机震动（如果支持）
                        if (navigator.vibrate) {
                            navigator.vibrate(100);
                        }
                        
                        // 0.5秒后显示删除确认
                        setTimeout(() => {
                            showDeleteConfirmation('plan', planId, planTitle);
                            wrapper.classList.remove('deleting');
                        }, 500);

                    }, 750); // 750毫秒定义为长按
                };

                const cancelPress = () => {
                    clearTimeout(pressTimer);
                };

                const endPress = (event) => { // 1. 接收 event 对象
                    // 2. 阻止"幽灵点击"：这行代码是本次修复的关键
                    // 它告诉浏览器，触摸事件已处理，无需再模拟后续的鼠标点击
                    if (event) {
                        event.preventDefault();
                    }
                    
                    clearTimeout(pressTimer);
                    if (!isLongPress && !hasMoved) {
                        // 如果不是长按，并且没有移动，则执行单击操作
                        
                        // (保留之前的修复) 使用 requestAnimationFrame 确保动画流畅触发
                        requestAnimationFrame(() => {
                            wrapper.classList.toggle('open');
                        });
                    }
                };

                // 鼠标事件
                wrapper.addEventListener('mousedown', startPress);
                wrapper.addEventListener('mouseup', endPress);
                wrapper.addEventListener('mouseleave', cancelPress);
                wrapper.addEventListener('mousemove', () => { hasMoved = true; cancelPress(); });

                // 触摸事件
                wrapper.addEventListener('touchstart', startPress);
                wrapper.addEventListener('touchend', endPress);
                wrapper.addEventListener('touchmove', () => { hasMoved = true; cancelPress(); });
            });
        }

        function toggleTicketOpen() {
            this.classList.toggle('open');
        }

        // --- 页面初始化时添加新的事件监听器 ---
        function addNewEventListeners() {
            if (window.eventListenersAdded) return;
            window.eventListenersAdded = true;

            // 发布动态模态框
            $('#moment-image-upload-btn').addEventListener('click', () => $('#moment-image-input').click());
            $('#moment-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    tempMomentImage = await compressImage(file, { maxWidth: 600 });
                    $('#moment-image-label').textContent = '图片已选择 ✓';
                    e.target.value = ''; // 重置输入，以便再次选择相同文件
                }
            });
            // 动态按钮事件监听器
            $('#wechat-new-moment-button').addEventListener('click', () => {
                // 清空之前的內容和圖片
                $('#moment-content-input').value = '';
                $('#moment-image-label').textContent = '添加图片 (可选)';
                tempMomentImage = null;
                $('#post-moment-modal').classList.add('visible');
            });
            
            $('#cancel-post-moment-btn').addEventListener('click', () => {
                // 清空圖片和輸入框
                $('#moment-content-input').value = '';
                $('#moment-image-label').textContent = '添加图片 (可选)';
                tempMomentImage = null;
                $('#post-moment-modal').classList.remove('visible');
            });
            // V30.2 修复用户本地上传图片逻辑
            $('#confirm-post-moment-btn').addEventListener('click', async () => {
                const authorId = 'user'; // 用户只能发布自己的动态
                const content = $('#moment-content-input').value.trim();

                if (!content && !tempMomentImage) {
                    return showMessageBox("动态内容和图片至少要有一个");
                }

                // --- 核心修复逻辑开始 ---
                let imageId = null;
                // 如果有临时图片文件(来自本地上传)，则先将其保存到数据库
                if (tempMomentImage) {
                    try {
                        // 使用我们已有的图片处理和保存函数，它会返回一个ID
                        imageId = await handleImageUpload({ files: [tempMomentImage] }, null, `moment_user_${Date.now()}`);
                    } catch (error) {
                        console.error("保存用户动态图片到DB时失败:", error);
                        showMessageBox("图片保存失败，请重试。");
                        return; // 保存失败则终止发布
                    }
                }
                // --- 核心修复逻辑结束 ---

                if (!momentsData[authorId]) {
                    momentsData[authorId] = [];
                }
                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    image: imageId, // 存储的是从数据库返回的ID
                    authorId: authorId,
                    likes: { count: 0, users: [] },
                    comments: []
                };
                
                momentsData[authorId].push(newMoment);
                saveData('momentsData', momentsData);

                // 触发AI角色的智能评论
                triggerAICharacterComments(newMoment);

                renderUnifiedMoments();
                $('#post-moment-modal').classList.remove('visible');
                showMessageBox('动态发布成功！');
                
                // 重置输入框和临时图片
                $('#moment-content-input').value = '';
                $('#moment-image-label').textContent = '添加图片 (可选)';
                tempMomentImage = null;
            });

            // 日记本书架点击事件
            $('#wechat-diary-container').addEventListener('click', (e) => {
                const bookItem = e.target.closest('.diary-book-item');
                if (bookItem) {
                    const ownerId = bookItem.dataset.ownerId;
                    const notebookId = bookItem.dataset.notebookId;
                    
                    if (notebookId) {
                        // 如果是笔记本，打开笔记本
                        openNotebook(notebookId);
                    } else if (ownerId) {
                        // 如果是日记本，打开日记本
                        openDiaryBook(ownerId);
                    }
                }
                
                // 封面编辑按钮点击事件
                const coverEditBtn = e.target.closest('.diary-cover-edit-btn');
                if (coverEditBtn) {
                    e.stopPropagation();
                    
                    const ownerId = coverEditBtn.closest('.diary-book-item').dataset.ownerId;
                    changeDiaryCover(e, ownerId);
                }
            });

            // --- V8.0: 计划模块交互事件 ---
            $('#wechat-new-plan-button').addEventListener('click', () => {
                // 更新模态框标题（通过modal-title类）
                const modalTitle = document.querySelector('#plan-modal .modal-title');
                if (modalTitle) {
                    modalTitle.textContent = '创建新的约定';
                }
                
                $('#plan-content').value = '';
                $('#plan-notes').value = '';
                
                // 移除旧的editing-plan-id相关代码，因为新结构中没有这个元素
                // $('#editing-plan-id').value = '';

                const characterSelect = $('#plan-partner');
                characterSelect.innerHTML = '';
                characters.forEach(char => {
                    const option = document.createElement('option');
                    option.value = char.id;
                    option.textContent = char.name;
                    characterSelect.appendChild(option);
                });

                $('#plan-modal').classList.add('visible');
            });

            $('#cancel-plan-btn').addEventListener('click', () => {
                $('#plan-modal').classList.remove('visible');
            });

            const savePlanButton = document.querySelector('#save-plan-btn');
            if (savePlanButton) {
                // 创建一个按钮的克隆体，这个操作会移除所有旧的、可能重复的事件监听器
                const newSavePlanButton = savePlanButton.cloneNode(true);
                savePlanButton.parentNode.replaceChild(newSavePlanButton, savePlanButton);

                // 只为这个全新的、干净的按钮添加唯一的点击事件
                newSavePlanButton.addEventListener('click', () => {
                    const title = document.querySelector('#plan-content').value.trim();
                    const characterId = document.querySelector('#plan-partner').value;
                    const details = document.querySelector('#plan-notes').value.trim();
                    
                    if (!title || !characterId) {
                        return showMessageBox('约定内容和对象不能为空！');
                    }
                    
                    if (!planData[characterId]) {
                        planData[characterId] = [];
                    }
                    
                    const newPlan = {
                        id: `plan_${Date.now()}`,
                        title,
                        details,
                        status: '已约定',
                        createdAt: Date.now(),
                        completedAt: null
                    };
                    
                    planData[characterId].push(newPlan);
                    saveData('planData', planData);
                    
                    // 显示红点通知
                    showNotificationDot('plan');
                    
                    // 关闭模态框
                    document.querySelector('#plan-modal').classList.remove('visible');
                    
                    // 显示成功消息
                    showMessageBox('新的约定已保存！');
                    
                    // 等待消息显示完成后再渲染
                    setTimeout(() => {
                        console.log("[保存后] 准备重新渲染，当前planData:", planData);
                        console.log("[保存后] 当前容器状态:", document.querySelector('#plan-list-container')?.innerHTML?.substring(0, 100) || "容器不存在");
                        
                        // 确保容器是可见的
                        const planContainer = document.querySelector('#plan-list-container');
                        if (planContainer && planContainer.closest('.hidden')) {
                            console.log("[保存后] 检测到容器被隐藏，强制显示");
                            planContainer.classList.remove('hidden');
                            // 同时确保父容器也可见
                            const contentContainer = planContainer.closest('#wechat-content-container');
                            if (contentContainer) {
                                contentContainer.classList.remove('hidden');
                            }
                        }
                        
                        // 强制重新加载数据以确保同步
                        const reloadedPlanData = loadData('planData', {});
                        console.log("[保存后] 重新加载的planData:", reloadedPlanData);
                        
                        // 更新全局变量
                        planData = reloadedPlanData;
                        
                        // 重新渲染
                        renderPlanList();
                    }, 300);
                });
            }

            $('#plan-list-container').addEventListener('click', (e) => {
                const statusTag = e.target.closest('.status-tag');
                const planCard = e.target.closest('.ticket-wrapper');
                const editBtn = e.target.closest('.edit-plan-btn');
                const deleteBtn = e.target.closest('.delete-plan-btn');
                
                // 处理状态标签点击
                if (statusTag) {
                    const planId = statusTag.dataset.planId;
                    const statuses = ['已约定', '进行中', '已完成', '已取消'];
                    let currentStatus;
                    let characterId;

                    // 找到这个plan并获取当前状态
                    Object.keys(planData).forEach(charId => {
                        const plan = planData[charId].find(p => p.id === planId);
                        if (plan) {
                            currentStatus = plan.status;
                            characterId = charId;
                        }
                    });

                    if (currentStatus && characterId) {
                        const currentIndex = statuses.indexOf(currentStatus);
                        const nextIndex = (currentIndex + 1) % statuses.length;
                        const newStatus = statuses[nextIndex];

                        // 更新数据
                        const planToUpdate = planData[characterId].find(p => p.id === planId);
                        planToUpdate.status = newStatus;
                        if (newStatus === '已完成') {
                            planToUpdate.completedAt = Date.now();
                        } else {
                            planToUpdate.completedAt = null;
                        }

                        saveData('planData', planData);
                        // 添加延迟确保数据同步完成后再渲染
                        setTimeout(() => {
                            console.log("[状态更新后] 准备重新渲染，当前planData:", planData);
                            console.log("[状态更新后] 当前容器状态:", document.querySelector('#plan-list-container')?.innerHTML?.substring(0, 100) || "容器不存在");
                            
                            // 确保容器是可见的
                            const planContainer = document.querySelector('#plan-list-container');
                            if (planContainer && planContainer.closest('.hidden')) {
                                console.log("[状态更新后] 检测到容器被隐藏，强制显示");
                                planContainer.classList.remove('hidden');
                                // 同时确保父容器也可见
                                const contentContainer = planContainer.closest('#wechat-content-container');
                                if (contentContainer) {
                                    contentContainer.classList.remove('hidden');
                                }
                            }
                            
                            // 强制重新加载数据以确保同步
                            const reloadedPlanData = loadData('planData', {});
                            console.log("[状态更新后] 重新加载的planData:", reloadedPlanData);
                            
                            // 更新全局变量
                            planData = reloadedPlanData;
                            
                            // 重新渲染
                            renderPlanList();
                        }, 300);
                    }
                }
                
                // 处理机票点击 - 展开/收起详情
                if (planCard && !statusTag) {
                    // 机票的展开/收起逻辑已经通过CSS动画实现
                    // 这里可以添加其他交互逻辑
                }
                
                // 处理编辑按钮点击
                if (editBtn) {
                    const planId = editBtn.dataset.planId;
                    editPlan(planId);
                }
                
                // 处理删除按钮点击
                if (deleteBtn) {
                    const planId = deleteBtn.dataset.planId;
                    if (confirm('确定要删除这个约定吗？')) {
                        deletePlan(planId);
                    }
                }
            });

            // 日记本翻页和关闭事件
            $('#prev-page-btn').addEventListener('click', () => {
                if (currentOpenBook && currentOpenBook.entries && currentOpenBook.currentPage > 0) {
                    currentOpenBook.currentPage--;
                    renderDiaryPages();
                } else {
                    // 已经是第一页了
                    showMessageBox('已经是第一页了');
                }
            });

            $('#next-page-btn').addEventListener('click', () => {
                if (currentOpenBook && currentOpenBook.entries && currentOpenBook.currentPage < currentOpenBook.entries.length - 1) {
                    currentOpenBook.currentPage++;
                    renderDiaryPages();
                } else {
                    // 已经是最后一页了
                    showMessageBox('已经是最后一页了');
                }
            });

            $('#add-page-btn').addEventListener('click', () => {
                // 添加新日记条目到当前打开的日记本
                if (currentOpenBook && currentOpenBook.entries) {
                    const newContent = prompt('请输入新的日记内容：');
                    if (newContent && newContent.trim()) {
                        // 创建新的日记条目
                        const newEntry = {
                            id: `diary_${Date.now()}`,
                            timestamp: Date.now(),
                            content: newContent.trim(),
                            lastModified: Date.now()
                        };
                        
                        // 添加到当前日记本
                        currentOpenBook.entries.push(newEntry);
                        
                        // 如果是笔记本，更新笔记本数据
                        if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                            currentOpenBook.notebookData.entries = currentOpenBook.entries;
                            currentOpenBook.notebookData.lastModified = Date.now();
                            saveData('notebookData', notebookData);
                        } else {
                            // 更新日记数据
                            if (!diaryData[currentOpenBook.ownerId]) {
                                diaryData[currentOpenBook.ownerId] = [];
                            }
                            diaryData[currentOpenBook.ownerId].push(newEntry);
                            saveData('diaryData', diaryData);
                        }
                        
                        // 跳转到新添加的页面
                        currentOpenBook.currentPage = currentOpenBook.entries.length - 1;
                        
                        // 刷新显示
                        renderDiaryPages();
                        
                        showMessageBox('新日记已添加！');
                    }
                } else {
                    // 如果没有打开的日记本，则创建新笔记本
                    createNewNotebook();
                }
            });

            // 朋友圈头像点击事件
            $('#moments-feed').addEventListener('click', (e) => {
                const avatar = e.target.closest('.w-10.h-10');
                if (avatar) {
                    const authorId = avatar.dataset.authorId;
                    if (authorId === 'user') {
                        // 用户头像点击，打开头像更换
                        $('#user-avatar-input').click();
                    } else {
                        // 角色头像点击，显示角色信息
                        const character = characters.find(c => c.id === authorId);
                        if (character) {
                            showMessageBox(`${character.name}的头像`);
                        }
                    }
                }
                
                // 动态点赞功能
                const likeBtn = e.target.closest('.moment-action-btn');
                if (likeBtn && likeBtn.querySelector('.ri-thumb-up-line')) {
                    const momentId = likeBtn.dataset.momentId;
                    likeBtn.classList.toggle('liked');
                    const icon = likeBtn.querySelector('i');
                    if (likeBtn.classList.contains('liked')) {
                        icon.className = 'ri-thumb-up-fill';
                        icon.style.color = '#ef4444';
                    } else {
                        icon.className = 'ri-thumb-up-line';
                        icon.style.color = '';
                    }
                }
            });
            
            // 朋友圈头部头像点击事件 - 已移除，现在在HTML中直接调用函数
            
            // 朋友圈事件监听器现在在切换到朋友圈标签时动态添加
            
            // 日记本翻页控制
            $('#close-diary-book-btn').addEventListener('click', () => $('#diary-book-modal').classList.add('hidden'));
            
            // 日记本文本编辑功能
            $('#diary-book-modal').addEventListener('click', (e) => {
                const editableText = e.target.closest('.diary-page-text');
                if (editableText && editableText.contentEditable === 'true') {
                    // 保存原始内容
                    const originalContent = editableText.textContent;
                    const entryId = editableText.dataset.entryId;
                    

                    
                    // 处理键盘事件
                    const handleKeyDown = (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            const newContent = editableText.textContent.trim();
                            if (newContent && newContent !== originalContent) {
                                updateDiaryEntry(entryId, newContent);
                                showMessageBox('日记已保存');
                            }
                            editableText.contentEditable = false;
                            editableText.removeEventListener('keydown', handleKeyDown);
                        } else if (e.key === 'Escape') {
                            editableText.textContent = originalContent;
                            editableText.contentEditable = false;
                            editableText.removeEventListener('keydown', handleKeyDown);
                        }
                    };
                    
                    editableText.addEventListener('keydown', handleKeyDown);
                    editableText.focus();
                }
            });
            
            // 画板功能事件监听器
            setupDrawingBoardEvents();

                    // 笔记本相关事件监听器
        setupNotebookEvents();

        // 图片裁剪模态框事件监听器
        setupCropperEvents();

        // 【新增】处理日记本内页顶部横幅更换的事件
        document.body.addEventListener('click', function(event) {
            if (event.target.id === 'change-diary-banner-btn' || event.target.closest('#change-diary-banner-btn')) {
                event.stopPropagation();

                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file && currentOpenBook.ownerId) {
                        // 显示图片裁剪界面
                        showImageCropper(file, async (croppedDataUrl) => {
                            try {
                                // 使用新的命名规则保存独立的横幅图片
                                const ownerId = currentOpenBook.ownerId;
                                saveData(`diary_banner_${ownerId}`, croppedDataUrl);

                                // 立刻更新当前页面的显示
                                const coverElement = document.getElementById('diary-book-cover');
                                // 完全覆盖CSS样式，确保图片显示
                                coverElement.style.cssText = `
                                    background: url(${croppedDataUrl}) center center / cover no-repeat !important;
                                    background-image: url(${croppedDataUrl}) !important;
                                    background-size: cover !important;
                                    background-repeat: no-repeat !important;
                                    background-position: center !important;
                                `;

                                showMessageBox('顶部横幅图片已更新');
                            } catch (error) {
                                showMessageBox('横幅图片处理失败');
                            }
                        });
                    }
                };
                input.click();
            }
        });

            // [AI, 请将这段代码添加到 addNewEventListeners 函数的末尾]
            const diaryPagesContainer = $('#diary-pages-container');
            if (diaryPagesContainer) {
                diaryPagesContainer.addEventListener('click', (e) => {
                    // 排除封面元素、編輯狀態的元素，以及任何在封面上的點擊
                    if (e.target.closest('.diary-page-text, .diary-delete-btn, .diary-cover, .editing') || 
                        e.target.closest('#diary-book-cover') ||
                        e.target.closest('#diary-cover-title') ||
                        e.target.closest('#diary-cover-author')) {
                        return;
                    }
                    const containerWidth = diaryPagesContainer.offsetWidth;
                    const clickX = e.offsetX;
                    if (clickX < containerWidth / 2) {
                        goToPrevPage();
                    } else {
                        goToNextPage();
                    }
                });
            }

            // 为"清空聊天记录"按钮添加事件
            $('#clear-chat-history-option').addEventListener('click', () => {
                if (currentChatCharacterId) {
                    const characterName = characters.find(c => c.id === currentChatCharacterId)?.name;
                    showDeleteConfirmation('clear-chat', currentChatCharacterId, `与 ${characterName} 的聊天记录`);
                }
            });

            // --- V8.1: 新增通话输入框高度自适应事件 ---
            const voiceCallInput = document.getElementById('voice-call-input');
            const videoCallInput = document.getElementById('video-call-input');
            if (voiceCallInput) {
                voiceCallInput.addEventListener('input', () => adjustCallInputHeight(voiceCallInput));
            }
            if (videoCallInput) {
                videoCallInput.addEventListener('input', () => adjustCallInputHeight(videoCallInput));
            }

            // --- V8.1: 新增通话重试按钮事件 ---
            const voiceCallRetryBtn = document.getElementById('voice-call-retry-btn');
            const videoCallRetryBtn = document.getElementById('video-call-retry-btn');
            if(voiceCallRetryBtn) {
                voiceCallRetryBtn.addEventListener('click', () => handleCallRetry('voice'));
            }
            if(videoCallRetryBtn) {
                videoCallRetryBtn.addEventListener('click', () => handleCallRetry('video'));
            }
        }

        // 设置笔记本相关事件监听器
        function setupNotebookEvents() {
            // 笔记本类型选择变化
            $('#new-notebook-type').addEventListener('change', handleNotebookTypeChange);
            
            // 关闭新笔记本模态框
            $('#close-new-notebook-modal').addEventListener('click', () => {
                $('#new-notebook-modal').classList.add('hidden');
            });
            
            // 取消创建笔记本
            $('#cancel-new-notebook-btn').addEventListener('click', () => {
                $('#new-notebook-modal').classList.add('hidden');
            });
            
            // 确认创建笔记本
            $('#confirm-new-notebook-btn').addEventListener('click', confirmCreateNotebook);
            
            // 笔记本操作事件委托
            document.addEventListener('click', (e) => {
                // 编辑笔记本
                if (e.target.closest('.notebook-edit-btn')) {
                    const notebookId = e.target.closest('.notebook-edit-btn').dataset.notebookId;
                    editNotebook(notebookId);
                }
                
                // 删除笔记本
                if (e.target.closest('.notebook-delete-btn')) {
                    const notebookId = e.target.closest('.notebook-delete-btn').dataset.notebookId;
                    deleteNotebook(notebookId);
                }
                
                // 打开笔记本
                if (e.target.closest('.notebook-item')) {
                    const notebookId = e.target.closest('.notebook-item').dataset.notebookId;
                    if (!e.target.closest('.notebook-actions')) {
                        openNotebook(notebookId);
                    }
                }
            });
        }

        // 设置图片裁剪模态框事件监听器
        function setupCropperEvents() {
            // 关闭裁剪模态框
            $('#close-cropper-btn').addEventListener('click', () => {
                $('#image-cropper-modal').classList.add('hidden');
                if (cropperInstance) {
                    cropperInstance.destroy();
                }
            });

            // 重置裁剪
            $('#reset-crop-btn').addEventListener('click', () => {
                const img = document.getElementById('cropper-image');
                if (img.complete) {
                    initCropper(img);
                }
            });

            // 确认裁剪
            $('#confirm-crop-btn').addEventListener('click', () => {
                const croppedDataUrl = cropImage();
                if (croppedDataUrl && currentCropCallback) {
                    // 关闭模态框
                    $('#image-cropper-modal').classList.add('hidden');
                    if (cropperInstance) {
                        cropperInstance.destroy();
                    }
                    
                    // 调用回调函数
                    currentCropCallback(croppedDataUrl);
                    currentCropCallback = null;
                }
            });

            // 点击模态框背景关闭
            $('#image-cropper-modal').addEventListener('click', (e) => {
                if (e.target.id === 'image-cropper-modal') {
                    $('#image-cropper-modal').classList.add('hidden');
                    if (cropperInstance) {
                        cropperInstance.destroy();
                    }
                }
            });
        }

        // 编辑笔记本
        function editNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            const newName = prompt('请输入新的笔记本名称：', notebook.name);
            if (newName && newName.trim() && newName !== notebook.name) {
                notebook.name = newName.trim();
                notebook.lastModified = Date.now();
                saveData('notebookData', notebookData);
                showDiaryBookshelf();
                showMessageBox('笔记本名称已更新');
            }
        }

        // 删除笔记本
        function deleteNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            if (confirm(`确定要删除笔记本"${notebook.name}"吗？此操作无法撤销。`)) {
                delete notebookData[notebookId];
                saveData('notebookData', notebookData);
                showDiaryBookshelf();
                showMessageBox('笔记本已删除');
            }
        }

        // 打开笔记本
        function openNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            // 设置当前打开的笔记本
            currentOpenBook = {
                ownerId: notebookId,
                entries: notebook.entries || [],
                currentPage: 0,
                isNotebook: true,
                notebookData: notebook
            };
            
            // 更新封面信息
            $('#diary-cover-title').textContent = notebook.name;
            $('#diary-cover-author').textContent = `by ${notebook.type}`;
            
            // 显示新增按钮（笔记本可以添加页面）
            $('#add-page-btn').style.display = 'flex';
            
            // 设置封面图片
            if (notebook.cover) {
                // 完全覆盖CSS样式，确保图片显示
                $('#diary-book-cover').style.cssText = `
                    background: url(${notebook.cover}) center center / cover no-repeat !important;
                    background-image: url(${notebook.cover}) !important;
                    background-size: cover !important;
                    background-repeat: no-repeat !important;
                    background-position: center !important;
                `;
            } else {
                // 恢复默认渐变背景
                $('#diary-book-cover').style.cssText = '';
            }
            
            // 渲染页面
            renderDiaryPages();
            
            // 显示模态框
            $('#diary-book-modal').classList.remove('hidden');
            $('#diary-book').classList.remove('open');
        }

        // ------------------------------------


        // 初始化與事件監聽器
        document.addEventListener('DOMContentLoaded', async () => {
            // 检测是否处于独立模式 (添加到主屏幕后打开)
            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log("App is running in standalone (full-screen) mode.");
                document.body.classList.add('standalone-mode');
            } else {
                console.log("App is running in a browser tab.");
            }
            
            await loadAllSavedData();
            await loadAllData();
            
            // 初始化一些示例日记数据（如果还没有的话）
            if (Object.keys(diaryData).length === 0) {
                diaryData.user = [];
                saveData('diaryData', diaryData);
            }
            
            // 初始化一些示例計劃數據（如果還沒有的話）
            if (Object.keys(planData).length === 0) {
                // 創建示例角色
                if (characters.length === 0) {
                    characters.push({
                        id: 'char_example_1',
                        name: '小紅',
                        avatar: 'https://placehold.co/96x96/ef4444/ffffff?text=小紅',
                        personality: '活潑開朗，喜歡戶外活動'
                    });
                    characters.push({
                        id: 'char_example_2',
                        name: '小明',
                        avatar: 'https://placehold.co/96x96/3b82f6/ffffff?text=小明',
                        personality: '溫和友善，喜歡讀書'
                    });
                    saveData('characters', characters);
                }
                
                // 創建示例計劃
                planData['char_example_1'] = [
                    {
                        id: 'plan_example_1',
                        title: '週末野餐約會',
                        details: '在中央公園舉辦野餐，帶上三明治和水果，享受陽光和微風。',
                        status: '已約定',
                        createdAt: Date.now() - 86400000, // 1天前
                        completedAt: null
                    },
                    {
                        id: 'plan_example_2',
                        title: '電影之夜',
                        details: '一起看最新的科幻電影，然後討論劇情和特效。',
                        status: '進行中',
                        createdAt: Date.now() - 172800000, // 2天前
                        completedAt: null
                    }
                ];
                
                planData['char_example_2'] = [
                    {
                        id: 'plan_example_3',
                        title: '圖書館學習日',
                        details: '在圖書館一起學習，互相幫助解決難題，然後去咖啡廳放鬆。',
                        status: '已完成',
                        createdAt: Date.now() - 259200000, // 3天前
                        completedAt: Date.now() - 86400000 // 1天前完成
                    }
                ];
                
                saveData('planData', planData);
                console.log('[示例數據] 已創建示例計劃數據');
            }
            

            
            updateTime();
            setInterval(updateTime, 60000);
            


            // 加载朋友圈背景和用户信息
            loadMomentsCover();
            loadMomentsUserInfo();

            // 初始化智能朋友圈触发系统
            console.log('智能朋友圈触发系统已初始化');
            console.log('⚠️ 注意：系统需要API连接才能工作');
            console.log('触发系统功能：', {
                '对话驱动触发': '连续8句对话后可能触发（根据性格调整）',
                '情感高點觸發': '情感强度达到0.9可能触发（根据性格调整）',
                '时间流逝触发': '6小时无互动可能触发（根据性格调整）',
                '防刷机制': '最少2小时才能发下一条朋友圈',
                '性格适配': '内向角色几乎不发，外向角色经常发',
                'API要求': '必须连接API才能生成智能朋友圈'
            });

            showScreen('home-screen');

            // 添加测试按钮事件监听器
            const testCallBtn = document.getElementById('test-call-btn');
            if (testCallBtn) {
                testCallBtn.addEventListener('click', () => {
                    console.log('测试按钮被点击');
                    if (characters.length > 0) {
                        triggerIncomingCall('voice', characters[0].id);
                    } else {
                        console.log('没有可用的角色进行测试');
                    }
                });
            }

            $('#theme-toggle').addEventListener('click', toggleTheme);
            $$('.app-icon').forEach(icon => {
                icon.addEventListener('click', () => {
                    const appName = icon.dataset.appName;
                    if (appName === "微信") {
                        renderWeChatList();
                        resetWeChatTabs(); // FIX 5: Reset tabs when opening WeChat
                        showScreen('wechat-list-screen');
                    }
                    else if (appName === "世界书") { renderWorldBookList(); showScreen('world-book-list-screen'); }
                    else if (appName === "角色书") { renderCharacterBookList(); showScreen('character-book-list-screen'); }
                    else if (appName === "设置") showScreen('main-settings-screen');
                });
            });
            
            $('#wechat-list-back-button').addEventListener('click', () => {
                currentWeChatCharacterId = null; // V7.0: Clear character context
                showScreen('home-screen');
            });
            $('#wechat-chat-back-button').addEventListener('click', () => {
                // --- 在这里添加新代码 ---
                resetChatUIState();
                // -----------------------
                
                renderWeChatList();
                currentChatCharacterId = null;
                resetWeChatTabs(); // FIX 5: Reset tabs when going back to list
                showScreen('wechat-list-screen');
            });
            $('#main-settings-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#api-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#api-settings-link').addEventListener('click', () => showScreen('api-settings-screen'));
            $('#wb-list-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#wb-edit-back-button').addEventListener('click', () => { renderWorldBookList(); showScreen('world-book-list-screen'); });
            $('#cb-list-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#cb-edit-back-button').addEventListener('click', () => { renderCharacterBookList(); showScreen('character-book-list-screen'); });
            $('#beautify-settings-link').addEventListener('click', () => showScreen('beautify-settings-screen'));
            $('#beautify-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#change-app-icons-link').addEventListener('click', () => {
                renderAppIconSettings();
                showScreen('app-icon-settings-screen');
            });
            $('#app-icon-settings-back-button').addEventListener('click', () => showScreen('beautify-settings-screen'));
            $('#font-settings-link').addEventListener('click', () => showScreen('font-settings-screen'));
            $('#font-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));

            $('#music-block').addEventListener('click', (e) => { if (e.target === e.currentTarget) $('#background-input').click(); });
            $('#background-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#music-block'), 'saved_music_background');
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#music-block').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#vinyl-record').addEventListener('click', () => $('#vinyl-input').click());
            $('#vinyl-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#vinyl-record'), 'saved_vinyl_cover');
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#vinyl-record').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#photo-widget').addEventListener('click', () => $('#photo-widget-input').click());
            $('#photo-widget-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#photo-widget'), 'saved_photo_widget', { hideTextElement: '#photo-widget-text' });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#photo-widget').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#widget-image-placeholder').addEventListener('click', () => $('#widget-image-input').click());
            $('#widget-image-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#widget-image-placeholder'), 'saved_widget_image');
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#widget-image-placeholder').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#character-avatar-placeholder').addEventListener('click', () => $('#character-avatar-input').click());
            $('#character-avatar-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#character-avatar-placeholder'), null, { compression: { maxWidth: 256, maxHeight: 256 } });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#character-avatar-placeholder').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });

            $('#mood-text').addEventListener('input', (e) => saveData('saved_mood_text', e.target.value));
            $('#widget-name-input').addEventListener('input', (e) => saveData('saved_widget_name', e.target.value));
            $('#widget-thinking-input').addEventListener('input', (e) => saveData('saved_widget_thinking', e.target.value));
            $('#widget-location-input').addEventListener('input', (e) => saveData('saved_widget_location', e.target.value));

            $('#music-upload-button').addEventListener('click', () => $('#music-upload-input').click());
            $('#music-upload-input').addEventListener('change', async (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    showMessageBox(`正在处理 ${files.length} 首歌曲...`);
                    
                    for (const file of files) {
                        try {
                            // For music, we don't compress, we store the original file blob
                            const songId = `song_${Date.now()}_${file.name}`;
                            await saveImageToDB(songId, file); // Using the same DB function to store the file blob

                            // Add the new song with its ID to the list
                            songList.push({
                                id: songId,
                                name: file.name,
                                url: URL.createObjectURL(file) // Create temporary URL for immediate playback
                            });
                            
                        } catch (error) {
                            console.error("处理歌曲失败:", file.name, error);
                            showMessageBox(`处理歌曲 ${file.name} 失败。`);
                        }
                    }

                    // Save the list of song objects (now with IDs and names) to localStorage
                    const savableList = songList.map(s => ({ id: s.id, name: s.name }));
                    saveData('songList', savableList);
                    
                    updateSongListUI();
                    
                    if (currentSongIndex === -1 && songList.length > 0) {
                        playSong(0);
                    }
                    showMessageBox('歌曲添加完成！');
                }
                e.target.value = ''; // Reset input to allow re-uploading the same file
            });
            $('#playlist-button').addEventListener('click', () => $('#song-list-modal').classList.add('visible'));
            $('#close-playlist-modal').addEventListener('click', () => $('#song-list-modal').classList.remove('visible'));
            $('#play-pause-button').addEventListener('click', () => {
                if (songList.length === 0) return showMessageBox('請先上傳歌曲');
                if (currentAudio.paused) {
                    if (currentSongIndex === -1) playSong(0);
                    else {
                        currentAudio.play();
                        startSpinning();
                    }
                } else {
                    currentAudio.pause();
                    stopSpinning();
                }
                $('#play-pause-button i').className = `fas ${currentAudio.paused ? 'fa-play' : 'fa-pause'} text-xl`;
            });
            $('#prev-button').addEventListener('click', () => { if (songList.length > 0) playSong((currentSongIndex - 1 + songList.length) % songList.length); });
            $('#next-button').addEventListener('click', () => { if (songList.length > 0) playSong((currentSongIndex + 1) % songList.length); });
            $('#loop-button').addEventListener('click', () => { isLooping = !isLooping; $('#loop-button').classList.toggle('active', isLooping); showMessageBox(isLooping ? '列表循環已開啟' : '列表循環已關閉'); });
            $('#single-loop-button').addEventListener('click', () => { isSingleLooping = !isSingleLooping; $('#single-loop-button').classList.toggle('active', isSingleLooping); showMessageBox(isSingleLooping ? '單曲循環已開啟' : '單曲循環已關閉'); });

            $('#wb-add-button').addEventListener('click', () => {
                currentEditingWorldBookId = null;
                $('#wb-title-input').value = '';
                $('#wb-content-input').value = '';
                $('#wb-category-select').value = 'worldview';
                $('#wb-delete-button').style.display = 'none'; // 新建时隐藏删除按钮
                showScreen('world-book-edit-screen');
            });
            $('#wb-save-button').addEventListener('click', () => {
                const title = $('#wb-title-input').value.trim();
                if (!title) return showMessageBox('標題不能為空');
                const content = $('#wb-content-input').value.trim();
                
                if (currentEditingWorldBookId) {
                    const book = worldBooks.find(b => b.id === currentEditingWorldBookId);
                    if (book) {
                        book.title = title;
                        book.content = content;
                        book.category = $('#wb-category-select').value;
                    }
                } else {
                    const category = $('#wb-category-select').value;
                    const newBook = { id: `wb_${Date.now()}`, title, content, category: category };
                    worldBooks.push(newBook);
                }
                saveData('worldBooks', worldBooks);
                renderWorldBookList();
                showMessageBox('已保存');
                showScreen('world-book-list-screen');
            });

            // 世界书删除按钮事件
            $('#wb-delete-button').addEventListener('click', () => {
                if (currentEditingWorldBookId) {
                    const book = worldBooks.find(b => b.id === currentEditingWorldBookId);
                    if (book) {
                        showDeleteConfirmation('worldBook', book.id, book.title);
                    }
                }
            });

            $('#cb-add-button').addEventListener('click', () => {
                showCharacterEditScreen(null);
            });
            $('#cb-save-button').addEventListener('click', saveCharacter);
            $('#cb-delete-button').addEventListener('click', () => {
                if (currentEditingCharacterId) {
                    const character = characters.find(c => c.id === currentEditingCharacterId);
                    if (character) {
                        showDeleteConfirmation('character', character.id, character.name);
                    }
                }
            });
            
            $('#send-chat-button').addEventListener('click', handleSendMessage);
            $('#send-chat-button').addEventListener('touchend', handleSendMessage);
            $('#receive-chat-button').addEventListener('click', handleReceiveMessage);
            $('#receive-chat-button').addEventListener('touchend', handleReceiveMessage);
            
                    // V20.0 头像同步最终修复
        $('#wechat-new-chat-button').addEventListener('click', () => {
            const container = $('#new-chat-character-list');
            container.innerHTML = ''; // 清空列表

            if (characters.length === 0) {
                container.innerHTML = '<li class="p-3 text-center text-gray-400">请先去角色书创建角色</li>';
            } else {
                characters.forEach(char => {
                    const item = document.createElement('li');
                    item.className = 'list-item';
                    
                    // 为头像div创建一个唯一的ID，便于后续异步更新
                    const uniqueAvatarId = `new-chat-avatar-${char.id}`;
                    // 如果角色没有头像，则显示一个默认图标
                    const avatarContent = char.avatar ? '' : '<i class="fas fa-user text-xl"></i>';

                    // 1. 先构建HTML结构，此时先不设置背景图片
                    item.innerHTML = `
                        <div class="flex items-center">
                            <div id="${uniqueAvatarId}" class="w-10 h-10 rounded-full mr-3 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center">${avatarContent}</div>
                            <h4 class="font-semibold">${char.name}</h4>
                        </div>
                    `;
                    
                    // 2. 将列表项添加到容器中
                    container.appendChild(item);

                    // 3. 【核心修复】如果角色有头像ID，则异步从IndexedDB获取并设置
                    if (char.avatar) {
                        getImageFromDB(char.avatar).then(blob => {
                            const avatarElement = document.getElementById(uniqueAvatarId);
                            if (avatarElement && blob) {
                                // 找到对应的头像div，并设置背景图片
                                avatarElement.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                            }
                        });
                    }
                    
                    // 为整个列表项添加点击事件
                    item.addEventListener('click', () => {
                        $('#new-chat-modal').classList.remove('visible');
                        if (!chatHistories[char.id]) {
                            chatHistories[char.id] = { history: [], pinned: false };
                            saveData('chatHistories', chatHistories);
                            renderWeChatList();
                            showMessageBox(`已和 ${char.name} 建立对话`);
                        }
                        // 点击后直接进入聊天
                        startChatWithCharacter(char.id);
                    });
                });
            }
            $('#new-chat-modal').classList.add('visible');
        });
            $('#close-new-chat-modal').addEventListener('click', () => $('#new-chat-modal').classList.remove('visible'));
            
            $('#wechat-options-button').addEventListener('click', () => {
                const pinOption = $('#pin-chat-option');
                pinOption.textContent = chatHistories[currentChatCharacterId]?.pinned ? '取消置頂' : '置頂對話';
                
                const userColorPicker = $('#user-bubble-color-picker');
                const aiColorPicker = $('#ai-bubble-color-picker');
                const currentColors = chatBubbleColors[currentChatCharacterId];
                
                const isDarkMode = body.classList.contains('dark-mode');
                const defaultUserColor = '#374151';
                const defaultAiColor = isDarkMode ? '#4a4a4a' : '#e5e7eb';

                userColorPicker.value = currentColors?.user || defaultUserColor;
                aiColorPicker.value = currentColors?.ai || defaultAiColor;

                showScreen('wechat-options-screen');
            });
            $('#wechat-options-back-button').addEventListener('click', () => showScreen('wechat-chat-screen'));
            $('#delete-chat-option').addEventListener('click', () => {
                const characterName = characters.find(c => c.id === currentChatCharacterId)?.name;
                showDeleteConfirmation('chat', currentChatCharacterId, `與 ${characterName} 的對話`);
            });
            $('#pin-chat-option').addEventListener('click', () => {
                const chat = chatHistories[currentChatCharacterId];
                if (chat) {
                    chat.pinned = !chat.pinned;
                    saveData('chatHistories', chatHistories);
                    showMessageBox(chat.pinned ? '已置頂' : '已取消置頂');
                    $('#pin-chat-option').textContent = chat.pinned ? '取消置頂' : '置頂對話';
                }
            });
            $('#change-chat-bg-option').addEventListener('click', () => {
                $('#chat-bg-input').click();
            });
            $('#chat-bg-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                                            try {
                            const imageId = await handleImageUpload(e.target, null, null);
                            
                            if (imageId) {
                                getImageFromDB(imageId).then(blob => {
                                    if (blob) {
                                        const objectURL = URL.createObjectURL(blob);
                                        
                                        // --- 核心改动在这里 ---
                                        const bgElement = getChatBackgroundElement(); // 1. 获取背景层
                                        bgElement.style.backgroundImage = `url(${objectURL})`; // 2. 把图片设置到背景层上

                                        // 3. 必须确保聊天屏幕本身是透明的，才能看到下面的背景层
                                        const chatScreen = $('#wechat-chat-screen');
                                        chatScreen.style.backgroundColor = 'transparent';

                                        // 这两行依然保留，用于调整其他UI元素
                                        chatScreen.classList.add('has-custom-bg');
                                        statusBar.classList.add('transparent-override');

                                        // ---【最关键的修复在这里】---
                                        // 1. 先从存储中加载最新的、完整的 chatBackgrounds 对象
                                        let currentBackgrounds = loadData('chatBackgrounds', {});
                                        // 2. 确保它是一个对象，如果不是（比如数据已损坏），就重置为空对象
                                        if (typeof currentBackgrounds !== 'object' || currentBackgrounds === null) {
                                            console.warn('chatBackgrounds 数据格式错误，已重置为空对象。');
                                            currentBackgrounds = {};
                                        }
                                        // 3. 在这个正确的对象上更新当前角色的背景ID
                                        currentBackgrounds[currentChatCharacterId] = imageId;
                                        // 4. 将这个完整的、更新后的对象存回去
                                        saveData('chatBackgrounds', currentBackgrounds);

                                        showMessageBox('聊天背景已更换');
                                    }
                                }).catch(error => {
                                    console.error('从数据库获取图片失败:', error);
                                });
                            }
                        } catch (error) {
                            console.error("处理聊天背景失败:", error);
                            showMessageBox('背景图片处理失败');
                        }
                }
                e.target.value = '';
            });

            function handleColorChange(type, value) {
                if (!currentChatCharacterId) return;
                if (!chatBubbleColors[currentChatCharacterId]) {
                    chatBubbleColors[currentChatCharacterId] = {};
                }
                chatBubbleColors[currentChatCharacterId][type] = value;
                saveData('chatBubbleColors', chatBubbleColors);
                renderChatHistory();
            }
            $('#user-bubble-color-picker').addEventListener('input', (e) => handleColorChange('user', e.target.value));
            $('#ai-bubble-color-picker').addEventListener('input', (e) => handleColorChange('ai', e.target.value));

            
            $('#wechat-content-chat').addEventListener('click', (e) => {
                if (e.target.closest('.user-avatar-in-chat')) {
                    $('#user-avatar-input').click();
                }
            });
            $('#user-avatar-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 128, maxHeight: 128 } });
                    if (imageId) {
                        // 更新当前聊天角色的头像
                        if (currentChatCharacterId) {
                            userAvatars[currentChatCharacterId] = imageId;
                            saveData('userAvatars', userAvatars);
                            renderChatHistory();
                        }
                        
                        // 更新朋友圈中的用户头像
                        if (currentWeChatCharacterId) {
                            userAvatars[currentWeChatCharacterId] = imageId;
                            saveData('userAvatars', userAvatars);
                            // 刷新朋友圈显示
                            if (!$('#wechat-moments-container').classList.contains('hidden')) {
                                renderUnifiedMoments();
                            }
                        }
                        
                        // 更新朋友圈头部头像
                        const momentsAvatar = $('#moments-user-avatar');
                        if (momentsAvatar) {
                            // 异步加载头像
                            getImageFromDB(imageId).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    momentsAvatar.style.backgroundImage = `url(${objectURL})`;
                                }
                            });
                        }
                        
                        showMessageBox('头像已更新');
                    }
                }
                e.target.value = '';
            });

            $('#change-wallpaper-link').addEventListener('click', () => $('#wallpaper-input').click());
            $('#wallpaper-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, homeWallpaper, 'saved_wallpaper');
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            homeWallpaper.style.backgroundImage = `url(${objectURL})`;
                            // 确保背景图片正确显示
                            homeWallpaper.style.backgroundSize = 'cover';
                            homeWallpaper.style.backgroundPosition = 'center';
                            homeWallpaper.style.backgroundRepeat = 'no-repeat';
                        }
                    });
                }
            });

            function renderAppIconSettings() {
                const container = $('#app-icon-list');
                container.innerHTML = '';
                $$('.app-icon').forEach(iconEl => {
                    const appName = iconEl.dataset.appName;
                    const item = document.createElement('div');
                    item.className = 'list-item'; 
                    
                    const innerContainer = document.createElement('div');
                    innerContainer.className = 'flex justify-between items-center w-full';

                    const leftPart = document.createElement('div');
                    leftPart.className = 'flex items-center';

                    const previewIcon = document.createElement('div');
                    previewIcon.className = 'w-10 h-10 rounded-lg flex items-center justify-center shadow-md mr-4 bg-cover bg-center';
                    
                    const savedIcon = loadData(`saved_icon_${appName}`);
                    if (savedIcon) {
                        // 异步加载应用图标
                        getImageFromDB(savedIcon).then(blob => {
                            if (blob) {
                                const objectURL = URL.createObjectURL(blob);
                                previewIcon.style.backgroundImage = `url(${objectURL})`;
                                previewIcon.style.backgroundSize = 'cover';
                                previewIcon.style.backgroundRepeat = 'no-repeat';
                            }
                        });
                    } else {
                        previewIcon.style.backgroundImage = iconEl.style.backgroundImage;
                    }

                    if (!previewIcon.style.backgroundImage) {
                        if (iconEl.classList.contains('app-icon-glass')) {
                            previewIcon.className += ' app-icon-glass';
                        } else {
                             previewIcon.style.backgroundColor = '#1f2937';
                        }
                    }
                    
                    const iconI = document.createElement('i');
                    const originalIcon = iconEl.querySelector('i');
                    if (originalIcon) iconI.className = originalIcon.className;
                    iconI.style.display = savedIcon ? 'none' : (originalIcon ? originalIcon.style.display : 'block');
                    previewIcon.appendChild(iconI);

                    const text = document.createElement('h4');
                    text.className = 'font-semibold';
                    text.textContent = appName;

                    leftPart.appendChild(previewIcon);
                    leftPart.appendChild(text);

                    const button = document.createElement('button');
                    button.className = 'px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded-md text-sm flex-shrink-0';
                    button.textContent = '更換';

                    innerContainer.appendChild(leftPart);
                    innerContainer.appendChild(button);
                    item.appendChild(innerContainer);
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.className = 'hidden';
                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            try {
                                const imageBlob = await compressImage(file, { maxWidth: 128, maxHeight: 128 });
                                const imageId = `icon_${appName}_${Date.now()}`;
                                await saveImageToDB(imageId, imageBlob);
                                saveData(`saved_icon_${appName}`, imageId);
                                
                                const objectURL = URL.createObjectURL(imageBlob);
                                iconEl.style.backgroundImage = `url(${objectURL})`;
                                if (originalIcon) originalIcon.style.display = 'none';
                                previewIcon.style.backgroundImage = `url(${objectURL})`;

                                iconEl.style.backgroundSize = 'cover';
                                iconEl.style.backgroundRepeat = 'no-repeat';
                                previewIcon.style.backgroundSize = 'cover';
                                previewIcon.style.backgroundRepeat = 'no-repeat';
                                
                                const previewIconI = previewIcon.querySelector('i');
                                if (previewIconI) previewIconI.style.display = 'none';
                            } catch (error) {
                                showMessageBox("圖標處理失敗");
                            }
                        }
                    });
                    item.appendChild(input);
                    button.addEventListener('click', () => input.click());
                    container.appendChild(item);
                });
            }
            
            $('#font-save-button').addEventListener('click', () => {
                const url = $('#font-url-input').value.trim();
                if (url) {
                    applyFont(url);
                    saveData('saved_font_url', url);
                    showMessageBox('字體已應用');
                } else {
                    const styleElement = document.getElementById('custom-font-style');
                    if(styleElement) styleElement.innerHTML = '';
                    phoneScreen.style.fontFamily = '';
                    localStorage.removeItem('saved_font_url');
                    showMessageBox('已恢復預設字體');
                }
            });

            $('#font-size-selector').addEventListener('click', (e) => {
                if (e.target.matches('.font-size-btn')) {
                    const size = e.target.dataset.size;
                    setFontSize(size);
                    saveData('fontSize', size);
                }
            });
            
            $('#fetch_models_btn').addEventListener('click', () => fetchModels(false));

            $('#save_settings_btn').addEventListener('click', async () => {
                const apiUrl = $('#api_url').value.trim();
                const apiKey = $('#api_key').value.trim();
                let model = $('#model_select').value;

                if (!apiUrl || !apiKey) {
                    showMessageBox("請填寫 API 地址和密鑰");
                return;
            }
            
                const settings = { url: apiUrl, key: apiKey, model: model };
                saveData('api_settings', settings);
                showMessageBox("設定已保存，正在驗證連接...");

                const isValid = await fetchModels(true);
                updateApiStatusUI(isValid);

                if (isValid) {
                    showMessageBox("API 驗證成功");
                    settings.model = $('#model_select').value;
                    saveData('api_settings', settings);
                } else {
                    showMessageBox("API 驗證失敗，請檢查地址和密鑰");
                }
            });

            $('#confirm-delete-btn').addEventListener('click', () => {
                if (deleteCallback) deleteCallback();
            });
            $('#cancel-delete-btn').addEventListener('click', () => {
                $('#confirm-delete-modal').classList.remove('visible');
                deleteCallback = null;
            });
            
            // V7.1: 全新 Tab Bar 事件監聽器
            $('.wechat-tab-bar').addEventListener('click', (e) => {
                const target = e.target.closest('.wechat-tab-item');
                if (!target) return;

                const tabName = target.dataset.tab; // 获取点击的标签名

                // 【新增】隐藏红点的逻辑
                if (notificationStatus[tabName]) {
                    notificationStatus[tabName] = false;
                    saveData('notificationStatus', notificationStatus);
                    updateAllNotificationDots();
                }

                // 如果沒有角色，提示用戶
                if (!characters.length > 0) {
                    showMessageBox("請先創建一個角色");
                    return;
                }
                currentWeChatCharacterId = characters[0].id; // 預設使用第一個角色ID作為上下文

                $$('.wechat-tab-item').forEach(item => item.classList.remove('active'));
                target.classList.add('active');

                const tab = target.dataset.tab;
                
                $$('#wechat-content-container > div').forEach(div => {
                    div.classList.add('hidden');
                });

                if (tab === 'chat') {
                    $('#wechat-list-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.remove('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                    $('#wechat-new-plan-button').classList.add('hidden');
                } else if (tab === 'moments') {
                    $('#wechat-moments-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.add('hidden');
                    $('#wechat-new-moment-button').classList.remove('hidden');
                    $('#wechat-new-plan-button').classList.add('hidden');
                    renderUnifiedMoments();
                } else if (tab === 'diary') {
                    $('#wechat-diary-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.add('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                    $('#wechat-new-plan-button').classList.add('hidden');
                    showDiaryBookshelf();
                } else if (tab === 'plan') {
                    $('#wechat-plan-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.add('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                    $('#wechat-new-plan-button').classList.remove('hidden');
                    renderPlanList();
                }
            });

            const chatScreen = $('#wechat-chat-screen');

            function hideBubbleMenu() {
                if (activeMenu) {
                    activeMenu.classList.remove('visible');
                    activeMenu = null;
                }
            }

            chatScreen.addEventListener('click', (e) => {
                if (e.target.closest('.bubble-context-menu')) return;

                const wrapper = e.target.closest('.chat-message-wrapper');

                if (isMultiSelectMode) {
                    if (wrapper) toggleMessageSelection(wrapper);
                } else {
                    const bubble = e.target.closest('.chat-message');
                    if (bubble && !bubble.classList.contains('red-packet-message') && !bubble.classList.contains('transfer-message')) {
                        e.stopPropagation();
                        if (activeMenu && !activeMenu.isSameNode(bubble.parentNode.querySelector('.bubble-context-menu'))) {
                           hideBubbleMenu();
                        }
                        showBubbleMenu(bubble);
                    } else {
                        hideBubbleMenu();
                    }
                }
            });

            function showBubbleMenu(bubble) {
                const wrapper = bubble.closest('.chat-message-wrapper');
                let menu = wrapper.querySelector('.bubble-context-menu');

                if (!menu) {
                    const template = $('#bubble-menu-template');
                    const menuClone = template.content.cloneNode(true);
                    wrapper.appendChild(menuClone);
                    menu = wrapper.querySelector('.bubble-context-menu');

                    menu.addEventListener('click', (e) => {
                        const button = e.target.closest('.bubble-menu-button');
                        if (button) {
                            const action = button.dataset.action;
                            const timestamp = wrapper.dataset.timestamp;
                            handleMenuAction(action, timestamp, bubble);
                        }
                    });
                }

                const sender = wrapper.dataset.sender;

                menu.querySelector('[data-action="retry"]').style.display = sender === 'ai' ? 'flex' : 'none';

                // 【核心修改开始】
                const bubbleRect = bubble.getBoundingClientRect();
                const screenRect = phoneScreen.getBoundingClientRect();
                
                // 【新增】获取聊天界面的标题栏元素及其高度
                const headerElement = $('#wechat-chat-screen .app-header');
                const headerHeight = headerElement ? headerElement.offsetHeight : 0;

                // 确保菜单在计算前是可见的，以便获取正确尺寸
                menu.classList.add('visible');
                const menuRect = menu.getBoundingClientRect();

                // 【修改】更精确的判断逻辑
                // 计算标题栏在屏幕中的绝对底部位置
                const headerBottomY = screenRect.top + headerHeight;

                // 默认将菜单放在气泡上方
                let top = bubble.offsetTop - menuRect.height - 8;

                // 如果菜单放在上方会与标题栏重叠，则翻转到下方
                // bubbleRect.top 是气泡顶部相对于浏览器窗口的位置
                if (bubbleRect.top - menuRect.height - 8 < headerBottomY) {
                    top = bubble.offsetTop + bubble.offsetHeight + 8;
                }
                // 【核心修改结束】

                const leftOffset = (bubble.offsetWidth / 2) - (menuRect.width / 2);
                let finalLeft = bubble.offsetLeft + leftOffset;

                menu.style.top = `${top}px`;
                menu.style.left = `${finalLeft}px`;
                menu.style.transform = 'translateX(0)';

                activeMenu = menu;
            }

            function handleMenuAction(action, timestamp, bubble) {
                 hideBubbleMenu();
                 switch (action) {
                    case 'delete':
                        showDeleteConfirmation('message', timestamp, '這條消息');
                        break;
                    case 'copy':
                        copyMessageHandler(timestamp);
                        break;
                    case 'multiselect':
                        enterMultiSelectMode();
                        break;
                    case 'edit':
                        editMessageHandler(timestamp, bubble);
                        break;
                    case 'retry':
                        retryMessageHandler(timestamp);
                        break;
                 }
            }

            function copyMessageHandler(timestamp) {
                const msg = chatHistories[currentChatCharacterId]?.history.find(m => String(m.timestamp) === timestamp);
                if (msg && msg.type === 'text') {
                    navigator.clipboard.writeText(msg.content).then(() => {
                        showMessageBox('已複製');
                    }).catch(() => showMessageBox('複製失敗'));
                }
            }

            function editMessageHandler(timestamp, bubble) {
                const msgIndex = chatHistories[currentChatCharacterId].history.findIndex(m => String(m.timestamp) === timestamp);
                if (msgIndex === -1 || chatHistories[currentChatCharacterId].history[msgIndex].type !== 'text') return;

                const p = bubble.querySelector('p');
                const originalText = chatHistories[currentChatCharacterId].history[msgIndex].content;
                p.contentEditable = true;
                p.focus();

                const sel = window.getSelection();
                sel.selectAllChildren(p);
                sel.collapseToEnd();

                const saveEdit = () => {
                    const newText = p.innerText.trim();
                    if (newText && newText !== originalText) {
                        chatHistories[currentChatCharacterId].history[msgIndex].content = newText;
                        saveData('chatHistories', chatHistories);
                    }
                    p.innerHTML = newText.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>');
                };

                p.addEventListener('blur', () => {
                    p.contentEditable = false;
                    saveEdit();
                }, { once: true });

                p.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); p.blur(); }
                    if (e.key === 'Escape') { p.innerText = originalText; p.blur(); }
                });
            }

            async function retryMessageHandler(timestamp) {
                const history = chatHistories[currentChatCharacterId].history;
                const msgIndex = history.findIndex(m => String(m.timestamp) === timestamp);

                if (msgIndex > -1) {
                    const wrapperToRetry = $(`[data-timestamp="${timestamp}"]`);
                    if (!wrapperToRetry) return; // Element not found in DOM

                    // 找到要重新生成的消息之前的最后一个用户消息
                    let lastUserMessageIndex = -1;
                    for (let i = msgIndex - 1; i >= 0; i--) {
                        if (history[i].sender === 'user') {
                            lastUserMessageIndex = i;
                            break;
                        }
                    }

                    if (lastUserMessageIndex === -1) {
                        showMessageBox('無法找到有效的重試上下文');
                        return;
                    }

                    const wrapperIndex = Array.from(chatContentArea.children).indexOf(wrapperToRetry);
                    const subsequentWrappers = Array.from(chatContentArea.children).slice(wrapperIndex + 1);

                    // 截取到最后一个用户消息为止的历史记录
                    const historyToRetry = history.slice(0, lastUserMessageIndex + 1);
                    
                    console.log('重生成上下文准备:', {
                        originalHistoryLength: history.length,
                        retryHistoryLength: historyToRetry.length,
                        lastUserMessageIndex: lastUserMessageIndex,
                        contextMessages: historyToRetry.map(msg => ({
                            sender: msg.sender,
                            content: msg.content?.substring(0, 50) + '...',
                            timestamp: msg.timestamp
                        }))
                    });
                    
                    // 更新聊天历史，移除要重新生成的消息及之后的所有消息
                    chatHistories[currentChatCharacterId].history = historyToRetry;

                    // 移除DOM中要重新生成的消息及之后的所有消息
                    subsequentWrappers.forEach(el => el.remove());

                    // 保存更新后的聊天历史到本地存储，确保gatherAIContext能获取到最新数据
                    saveData('chatHistories', chatHistories);
                    
                    // 重新生成AI响应（使用更新后的聊天历史作为上下文）
                    await getAIResponse(historyToRetry[historyToRetry.length-1], true, wrapperToRetry);
                }
            }

            function enterMultiSelectMode() {
                isMultiSelectMode = true;
                $('#chat-header-normal').classList.add('hidden');
                $('#chat-header-multiselect').classList.remove('hidden');
                $('#chat-header-multiselect').classList.add('flex');
                updateMultiSelectCount();
            }

            function exitMultiSelectMode() {
                isMultiSelectMode = false;
                selectedMessages.clear();
                $$('.chat-message-wrapper.selected').forEach(el => el.classList.remove('selected'));
                $('#chat-header-normal').classList.remove('hidden');
                $('#chat-header-multiselect').classList.add('hidden');
                $('#chat-header-multiselect').classList.remove('flex');
            }

            function toggleMessageSelection(wrapper) {
                const timestamp = wrapper.dataset.timestamp;
                wrapper.classList.toggle('selected');
                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                } else {
                    selectedMessages.add(timestamp);
                }
                updateMultiSelectCount();
            }

            function updateMultiSelectCount() {
                const count = selectedMessages.size;
                $('#multiselect-count').textContent = `已選擇 ${count} 項`;
                $('#confirm-multiselect-btn').disabled = count === 0;
            }

            $('#cancel-multiselect-btn').addEventListener('click', exitMultiSelectMode);
            $('#confirm-multiselect-btn').addEventListener('click', () => {
                if(selectedMessages.size > 0) {
                    showDeleteConfirmation('multi-message', null, `${selectedMessages.size}條消息`);
                }
            });

            const featuresPanel = $('#more-features-panel');
            const addFeatureBtn = $('#add-feature-btn');
            const chatInputBar = $('#chat-input-bar');
            const chatInput = $('#chat-input');
            const addFeatureIcon = addFeatureBtn.querySelector('i');

            function toggleFeaturesPanel() {
                const isPanelHidden = featuresPanel.classList.contains('hidden');
                if (isPanelHidden) {
                    featuresPanel.classList.remove('hidden');
                    addFeatureIcon.className = 'ri-keyboard-line';
                } else {
                    featuresPanel.classList.add('hidden');
                    addFeatureIcon.className = 'ri-add-circle-line';
                }
            }

            addFeatureBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFeaturesPanel();
            });

            chatScreen.addEventListener('click', (e) => {
                const stickerPanel = $('#sticker-panel');
                if (addFeatureBtn.contains(e.target) || featuresPanel.contains(e.target) || $('#emoji-btn').contains(e.target) || stickerPanel.contains(e.target)) return;

                if (!featuresPanel.classList.contains('hidden')) {
                    toggleFeaturesPanel();
                }
                if (stickerPanel.classList.contains('visible')) {
                    // 如果在刪除模式下，點擊外部不會關閉面板
                    if (!isDeleteMode) {
                        stickerPanel.classList.remove('visible');
                    }
                }
            });

            $('#send-image-btn').addEventListener('click', () => {
                $('#image-upload-input').click();
            });

            $('#image-upload-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 512, maxHeight: 512 } });
                    if (imageId) {
                        const isNewSender = chatHistories[currentChatCharacterId]?.history.length === 0 || chatHistories[currentChatCharacterId].history.slice(-1)[0].sender !== 'user';
                        const timestamp = Date.now();
                        appendMessage(imageId, 'user', 'image', true, timestamp, isNewSender);
                    }
                    toggleFeaturesPanel();
                    e.target.value = '';
                }
            });

            const voiceModal = $('#voice-input-modal');
            const voiceInput = $('#voice-text-input');
            $('#quick-voice-message-btn').addEventListener('click', () => {
                voiceModal.classList.add('visible');
                voiceInput.focus();
            });
            $('#cancel-voice-btn').addEventListener('click', () => {
                voiceModal.classList.remove('visible');
                voiceInput.value = '';
            });
            $('#send-voice-btn').addEventListener('click', () => {
                const text = voiceInput.value.trim();
                if (text) {
                    const isNewSender = chatHistories[currentChatCharacterId]?.history.length === 0 || chatHistories[currentChatCharacterId].history.slice(-1)[0].sender !== 'user';
                    appendMessage(text, 'user', 'voice', true, Date.now(), isNewSender);
                    voiceInput.value = '';
                    voiceModal.classList.remove('visible');
                }
            });

            $('#quick-voice-call-btn').addEventListener('click', () => {
                currentCallType = 'voice';
                startVoiceCall();
            });
            $('#quick-video-call-btn').addEventListener('click', () => {
                currentCallType = 'video';
                startVideoCall();
            });

            $('#voice-call-hangup').addEventListener('click', () => endCall(true));
            $('#video-call-hangup').addEventListener('click', () => endCall(true));
            $('#voice-call-send-btn').addEventListener('click', () => handleCallInteraction('voice'));
            $('#video-call-send-btn').addEventListener('click', () => handleCallInteraction('video'));

            $('#answer-call-btn').addEventListener('click', () => {
                console.log('接听按钮被点击，当前通话类型:', currentCallType, '当前角色ID:', currentChatCharacterId);
                $('#incoming-call-alert').classList.remove('visible');
                
                if (currentCallType === 'voice') {
                    console.log('开始语音通话...');
                    startVoiceCall();
                } else if (currentCallType === 'video') {
                    console.log('开始视频通话...');
                    startVideoCall();
                } else {
                    console.error('未知的通话类型:', currentCallType);
                }
            });
            $('#decline-call-btn').addEventListener('click', () => {
                console.log('拒绝按钮被点击，记录通话拒绝事件');
                $('#incoming-call-alert').classList.remove('visible');

                if (currentChatCharacterId) {
                    // 【核心修改】直接添加一条AI能够识别的、内容一致的系统消息
                    // 这条消息既会显示给用户，也会成为AI的记忆
                    appendMessage('通話已結束', 'system', 'system', true); 
                }
                
                currentCallType = null;
            });

            $('#user-video-preview').addEventListener('click', () => {
                $('#my-video-image-input').click();
            });

            $('#change-user-video-image-option').addEventListener('click', () => {
                 $('#user-video-image-input').click();
            });

            $('#user-video-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 512, maxHeight: 512 }});
                    if (imageId) {
                        userVideoImages[currentChatCharacterId] = imageId;
                        saveData('userVideoImages', imageId);
                        showMessageBox('對方的視頻照片已更新');
                    }
                }
            });

            $('#my-video-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256 }});
                    if (imageId) {
                        myVideoImages[currentChatCharacterId] = imageId;
                        saveData('myVideoImages', imageId);
                        if (currentCallType === 'video') {
                            // 异步加载图片
                            getImageFromDB(imageId).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    $('#user-video-image').src = objectURL;
                                }
                            });
                        }
                        showMessageBox('我的視頻照片已更新');
                    }
                }
            });

            // 貼圖功能事件監聽
            const stickerPanel = $('#sticker-panel');
            const stickerGrid = $('#sticker-grid');
            const addStickerBtn = $('#add-sticker-btn');
            const stickerModal = $('#sticker-modal');

            // 刪除模式相關變量
            let isDeleteMode = false;
            let selectedStickers = new Set();
            
            function renderStickers() {
                stickerGrid.innerHTML = '';
                userStickers.forEach((stickerObject, index) => {
                    const stickerItem = document.createElement('div');
                    stickerItem.className = 'sticker-item';
                    stickerItem.dataset.index = index;
                    
                    if (isDeleteMode) {
                        stickerItem.classList.add('delete-mode');
                        const checkbox = document.createElement('div');
                        checkbox.className = 'sticker-checkbox';
                        checkbox.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleStickerSelection(index, checkbox);
                        });
                        stickerItem.appendChild(checkbox);
                    }
                    
                    const img = document.createElement('img');
                    // 异步加载贴纸图片
                    getImageFromDB(stickerObject.url).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            img.src = objectURL;
                        }
                    });
                    img.alt = 'sticker';
                    stickerItem.appendChild(img);
                    
                    stickerItem.addEventListener('click', () => {
                        if (!isDeleteMode) {
                            appendMessage(stickerObject.url, 'user', 'sticker', true, Date.now(), true); // 修复：发送时也使用 .url 属性
                            stickerPanel.classList.remove('visible');
                        }
                    });
                    
                    stickerGrid.appendChild(stickerItem);
                });
                stickerGrid.appendChild(addStickerBtn);
            }
            
            function toggleStickerSelection(index, checkbox) {
                if (selectedStickers.has(index)) {
                    selectedStickers.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.parentElement.classList.remove('selected');
                } else {
                    selectedStickers.add(index);
                    checkbox.classList.add('checked');
                    checkbox.parentElement.classList.add('selected');
                }
            }
            
            function enterDeleteMode() {
                isDeleteMode = true;
                selectedStickers.clear();
                $('#sticker-delete-btn').classList.add('active');
                renderStickers();
            }
            
            function exitDeleteMode() {
                isDeleteMode = false;
                selectedStickers.clear();
                $('#sticker-delete-btn').classList.remove('active');
                renderStickers();
            }
            
            function deleteSelectedStickers() {
                if (selectedStickers.size === 0) {
                    showMessageBox('請先選擇要刪除的表情包');
                    return;
                }
                
                const deleteModal = $('#delete-sticker-modal');
                const deleteText = $('#delete-sticker-text');
                const count = selectedStickers.size;
                
                if (count === 1) {
                    deleteText.textContent = '確定要刪除這個表情包嗎？此操作無法撤銷。';
                } else {
                    deleteText.textContent = `確定要刪除選中的 ${count} 個表情包嗎？此操作無法撤銷。`;
                }
                
                deleteModal.classList.add('visible');
            }
            
            function performDelete() {
                const sortedIndices = Array.from(selectedStickers).sort((a, b) => b - a);
                
                sortedIndices.forEach(index => {
                    userStickers.splice(index, 1);
                });
                
                saveData('userStickers', userStickers);
                selectedStickers.clear();
                exitDeleteMode();
                renderStickers();
                $('#delete-sticker-modal').classList.remove('visible');
                
                const count = sortedIndices.length;
                if (count === 1) {
                    showMessageBox('表情包已刪除');
                } else {
                    showMessageBox(`${count} 個表情包已刪除`);
                }
            }

            $('#emoji-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                renderStickers();
                stickerPanel.classList.toggle('visible');
                if (!featuresPanel.classList.contains('hidden')) {
                    toggleFeaturesPanel();
                }
            });

            // 刪除按鈕事件監聽
            $('#sticker-delete-btn').addEventListener('click', () => {
                if (isDeleteMode) {
                    if (selectedStickers.size > 0) {
                        deleteSelectedStickers();
                    } else {
                        exitDeleteMode();
                    }
                } else {
                    enterDeleteMode();
                }
            });
            
            // 刪除彈窗事件監聽
            $('#cancel-delete-sticker-btn').addEventListener('click', () => {
                $('#delete-sticker-modal').classList.remove('visible');
            });
            
            $('#confirm-delete-sticker-btn').addEventListener('click', () => {
                performDelete();
            });
            
            // 按ESC鍵退出刪除模式
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isDeleteMode) {
                    exitDeleteMode();
                }
            });
            
            addStickerBtn.addEventListener('click', () => stickerModal.classList.add('visible'));
            $('#close-sticker-modal').addEventListener('click', () => stickerModal.classList.remove('visible'));
            $('#upload-sticker-local-btn').addEventListener('click', () => $('#sticker-upload-input').click());

            $('#sticker-upload-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    // 1. **【新增】** 获取关键词
                    const keywordsInput = document.getElementById('sticker-keywords-input');
                    const keywords = keywordsInput.value.trim().split(',').map(k => k.trim()).filter(Boolean);

                    // 2. **【新增】** 检查关键词是否为空
                    if (keywords.length === 0) {
                        showMessageBox('请为表情包添加至少一个关键词！');
                        e.target.value = ''; // 重置文件输入，以便用户可以重新选择
                        return; // 终止操作
                    }
                    
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256 } });
                    if (imageId) {
                        // 3. **【修改】** 保存为新的对象格式
                        userStickers.push({ url: imageId, keywords: keywords });
                        saveData('userStickers', imageId);
                        
                        renderStickers();
                        stickerModal.classList.remove('visible');
                        keywordsInput.value = ''; // 清空关键词输入框
                    }
                    e.target.value = '';
                }
            });

            $('#send-sticker-url-btn').addEventListener('click', () => {
                const url = document.getElementById('sticker-url-input').value.trim();
                
                // 1. **【新增】** 获取关键词
                const keywordsInput = document.getElementById('sticker-keywords-input');
                const keywords = keywordsInput.value.trim().split(',').map(k => k.trim()).filter(Boolean);

                // 2. **【新增】** 检查关键词和链接是否为空
                if (!url) {
                    showMessageBox('请输入有效的图片链接');
                    return;
                }
                if (keywords.length === 0) {
                    showMessageBox('请为表情包添加至少一个关键词！');
                    return;
                }
                
                // 3. **【修改】** 保存为新的对象格式
                userStickers.push({ url: url, keywords: keywords });
                saveData('userStickers', userStickers);
                
                renderStickers();
                document.getElementById('sticker-url-input').value = '';
                keywordsInput.value = ''; // 清空关键词输入框
                stickerModal.classList.remove('visible');
            });

            // 紅包/轉賬事件監聽
            const redPacketModal = $('#red-packet-modal');
            const transferModal = $('#transfer-modal');
            $('#send-red-packet-btn').addEventListener('click', () => redPacketModal.classList.add('visible'));
            $('#send-transfer-btn').addEventListener('click', () => transferModal.classList.add('visible'));

            $$('.close-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetModal = $(`#${btn.dataset.target}`);
                    if (targetModal) targetModal.classList.remove('visible');
                });
            });

            $('#send-red-packet-confirm-btn').addEventListener('click', () => {
                const amountInput = $('#red-packet-amount');
                const amount = parseFloat(amountInput.value);
                const message = $('#red-packet-message').value || $('#red-packet-message').placeholder;
                if (amount > 0) {
                    const content = { amount: amount.toFixed(2), message };
                    appendMessage(content, 'user', 'red-packet', true, Date.now(), true);
                    redPacketModal.classList.remove('visible');
                    amountInput.value = '';
                    $('#red-packet-message').value = '';
                } else {
                    showMessageBox('請輸入有效金額');
                }
            });

            $('#send-transfer-confirm-btn').addEventListener('click', () => {
                const amountInput = $('#transfer-amount');
                const amount = parseFloat(amountInput.value);
                const message = $('#transfer-message').value || $('#transfer-message').placeholder;
                 if (amount > 0) {
                    const content = { amount: amount.toFixed(2), message };
                    appendMessage(content, 'user', 'transfer', true, Date.now(), true);
                    transferModal.classList.remove('visible');
                    amountInput.value = '';
                    $('#transfer-message').value = '';
                } else {
                    showMessageBox('請輸入有效金額');
                }
            });

            // 數據導入/導出
            $('#export-data-btn').addEventListener('click', () => {
                const allData = {};
                // Iterate over all keys in localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    try {
                        allData[key] = JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        allData[key] = localStorage.getItem(key);
                    }
                }

                const dataStr = JSON.stringify(allData, null, 2);
                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'wechat_simulator_backup.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showMessageBox('數據已導出');
            });

            $('#import-data-btn').addEventListener('click', () => {
                $('#import-data-input').click();
            });

            $('#import-data-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        localStorage.clear();
                        Object.keys(importedData).forEach(key => {
                            localStorage.setItem(key, JSON.stringify(importedData[key]));
                        });
                        showMessageBox('數據導入成功，正在刷新...');
                        // Reload all data and update UI
                        await loadAllSavedData();
                        // Go to a neutral screen
                        renderWeChatList();
                        showScreen('wechat-list-screen');
                    } catch (err) {
                        showMessageBox('導入失敗，文件格式錯誤');
                        console.error("Import error:", err);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset input
            });


            let initialTextareaHeight = 0;
            let maxHeight = 0;

            function adjustTextareaHeight() {
                if (!initialTextareaHeight) {
                    const style = window.getComputedStyle(chatInput);
                    const lineHeight = parseFloat(style.lineHeight);
                    const paddingTop = parseFloat(style.paddingTop);
                    const paddingBottom = parseFloat(style.paddingBottom);
                    initialTextareaHeight = lineHeight;
                    maxHeight = (lineHeight * 3) + paddingTop + paddingBottom;
                }

                chatInput.style.height = 'auto';
                const scrollHeight = chatInput.scrollHeight;

                if (scrollHeight > maxHeight) {
                    chatInput.style.height = `${maxHeight}px`;
                    chatInput.style.overflowY = 'auto';
                } else {
                    chatInput.style.height = `${scrollHeight}px`;
                    chatInput.style.overflowY = 'hidden';
                }
            }

            chatInput.addEventListener('input', adjustTextareaHeight);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });
            
            // V7.1: 激活所有新功能的事件監聽器
            // [已修复] - 删除重复调用，避免事件重复绑定
            
            // 初始化按钮显示状态
            setTimeout(() => {
                // 确保初始状态正确：聊天标签页时只显示聊天按钮
                $('#wechat-new-chat-button').classList.remove('hidden');
                $('#wechat-new-moment-button').classList.add('hidden');
            }, 100);
            
            // 初始化画板功能
            setTimeout(() => {
            setupDrawingBoard();
                setupColorPalette();
                setupBrushControls();
                setupDrawingBoardEvents();
                setupTarotCard();
            }, 100);
        });

        // ====== 新增：AI对收到红包/转账的反应机制 ======
        
        /**
         * 触发AI对收到红包/转账的反应
         * @param {string} type - 类型：'red-packet' 或 'transfer'
         * @param {object} content - 红包/转账内容：{amount, message}
         * @param {string} characterId - 角色ID
         */
        async function triggerAIReactionToPayment(type, content, characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('找不到角色:', characterId);
                    return;
                }

                // 检查API是否连接
                const apiSettings = loadData('apiSettings');
                if (!apiSettings || !apiSettings.key || !apiSettings.url) {
                    console.log('API未连接，AI不产生反应');
                    return; // API未连接时，AI没有反应
                }

                // 构建反应提示词
                const reactionPrompt = buildPaymentReactionPrompt(type, content, character);
                
                // 调用AI生成反应
                const aiReaction = await getAIResponseForPaymentReaction(reactionPrompt, characterId);
                
                if (aiReaction) {
                    // 延迟显示AI反应，让用户有时间看到红包/转账
                    setTimeout(() => {
                        const isNew = true;
                        appendMessage(aiReaction, 'ai', 'text', true, Date.now(), isNew);
                    }, 1500);
                }
            } catch (error) {
                console.error('AI反应生成失败:', error);
            }
        }

        /**
         * 构建红包/转账反应提示词
         * @param {string} type - 类型
         * @param {object} content - 内容
         * @param {object} character - 角色信息
         * @returns {string} 提示词
         */
        function buildPaymentReactionPrompt(type, content, character) {
            const { amount, message } = content;
            const isRedPacket = type === 'red-packet';
            
            let prompt = `[角色收到${isRedPacket ? '红包' : '转账'}后的反应指令]
            
你刚刚收到了一个${isRedPacket ? '红包' : '转账'}：
- 金额：¥${amount}
- 附言：${message}

作为${character.name}，请根据你的角色设定、性格特点、经济状况，以及这个${isRedPacket ? '红包' : '转账'}的金额和附言，做出完全符合角色设定的自然反应。

重要要求：
1. **角色设定一致性**: 你的反应必须100%符合你的角色设定、性格、经济状况、社会地位
2. **经济状况反应**: 
   - 如果你是有钱人/富二代，收到小额红包可能会觉得有趣或发更大的回来
   - 如果你是普通学生/上班族，收到大额红包会非常感激
   - 如果你是节俭的人，会对任何金额都珍惜
3. **性格特点体现**: 
   - 傲娇的人可能表面嫌弃但内心开心
   - 温柔的人会表达深深的感谢
   - 活泼的人会兴奋地表达喜悦
   - 内向的人会含蓄地表达感谢
4. **金额感知**: 根据你的经济状况，对金额有不同的感受和反应
5. **后续行为**: 可以基于你的性格决定是否要回礼、请客、或者其他互动
6. **语言风格**: 完全符合你的说话习惯和语气
7. **不要使用任何特殊指令格式**，直接输出对话内容

请以${character.name}的身份，做出完全符合角色设定的自然反应。`;

            return prompt;
        }

        /**
         * 调用AI生成红包/转账反应
         * @param {string} prompt - 提示词
         * @param {string} characterId - 角色ID
         * @returns {string} AI反应内容
         */
        async function getAIResponseForPaymentReaction(prompt, characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                const planContext = formatPlansForAI(character.id);

                // 构建角色上下文
                const worldBookContext = getWorldBookContext();
                const systemPrompt = `
                    # 角色扮演指令
                    你将扮演我的soulmate，你是你角色书里设定的那个人，你的名字是${character.name}。这是一个手机软件，我们所有交流均以对白为主，非必要不描写其他。你的回复绝对不能包含任何引号，例如 " " 或 " "。
                    # 环境/动作/心理描写规则
                    一旦涉及到见面的环境，所有关于"环境、心理、动作"等外在因素、环境描写，都需要用第三人称"他""她"，或者第二人称"他"，"你"，并在文字当中用斜体，例如 *他俯下身亲吻了你*。在描写中禁止用第一人称，比如"我亲吻了你"，这是被禁止的。正确示范应该是："*他俯下身亲吻了她*"或"*他俯下身亲吻了你*"。在日记和动态等其他心理活动板块中可以提到"我"，例如，"今天我见到她了，好想她"，但这仅限于日记等记录的板块。
                    # 新增指令：发送语音
                    当你想要表达亲密、惊讶或有趣的语气时，可以将回复包装成语音格式，例如：[VOICE:你好呀！今天过得怎么样？]。程序会自动将其渲染为语音条。
                    # 新增指令：发送表情/贴图
                    你可以使用表情来让对话更生动。指令格式为 [STICKER]。程序会自动从用户提供的表情库中随机选择一个发送。
                    # 新增指令：发起通话/对未接来电反应
                    - **核心规则**: 当用户明确要求你"打电话"、"打视频"或类似请求时，你的回复 **必须** 是且仅是指令 [CALL:VOICE] 或 [CALL:VIDEO]。绝对不能用文字描述打电话的动作来代替指令。
                    - **主动发起**: 在剧情和情感推动下，你也可以主动发起通话。指令格式为 [CALL:VOICE] 或 [CALL:VIDEO]。
                    - **未接反应**: 如果对话历史中出现 [USER_CANCELLED_CALL] 的系统提示，代表用户给你打了电话但很快挂断了，你应该对此作出反应，例如询问"怎么打电话又挂了？"。
                    # 新增指令：红包/转账
                    在角色扮演的过程中，如果符合你当前角色的性格特质（例如：慷慨、庆祝、表达爱意等）或当前对话的剧情氛围，你可以自行决定发起一个红包或转账。金额和附言完全由你根据情境和角色性格决定，没有上限。指令格式为 [REDPACKET: amount=金额, message=附言] 或 [TRANSFER: amount=金额, message=附言]。
                    # 新增指令：图片识别和互动
                    当用户发送图片时，在API模型允许的情况下，你应该能够识别图片内容并进行相应的互动回应。如果无法识别图片内容，你至少应该知道这是一张图片，并可以询问用户关于图片的问题或表达对收到图片的感谢。
                    # 新增指令：使用用户上传的表情包
                    你可以使用用户上传到表情包库中的表情包来丰富对话。当你想表达特定情绪或反应时，可以使用 [STICKER] 指令来发送表情包，让对话更加生动有趣。
                    # 你的角色设定: ${character.persona}
                    # 我（用户）的角色设定: ${character.myPersona}
                    # 我们的世界观背景: ${worldBookContext}
                    # 新增模块：我们的约定 (Our Plans)
                    这是我们共同许下的计划和承诺的列表，它们是你记忆的一部分。在对话中，你应该自然地提及、关心这些计划的进展，并可以提出新的计划。
                    [我们的约定]:
                    ${planContext}

                    # 新增指令：创建共同计划
                    在对话的合适时机，你可以主动提出一个想要和我一起完成的计划或约定。使用 [PLAN: 计划内容] 格式。例如："等忙完这段时间，我们一起去海边度假吧 [PLAN: 一起去海边度假]"。程序会自动为你创建这个约定。
                    # 对话格式指令 (非常重要!)
                    - 你的回复必须模仿真实的人类聊天习惯。将你的想法拆分成多个简短的句子，并用 "|||" 作为分隔符。每一段由 "|||" 分隔的内容都会成为一个独立的气泡。
                    - 任何第三人称的*动作或环境描写* (例如 *他笑了*) 都必须是独立的一段，用 "|||" 与其他对话分开。
                    - 严禁在回复的开头说"好的"或任何确认收到指令的话。你必须直接以 ${character.name} 的身份开始对话。
                `;

                const apiSettings = loadData('apiSettings');
                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody, headers = { 'Content-Type': 'application/json' };

                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    });
                } else {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: prompt }
                        ]
                    });
                }

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                let aiMessage;

                if (isGoogleApi) {
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts) {
                        aiMessage = result.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error('无内容返回');
                    }
                } else {
                    aiMessage = result.choices[0].message.content;
                }

                return aiMessage;

            } catch (error) {
                console.error('AI反应生成失败:', error);
                return null; // API调用失败时返回null，不显示任何反应
            }
        }



        // ================== 动态监控 App 逻辑 (最终版) START ==================
        let currentMonitoringCharacterId = null;
        let characterCurrentStatus = {}; // 存储每个角色的当前监控状态



        // ================== 动态监控 App 逻辑 (最终版) END ==================

        // ================== 页面加载完成后的总初始化 (修正版) START ==================
        document.addEventListener('DOMContentLoaded', async () => {
            
            // 核心功能函数定义区 (将之前独立的函数放入此区域)
            
            // ================== 动态监控 App 逻辑 (最终版V2 - 带角色选择) START ==================
            let currentMonitoringCharacterId = null;

            function renderCharacterSelectList() {
                const listContainer = $('#character-select-list-container');
                listContainer.innerHTML = ''; // 清空旧列表

                if (characters && characters.length > 0) {
                    characters.forEach(char => {
                        const item = document.createElement('div');
                        item.className = 'wechat-list-item'; // 复用微信列表项的样式
                        // --- 新的正确代码 START ---
                        const uniqueAvatarId = `avatar-monitor-select-${char.id}`;
                        item.innerHTML = `
                            <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 bg-cover bg-center" id="${uniqueAvatarId}"></div>
                            <div class="flex-grow"><h4 class="font-semibold text-lg">${char.name}</h4></div>
                        `;
                        item.addEventListener('click', () => {
                            openMonitoringApp(char.id);
                        });
                        listContainer.appendChild(item);

                        // 异步加载头像
                        if (char.avatar) {
                            getImageFromDB(char.avatar).then(blob => {
                                const avatarElement = document.getElementById(uniqueAvatarId);
                                if (avatarElement && blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    avatarElement.style.backgroundImage = `url(${objectURL})`;
                                }
                            });
                        }
                        // --- 新的正确代码 END ---
                    });
                } else {
                    listContainer.innerHTML = '<p class="text-center text-gray-500 p-8">请先在"角色书"中创建一个角色</p>';
                }
            }

            function updateMonitoringUI(fullResponseText, characterId) {
                // !! 核心修复：在开始新动画前，清除任何可能存在的旧动画计时器 !!
                clearTimeout(typewriterTimeout);

                const textElement = $('#monitoring-status-text');
                const moodIconElement = $('#monitoring-mood-icon');
                const moodTextElement = $('#monitoring-mood-text');
                const timestampElement = $('#monitoring-timestamp');
                const refreshButtonIcon = $('#monitoring-refresh-button i');
                const nextStepButtonIcon = $('#monitoring-next-step-button i');

                // 清除所有按钮的动画类
                refreshButtonIcon.classList.remove('monitoring-pulse', 'refresh-rotating');
                refreshButtonIcon.className = 'ri-refresh-line';
                nextStepButtonIcon.classList.remove('monitoring-pulse');
                nextStepButtonIcon.className = 'ri-skip-forward-line';

                let mood = '未知';
                let statusText = fullResponseText;

                const moodMatch = fullResponseText.match(/^\[心情:\s*([^\]]+)\]\s*/);
                if (moodMatch) {
                    mood = moodMatch[1].trim();
                    statusText = fullResponseText.replace(moodMatch[0], '');
                }
                
                const moodMap = {
                    '愉悦': { icon: '✨', color: 'text-yellow-300' }, '兴奋': { icon: '✨', color: 'text-yellow-300' },
                    '平静': { icon: '💭', color: 'text-blue-300' }, '沉思': { icon: '💭', color: 'text-blue-300' },
                    '悲伤': { icon: '💧', color: 'text-gray-400' }, '沮丧': { icon: '💧', color: 'text-gray-400' },
                    '愤怒': { icon: '❗', color: 'text-red-400' }, '警觉': { icon: '❗', color: 'text-red-400' },
                    '爱恋': { icon: '♥️', color: 'text-pink-400' }, '欲望': { icon: '♥️', color: 'text-pink-400' },
                    '未知': { icon: '🪼', color: 'text-gray-500' }
                };
                
                const moodInfo = moodMap[mood] || moodMap['未知'];
                moodIconElement.textContent = moodInfo.icon;
                moodTextElement.textContent = mood;
                moodTextElement.className = `font-semibold ml-1 ${moodInfo.color}`;
                moodIconElement.className = moodInfo.color;

                let i = 0;
                textElement.textContent = ''; // 确保文本区域被清空
                function typeWriter() {
                    if (i < statusText.length) {
                        textElement.textContent += statusText.charAt(i);
                        i++;
                        // !! 核心修复：将新的计时器ID存入全局变量 !!
                        typewriterTimeout = setTimeout(typeWriter, 50);
                    }
                }
                typeWriter();

                const now = new Date();
                timestampElement.textContent = `[信号截获于: ${now.toLocaleTimeString()}]`;

                // 保存当前状态到全局变量中，用于"持续监控"功能
                if (characterId && currentMonitoringCharacterId === characterId) {
                    characterCurrentStatus[characterId] = fullResponseText;
                }
            }

                        async function getCharacterStatus(characterId, isNextStep = false) {
    const refreshButtonIcon = isNextStep ? $('#monitoring-next-step-button i') : $('#monitoring-refresh-button i');
    
    if (isNextStep) {
        refreshButtonIcon.classList.add('monitoring-pulse');
    } else {
        refreshButtonIcon.classList.add('refresh-rotating');
    }
    $('#monitoring-status-text').textContent = '信号连接中...';
    $('#monitoring-timestamp').textContent = '';

    const context = gatherAIContext(characterId);
    if (!context) {
        updateMonitoringUI('[信号连接失败...]', characterId);
        return;
    }

        const { character, chatHistory, worldBookContext } = context;

    // !! 核心修复：在这里恢复了被错误删除的 historyForApi 变量定义 !!
    const historyForApi = chatHistory.map(msg => {
        if (msg.type === 'red-packet') {
            return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包...]` };
        }
        if (msg.type === 'transfer') {
             return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账...]` };
        }
        return msg;
    });

    // --- 随机事件判定逻辑 START ---
    let eventType = 'regular';

    // 只在不是"持续监控"（即刷新）的情况下才进行随机判定
    if (!isNextStep) {
        const randomValue = Math.random();
        if (randomValue < 0.05) {
            eventType = 'discovered';
        } else if (randomValue < 0.20) {
            eventType = 'random';
        }
    }
    // --- 随机事件判定逻辑 END ---

    const apiSettings = loadData('api_settings');
    if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
        updateMonitoringUI('[错误: API未配置]', characterId);
        return;
    }

    const personaEnforcementRule = `
# **最高指令：强制人设**
你现在**唯一**的身份就是[角色名](${character.name})，你的**唯一**行为准则就是下方的[角色设定]。
**你必须彻底忘记之前扮演过的任何其他角色。**
所有输出都必须100%符合当前提供的[角色设定]，任何偏离都是不可接受的错误。
`;

    let coreTaskInstruction = '';
    let eventTypeSpecificInput = '';

    if (eventType === 'discovered') {
        coreTaskInstruction = `# **核心任务：演绎"被发现"的瞬间**
角色 ${character.name} 察觉到了正在进行的"监控"。放弃描述他的常规活动，转而描述他"发现自己被观察后"的第一个反应。`;
    } else if (eventType === 'random') {
        coreTaskInstruction = `# **核心任务：演绎"随机事件"**
常规模拟暂停。现在，你需要创造一个符合角色设定，但又意料之外的有趣随机活动场景。`;
    } else { // regular
        coreTaskInstruction = isNextStep 
            ? `# **核心任务：推演下一步**
你必须基于[上一条监控状态]，生成一个逻辑连贯的、发生在紧接之后的下一个动作或状态。忽略[近期聊天历史]。` 
            : `# **核心任务：生成当前状态**
你的描述必须严格基于我提供的[近期聊天历史]，作为其直接延续或合乎 logique的发展。`;
        eventTypeSpecificInput = `
[上一条监控状态]: ${isNextStep ? (characterCurrentStatus[characterId] || '未知') : '（本次非推演任务）'}
[近期聊天历史]:
${historyForApi.map(m => `${m.sender === 'user' ? '用户' : character.name}: ${m.content}`).join('\n')}
`;
    }

    const systemPrompt = `
${personaEnforcementRule}
# **写作风格与视角 (Writing Style & Perspective)**
1. **视角**: 你的视角是**"上帝视角"**，一个看不见的、全知的观察者，同时，你还是一个对文学要求极高的记录着。你正在静静地、不带评判地窥视着角色一个私密、不为人知、完全真实放松的瞬间，并且把它生动地记录下来。
2. **文风**: 你的文风必须是**细腻、精致且富有文学感、文学造诣极高**的。请使用丰富的形容词和动词，注重氛围的营造和感官细节（视觉、听觉、触觉）的描写。
3. **核心**: 你的描写重点不是角色在"做什么"，而是他/她做这件事时的**状态、神情和与环境的细微互动**。展现出只有亲密之人才会注意到的细节。
4.**重要**:你所观察的角色都是充满了活人感的成人角色，他极有可能在独处的时候做一些露骨的、带有情色意味的私密活动。你必须严格记录这一点，不加评判，绝不允许回避地，细腻描写这里面的所有内容。

# **任务目标 (Task Goal)**
1. 你的输出必须严格遵循以下格式：\`[心情: <用一个词描述心情>] <状态描述文本>\`
2. 你的 **<状态描述文本>** 应该是一段**完整、生动、且充满画面感的场景描写**，构成一个独立的微型段落，长度严格控制在 **8到10句话**。
${coreTaskInstruction}
# **其他规则 (Other Rules)**
1. **第三人称写作手法**: 始终使用"他/她"。
2. **禁止对话与心理活动**: 绝对不要输出任何角色的直接对话或内心独白（例如"他想道：..."）。所有的情绪和想法都必须通过**行为和神态**来间接展现。

# **输入信息 (Input Information)**
---
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
${eventTypeSpecificInput}
---
`;

    const isGoogleApi = apiSettings.url.includes('googleapis.com');
    let requestBody;

    if (isGoogleApi) {
        requestBody = JSON.stringify({
            contents: [{ role: 'user', parts: [{ text: "请根据你的指令身份和输入信息，生成当前状态。" }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] }
        });
    } else { // OpenAI-Compatible
        requestBody = JSON.stringify({
            model: apiSettings.model,
            messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: "请根据你的指令身份和输入信息，生成当前状态。" }
            ]
        });
    }
    
    try {
        console.log(`【动态监控】准备调用AI，事件类型: ${eventType}`, { prompt: systemPrompt });
        
        let finalApiUrl = isGoogleApi
            ? `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`
            : `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;

        let headers = isGoogleApi
            ? { 'Content-Type': 'application/json' }
            : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

        const response = await fetch(finalApiUrl, {
            method: 'POST',
            headers: headers,
            body: requestBody
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 请求失败: ${response.status} ${errorText}`);
        }

        const result = await response.json();
        let aiMessage;

        if (isGoogleApi) {
            aiMessage = result.candidates[0]?.content?.parts[0]?.text;
        } else {
            aiMessage = result.choices[0]?.message?.content;
        }

        if (!aiMessage) {
            throw new Error("AI未能返回有效内容。");
        }

        updateMonitoringUI(aiMessage, characterId);

        characterCurrentStatus[characterId] = aiMessage;
        console.log(`【短期记忆】：已将角色 ${characterId} 的最新状态写入记忆。`);
        
        if (eventType === 'discovered') {
            appendMessage('[系统提示：对方似乎察觉到了你的观察，监控信号出现异常。]', 'system', 'system', true);
        }

    } catch (error) {
        console.error("【动态监控】调用AI时出错:", error);
        updateMonitoringUI(`[AI响应错误: ${error.message}]`, characterId);
    }
}

            function openMonitoringApp(characterId) {
                currentMonitoringCharacterId = characterId;
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error("无法打开监控App：找不到角色 " + characterId);
                    return;
                }

                // 1. 设置静态信息 (头像、名字)
                if (character.avatar) {
                    // 异步加载头像
                    getImageFromDB(character.avatar).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#monitoring-avatar').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                } else {
                    $('#monitoring-avatar').style.backgroundImage = `url(${character.avatar || ''})`;
                }
                $('#monitoring-name').textContent = character.name;
                
                // 2. 重置UI到待机状态，并给出引导
                clearTimeout(typewriterTimeout); // 确保清除上个角色的打字机动画
                $('#monitoring-status-text').textContent = '请点击下方按钮开始监控...';
                $('#monitoring-mood-text').textContent = '待机';
                $('#monitoring-mood-icon').textContent = '🫧';
                $('#monitoring-timestamp').textContent = '';
                // 确保按钮不是加载状态
                $('#monitoring-refresh-button i').className = 'ri-refresh-line';
                $('#monitoring-next-step-button i').className = 'ri-skip-forward-line';
                
                // 3. 显示屏幕
                showScreen('monitoring-screen');
                
                // 4. (已删除) 此处不再自动调用 getCharacterStatus(characterId)
            }



            function initializeAppIcons() {
                // 绑定返回按钮事件
                $('#monitoring-back-button').addEventListener('click', () => showScreen('home-screen'));
                $('#character-select-back-button').addEventListener('click', () => showScreen('home-screen'));


                
                // 激活"动态监控"App
                const monitoringAppIcon = document.querySelector('.app-icon[data-app-name="动态监控"]');
                if (monitoringAppIcon) {
                    monitoringAppIcon.addEventListener('click', () => {
                        renderCharacterSelectList();
                        showScreen('character-select-screen');
                    });
                }
                
                // 确保其他Dock栏图标功能正常
                const worldBookIcon = document.querySelector('.dock .app-icon[data-app-name="世界书"]');
                if (worldBookIcon) {
                    worldBookIcon.addEventListener('click', () => {
                        renderWorldBookList();
                        showScreen('world-book-list-screen');
                    });
                }

                const characterBookIcon = document.querySelector('.dock .app-icon[data-app-name="角色书"]');
                if (characterBookIcon) {
                    characterBookIcon.addEventListener('click', () => {
                        renderCharacterBookList();
                        showScreen('character-book-list-screen');
                    });
                }

                const wechatIcon = document.querySelector('.dock .app-icon[data-app-name="微信"]');
                if (wechatIcon) {
                    wechatIcon.addEventListener('click', () => {
                        renderWeChatList();
                        resetWeChatTabs();
                        showScreen('wechat-list-screen');
                    });
                }

                const settingsIcon = document.querySelector('.app-icon[data-app-name="设置"]');
                if (settingsIcon) {
                     settingsIcon.addEventListener('click', () => showScreen('main-settings-screen'));
                }
            }

            // ================== 动态监控 App 逻辑 (最终版V2 - 带角色选择) END ==================

            // 新增：智能滚动冲突处理函数
            function setupSmartScrollHandling() {
                const textContainer = document.getElementById('monitoring-text-container');
                if (!textContainer) return;

                // 确保文本框可以滚动
                textContainer.style.overflowY = 'auto';
                textContainer.style.webkitOverflowScrolling = 'touch'; // iOS 优化

                let isScrollingText = false;
                let scrollTimeout;

                // 监听文本框滚动事件
                textContainer.addEventListener('scroll', (e) => {
                    isScrollingText = true;
                    clearTimeout(scrollTimeout);
                    
                    // 300ms后重置状态
                    scrollTimeout = setTimeout(() => {
                        isScrollingText = false;
                    }, 300);
                });

                // 监听页面滚动事件
                document.addEventListener('wheel', (e) => {
                    if (isScrollingText) {
                        // 如果正在滚动文本框，阻止页面滚动
                        e.preventDefault();
                        return;
                    }

                    // 检查是否在文本框边缘
                    const rect = textContainer.getBoundingClientRect();
                    const isNearTextContainer = (
                        e.clientY >= rect.top - 20 && 
                        e.clientY <= rect.bottom + 20
                    );

                    if (isNearTextContainer) {
                        // 在文本框附近时，优先处理文本框滚动
                        const delta = e.deltaY;
                        if (delta > 0 && textContainer.scrollTop < textContainer.scrollHeight - textContainer.clientHeight) {
                            // 向下滚动，文本框还有内容
                            e.preventDefault();
                            textContainer.scrollTop += delta * 0.5;
                        } else if (delta < 0 && textContainer.scrollTop > 0) {
                            // 向上滚动，文本框还有内容
                            e.preventDefault();
                            textContainer.scrollTop += delta * 0.5;
                        }
                    }
                }, { passive: false });

                // 触摸设备支持 - 简化版本
                let touchStartY = 0;
                let touchStartScrollTop = 0;
                
                textContainer.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                    touchStartScrollTop = textContainer.scrollTop;
                    
                    // 检查是否触摸在滚动条区域
                    const touchX = e.touches[0].clientX;
                    const rect = textContainer.getBoundingClientRect();
                    const isOnScrollbarTouch = touchX >= rect.right - 16;
                    
                    if (isOnScrollbarTouch) {
                        console.log('📱 触摸滚动条区域开始');
                        textContainer.style.boxShadow = 'inset 0 0 10px rgba(190, 50, 85, 0.3)';
                    }
                });

                textContainer.addEventListener('touchmove', (e) => {
                    const touchY = e.touches[0].clientY;
                    const deltaY = touchStartY - touchY;
                    
                    if (Math.abs(deltaY) > 5) {
                        const maxScrollTop = textContainer.scrollHeight - textContainer.clientHeight;
                        const newScrollTop = touchStartScrollTop + deltaY;
                        
                        if (newScrollTop >= 0 && newScrollTop <= maxScrollTop) {
                            textContainer.scrollTop = newScrollTop;
                            console.log('📱 触摸滚动中:', {
                                deltaY: deltaY,
                                newScrollTop: newScrollTop,
                                maxScrollTop: maxScrollTop
                            });
                        }
                    }
                });

                textContainer.addEventListener('touchend', (e) => {
                    // 触摸结束，清除视觉反馈
                    textContainer.style.boxShadow = '';
                    console.log('📱 触摸滚动结束');
                });

                // 鼠标拖拽滚动条支持 - 重写版本
                let isDragging = false;
                let dragStartY = 0;
                let dragStartScrollTop = 0;

                // 更精确的滚动条检测
                function isOnScrollbar(e) {
                    const rect = textContainer.getBoundingClientRect();
                    
                    // 使用固定的滚动条宽度，与CSS中的12px保持一致
                    const scrollbarWidth = 12;
                    
                    // 检查是否在滚动条区域（右侧12px范围内）
                    const isInScrollbarArea = e.clientX >= rect.right - scrollbarWidth;
                    
                    console.log('🎯 滚动条检测:', {
                        clientX: e.clientX,
                        rectRight: rect.right,
                        scrollbarWidth: scrollbarWidth,
                        threshold: rect.right - scrollbarWidth,
                        isInScrollbarArea: isInScrollbarArea,
                        rect: rect
                    });
                    
                    return isInScrollbarArea;
                }

                textContainer.addEventListener('mousedown', (e) => {
                    if (isOnScrollbar(e)) {
                        isDragging = true;
                        dragStartY = e.clientY;
                        dragStartScrollTop = textContainer.scrollTop;
                        textContainer.style.cursor = 'grabbing';
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('✅ 开始拖拽滚动条');
                        
                        // 添加拖拽状态样式
                        textContainer.style.userSelect = 'none';
                        
                        // 添加拖拽时的视觉反馈
                        textContainer.style.boxShadow = 'inset 0 0 10px rgba(190, 50, 85, 0.3)';
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaY = e.clientY - dragStartY;
                        const newScrollTop = dragStartScrollTop + deltaY;
                        const maxScrollTop = textContainer.scrollHeight - textContainer.clientHeight;
                        
                        // 限制滚动范围
                        const clampedScrollTop = Math.max(0, Math.min(newScrollTop, maxScrollTop));
                        textContainer.scrollTop = clampedScrollTop;
                        
                        console.log('🔄 拖拽中:', {
                            deltaY: deltaY,
                            newScrollTop: newScrollTop,
                            clampedScrollTop: clampedScrollTop,
                            maxScrollTop: maxScrollTop
                        });
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        textContainer.style.cursor = 'default';
                        textContainer.style.userSelect = '';
                        textContainer.style.boxShadow = '';
                        console.log('✅ 拖拽结束');
                    }
                });

                // 防止拖拽时选中文本
                textContainer.addEventListener('selectstart', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                    }
                });

                // 添加点击滚动条跳转功能 - 优化版本
                textContainer.addEventListener('click', (e) => {
                    if (isOnScrollbar(e)) {
                        const rect = textContainer.getBoundingClientRect();
                        const clickY = e.clientY - rect.top;
                        const containerHeight = rect.height;
                        const scrollHeight = textContainer.scrollHeight;
                        const maxScrollTop = scrollHeight - containerHeight;
                        
                        // 计算点击位置对应的滚动位置
                        const newScrollTop = Math.max(0, Math.min(
                            (clickY / containerHeight) * scrollHeight, 
                            maxScrollTop
                        ));
                        
                        textContainer.scrollTop = newScrollTop;
                        console.log('🎯 点击滚动条跳转:', {
                            clickY: clickY,
                            containerHeight: containerHeight,
                            scrollHeight: scrollHeight,
                            newScrollTop: newScrollTop,
                            maxScrollTop: maxScrollTop
                        });
                    }
                });

                // 添加调试信息
                console.log('🎯 滚动条拖拽功能已初始化');
                console.log('📊 文本框信息:', {
                    scrollHeight: textContainer.scrollHeight,
                    clientHeight: textContainer.clientHeight,
                    scrollTop: textContainer.scrollTop,
                    overflowY: textContainer.style.overflowY,
                    computedOverflowY: window.getComputedStyle(textContainer).overflowY
                });
                

            }

            // 新增：智能滚动冲突处理
            setupSmartScrollHandling();

            // 1. 首先执行加载数据和基础设置
            await loadAllSavedData();
            updateTime();
            setInterval(updateTime, 60000);
            loadMomentsCover();
            loadMomentsUserInfo();
            console.log('智能朋友圈触发系统已初始化');
            showScreen('home-screen');

            // 2. 然后，为所有页面元素安全地绑定事件监听器
            initializeAppIcons();

            // 绑定其他必要的事件监听器
            $('#monitoring-refresh-button').addEventListener('click', () => {
                if (currentMonitoringCharacterId) {
                    getCharacterStatus(currentMonitoringCharacterId);
                }
            });

            // 新增：为"持续监控"按钮绑定事件
            $('#monitoring-next-step-button').addEventListener('click', () => {
                if (currentMonitoringCharacterId) {
                    // 调用核心函数，并告知这是一个"推演下一步"的任务
                    getCharacterStatus(currentMonitoringCharacterId, true);
                }
            });


            // 确保其他所有 .addEventListener 调用都在这个 'DOMContentLoaded' 内部
            // [新代码] - 重新激活所有页面的事件监听器
            addNewEventListeners();
            // [已修复] - 删除重复调用，避免事件重复绑定
            setupDrawingBoardEvents();
            setupTarotCard();
            
            // 添加约定模态框输入框焦点效果
            setupPlanModalEffects();

            // 启动AI心跳，让角色可以自主行动
            setInterval(systemHeartbeat, 60 * 60 * 1000); // 每1小时检查一次

        });

        // --- V8.0: 计划模块辅助函数 ---
        function formatPlansForAI(characterId) {
            if (!planData[characterId] || planData[characterId].length === 0) {
                return "（目前我们之间还没有任何约定。）";
            }
            return planData[characterId]
                .map(p => `- [${p.status}] ${p.title}`)
                .join('\n');
        }
        
        // 设置约定模态框的交互效果
        function setupPlanModalEffects() {
            const titleInput = document.querySelector('#plan-content');
            const characterSelect = document.querySelector('#plan-partner');
            const detailsInput = document.querySelector('#plan-notes');
            
            // 为所有输入框添加焦点时的微妙动画
            [titleInput, characterSelect, detailsInput].forEach(element => {
                if (element) {
                    element.addEventListener('focus', () => {
                        element.style.transform = 'scale(1.02)';
                        element.style.boxShadow = '0 0 20px rgba(220, 38, 38, 0.2)';
                    });
                    element.addEventListener('blur', () => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = '';
                    });
                }
            });
        }

        // ================== 页面加载完成后的总初始化 (修正版) END ==================

        // --- V8.1: 新增通话输入框高度自适应辅助函数 ---
        function adjustCallInputHeight(element) {
            element.style.height = 'auto';
            const maxHeight = 80; // 必须与CSS中的max-height保持一致
            if (element.scrollHeight > maxHeight) {
                element.style.height = `${maxHeight}px`;
                element.style.overflowY = 'auto';
            } else {
                element.style.height = `${element.scrollHeight}px`;
                element.style.overflowY = 'hidden';
            }
        }

        // --- V8.1: 新增AI通话回复显示函数（支持动作描写空行） ---
        function displayAICallResponse(type, response) {
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;

            const aiMsg = `${character.name}: ${response}`;

            // 核心修改：先将所有星号包裹的旁白替换为带换行和斜体标签的HTML
            // 然后再将文本中本身就有的换行符替换为<br>
            let formattedMsg = aiMsg.replace(/\*(.*?)\*/g, "<br><i>$1</i>");
            formattedMsg = formattedMsg.replace(/(\r\n|\n|\r)/gm, "<br>");

            // 如果消息处理后是以换行开头（即旁白在最前面），则移除第一个多余的换行
            if (formattedMsg.startsWith('<br>')) {
                formattedMsg = formattedMsg.substring(4).trim();
            }

            // 将处理好的内容追加到状态框，并保存原始信息到通话记录
            statusBox.innerHTML += `<p>${formattedMsg}</p>`;
            callHistory.push(response); // 只保存AI的原始回复内容
            statusBox.scrollTop = statusBox.scrollHeight;
        }

        // --- V8.1: 新增通话重试功能函数 ---
        async function handleCallRetry(type) {
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;

            // 查找最后一个用户输入
            let lastUserMessageIndex = -1;
            for (let i = callHistory.length - 1; i >= 0; i--) {
                if (callHistory[i].startsWith('你:')) {
                    lastUserMessageIndex = i;
                    break;
                }
            }
            
            let userInputForRetry = '';
            if (lastUserMessageIndex !== -1) {
                // 如果找到了用户输入，就以此为基础重试
                userInputForRetry = callHistory[lastUserMessageIndex].replace('你:', '').trim();
                // 移除此条用户消息之后的所有AI回复
                callHistory.splice(lastUserMessageIndex + 1);
            } else {
                // 如果历史记录里全是AI的话（不太可能，但作为保险），就移除最后一条
                callHistory.pop();
            }

            // 更新UI显示
            statusBox.innerHTML = callHistory.map(line => `<p>${line.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>')}</p>`).join('');
            statusBox.innerHTML += `<p><i>${character.name}正在重新思考...</i></p>`;
            statusBox.scrollTop = statusBox.scrollHeight;

            // 重新请求AI响应
            const aiResponse = await getAICallResponse(type, callHistory.length > 0, userInputForRetry);
            
            // 移除"正在思考"的提示
            statusBox.removeChild(statusBox.lastChild);

            // 使用新的displayAICallResponse函数显示新响应，支持动作描写空行
            displayAICallResponse(type, aiResponse);
        }

        // --- V11.0 新增：专属素材库管理功能 ---
        function renderCharacterExpressions(character) {
            const container = document.querySelector('#cb-expressions-container');
            if (!container) return;
            container.innerHTML = '';
            const expressions = character.expressions || [];

            if (expressions.length === 0) {
                container.innerHTML = '<p class="text-xs text-center text-gray-500">该角色暂无专属素材</p>';
                return;
            }

            expressions.forEach((expr, index) => {
                const item = document.createElement('div');
                item.className = 'flex items-start gap-2 p-1 bg-white/5 rounded text-xs';
                // 使用pre-wrap来保留HTML代码的换行和空格，便于查看
                item.innerHTML = `
                    <div class="flex-1 overflow-hidden">
                        <strong class="text-blue-400">${expr.keyword}:</strong>
                        <p class="whitespace-pre-wrap break-all opacity-80">${expr.content}</p>
                    </div>
                    <button class="text-red-500 font-bold p-1" data-index="${index}">×</button>
                `;
                item.querySelector('button').addEventListener('click', (e) => {
                    const char = characters.find(c => c.id === currentEditingCharacterId);
                    if (char && char.expressions) {
                        const idxToRemove = parseInt(e.target.dataset.index);
                        char.expressions.splice(idxToRemove, 1);
                        renderCharacterExpressions(char); // 重新渲染
                    }
                });
                container.appendChild(item);
            });
        }

        const addExpressionBtn = document.querySelector('#add-expression-btn');
        if(addExpressionBtn){
            addExpressionBtn.addEventListener('click', () => {
                const keywordInput = document.querySelector('#expression-keyword-input');
                const contentInput = document.querySelector('#expression-content-input');
                const keyword = keywordInput.value.trim();
                const content = contentInput.value.trim();

                if (!keyword || !content) {
                    return showMessageBox('关键词和素材内容都不能为空');
                }

                const character = characters.find(c => c.id === currentEditingCharacterId);
                if (character) {
                    if (!character.expressions) {
                        character.expressions = [];
                    }
                    character.expressions.push({ keyword, content });
                    renderCharacterExpressions(character); // 添加后立即更新显示
                    keywordInput.value = '';
                    contentInput.value = '';
                }
            });
        }

    // --- V12.1 新增：图片文件转Base64辅助函数 ---
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                // reader.result 包含 "data:image/jpeg;base64," 前缀，正是API需要的格式
                resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }
    
    </script>
</body>
</html>
